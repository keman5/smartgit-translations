:*"Cancel"=取消
:*"Add Branch"=创建分支
:*"Discard"=丢弃
:*"Git-Flow"=Git 工作流
:*"Commit"=提交
:*"Branch"=分支
:*"Check Out"=检出
:*"Merge"=合并
:*"Pull"=拉取
:*"Push"=推送
:*"Rebase"=变基
:*"Save Stash"=贮藏
:*"Stage"=暂存
:*"Sync"=同步
:*"Unstage"=取消暂存
:*"Deselect All"=取消全选
:*"Select All"=全选
:*"Output"=输出
:*"Repositories"=仓库
:*"Add Tag"=创建标签
:*"Apply Stash"=应用贮藏
:*"Working Tree"=工作区
:*"Refresh"=刷新
:*"Email"=电子邮箱

*.btn"< Back"=< 上一步
*.btn"Cancel"=取消
*.btn"Close"=关闭
*.btn"Finish"=完成
*.btn"Next >"=下一步 >
*.btn"OK"=确定
*.hnt"Filter"=过滤器
dlgCommit.replaceMessage.btn"Replace"=替换
dlgCommit.replaceMessage.chk=始终替换
dlgCommit.replaceMessage.fur=替换后，您可以在单击历史记录按钮时找到上一条消息。
dlgCommit.replaceMessage.hdl=是否替换现有消息？
dlgCommit.replaceMessage.tle=替换消息
dlgDgAbout.edt"Build Date"=编译日期
dlgDgAbout.edt"Email"=电子邮箱
dlgDgAbout.edt"Java Version"=Java 版本
dlgDgAbout.edt"Maximum Heap"=最大内存
dlgDgAbout.edt"Name"=用户名
dlgDgAbout.edt"Settings Path"=设置路径
dlgDgAbout.edt"Version"=版本
dlgDgAbout.tab"Credits"=基本信息
dlgDgAbout.tab"Information"=软件信息
dlgDgAbout.tab"Licensee"=授权信息
dlgDgAbout.tle=关于 DeepGit
dlgDgRefMapperGroupConfig.hdl=配置此仓库的标记分组模式
dlgDgRefMapperGroupConfig.inf=标签, 分支以及与此配置匹配的其他引用将显示在导航图中.
dlgDgRefMapperGroupConfig.tle=配置标记分组
dlgDgSetEncoding.edt"Text File Encoding"=文本文件编码
dlgDgSetEncoding.hdl=配置编码
dlgDgSetEncoding.inf=指定应用于处理和查看文件的编码。请注意,UTF-8 编码将自动检测到,而不考虑此处的配置。
dlgDgSetEncoding.tle=设置编码
dlgDgSetPerspectiveCantSwitch.fur=为审查可能的起源, 必须先对它们进行评估. 先在提交视图中选择1行. 然后等待完成查找可能的起源.
dlgDgSetPerspectiveCantSwitch.hdl=无法切换视角.
dlgDgSetPerspectiveCantSwitch.tle=原始视角
dlgInfo.tle=丢弃
dlgProgress.btn"Stop"=停止
dlgProgress.tle"Checking connectivity"=检查连接
dlgProgress.tle"Checking push conditions"=检查推送条件
dlgProgress.tle"JIRA"=JIRA
dlgProgress.tle"Jump To"=跳转到
dlgProgress.tle"Layouting Graph"=布局图
dlgProgress.tle"Refresh"=刷新
dlgProgress.tle"Reveal Commit"=显示提交
dlgProgress.tle"SmartGit Installation Update"=SmartGit 安装更新
dlgProgress.tle"Upgrade"=升级
dlgQBugFileSendingFailed.fur%1=也许您需要配置代理才能访问我们服务器或我们的服务器暂时关闭。\n详情：$1
dlgQBugFileSendingFailed.hdl%1=无法将崩溃记录发送到 $1
dlgQBugFileSendingFailed.tle=本机崩溃记录
dlgQBugReportSend.btn"Force Exit"=强制退出
dlgQBugReportSend.btn"Ignore \(Dangerous\)"=忽略 \(危险\)
dlgQBugReportSend.btn"Just Exit"=仅退出
dlgQBugReportSend.btn"Report && Exit"=报告并退出
dlgQBugReportSend.btn"Report Bug"=反馈 Bug
dlgQBugReportSend.edt"Comments or Steps to Reproduce"=重现注释或步骤
dlgQBugReportSend.edt"Email"=电子邮箱
dlgQBugReportSend.edt"Reply To"=回复
dlgQBugReportSend.lbl"Sorry for the trouble!"=我们对此感到抱歉!
dlgQBugReportSend.tle=内部错误
dlgQDockManagerClosedView.chk=不再显示
dlgQDockManagerClosedView.fur=要再次重新打开，请使用窗口菜单中的相应菜单项。
dlgQDockManagerClosedView.hdl%1=您已经关闭了视图 $1。
dlgQDockManagerClosedView.tle=关闭视图
dlgQFileSaveAcceptFilterOverwrite.btn"Overwrite"=覆盖
dlgQFileSaveAcceptFilterOverwrite.fur=要保存到其他文件，请单击 “取消”。
dlgQFileSaveAcceptFilterOverwrite.hdl%1=文件 $1 已存在。你确定覆盖吗？
dlgQFileSaveAcceptFilterOverwrite.tle=覆盖文件
dlgQFrameManagerExit.btn"Discard Changes && Exit"=放弃变更并退出
dlgQFrameManagerExit.fur=存在未保存的变更，这些变更将在退出时丢失!
dlgQFrameManagerExit.hdl=是否确定要退出 SmartGit ？
dlgQFrameManagerExit.tle=退出
dlgQIntegerInputProviderInvalidValue.fur%2=端口必须在 $1 到 $2 的范围内。
dlgQIntegerInputProviderInvalidValue.hdl%1=字段 “$1” 中的文本无效。
dlgQIntegerInputProviderInvalidValue.tle=输入验证
dlgQProxyConfigure.chk"Proxy requires authentication"=代理需要身份验证
dlgQProxyConfigure.edt"Host"=服务器
dlgQProxyConfigure.edt"Password"=密码
dlgQProxyConfigure.edt"Port"=端口
dlgQProxyConfigure.edt"Username"=用户名
dlgQProxyConfigure.lbl"Note: The password will be stored in plain text in SmartGit's configuration area!"=\
 注意：密码将以明文形式存储在 SmartGit 的配置区域中！
dlgQProxyConfigure.rbt"Auto-detect the system proxy"=自动检测系统代理
dlgQProxyConfigure.rbt"Don't use a proxy"=不使用代理
dlgQProxyConfigure.rbt"Use following proxy"=使用以下代理
dlgQProxyConfigure.tle=设置代理
dlgQProxyConnectionFailed.btn"Configure Proxy"=配置代理
dlgQProxyConnectionFailed.btn"Retry"=重试
dlgQProxyConnectionFailed.fur=详情：syntevo.com
dlgQProxyConnectionFailed.hdl%1=无法连接到 $1。
dlgQProxyConnectionFailed.tle=连接失败
dlgQUpdateCheckForNewVersion.btn"Configure Proxy"=配置代理
dlgQUpdateCheckForNewVersion.btn"Exit"=退出
dlgQUpdateCheckForNewVersion.btn"Retry"=重试
dlgQUpdateCheckForNewVersion.btn"Skip"=跳过
dlgQUpdateCheckForNewVersion.hdl=SmartGit 需要检查更新
dlgQUpdateCheckForNewVersion.inf=如果需要，请配置代理并重试。
dlgQUpdateCheckForNewVersion.tle=检查新版本
dlgQUpdateCheckForNewVersionFailed.fur%1=详细信息：无法连接到 “$1”。
dlgQUpdateCheckForNewVersionFailed.hdl=检查新版本失败。
dlgQUpdateCheckForNewVersionFailed.tle=检查新版本
dlgQUpdateCheckLatestBuild.btn"Get Latest Build"=确认
dlgQUpdateCheckLatestBuild.fur=仅在支持团队要求时使用最新版本。
dlgQUpdateCheckLatestBuild.hdl=您确定要下载最新编译版本吗？
dlgQUpdateCheckLatestBuild.tle=检查最新编译版本
dlgQUpdateCheckLatestBuildFetchFailed.fur%1=详细信息：$1
dlgQUpdateCheckLatestBuildFetchFailed.hdl=初始化升级失败。
dlgQUpdateCheckLatestBuildFetchFailed.tle=检查最新编译版本
dlgQUpdateCheckNewVersion.btn"Download"=下载
dlgQUpdateCheckNewVersion.fur=建议更新到新版
dlgQUpdateCheckNewVersion.hdl=发现版本更新
dlgQUpdateCheckNewVersion.tle=检测更新
dlgQUpdateCheckNoNewerLatestBuild.fur=您已经在使用最新编译版本。
dlgQUpdateCheckNoNewerLatestBuild.hdl=未找到需要更新的编译版本
dlgQUpdateCheckNoNewerLatestBuild.tle=检查最新编译版本
dlgQUpdateCheckNowNewerVersion.fur=当前版本已是最新
dlgQUpdateCheckNowNewerVersion.hdl=未找到需要更新的版本
dlgQUpdateCheckNowNewerVersion.tle=检查新版本
dlgRewriteTextFiles.btn"Fix Line-Endings"=修复行尾序列
dlgRewriteTextFiles.chk"Enforce line-ending on end of file"=\
 在文件末尾强制使用行尾序列
dlgRewriteTextFiles.edt"Line-Endings"=行尾序列
dlgRewriteTextFiles.hdl=用选定的行尾序列重写文本文件
dlgRewriteTextFiles.inf=选择应用于写入文本文件的行尾序列。
dlgRewriteTextFiles.tle=修复行尾序列
dlgScAboutUpdateInstallation.btn"Upgrade Installation"=安装升级
dlgScAboutUpdateInstallation.fur=这将需要些时间，必须重新启动 SmartGit。
dlgScAboutUpdateInstallation.hdl%1=是否要将安装目录升级到版本 $1？
dlgScAboutUpdateInstallation.tle=升级安装
dlgScApplicationStarterRestart.btn"Exit"=退出
dlgScApplicationStarterRestart.btn"Remind Later"=稍后提醒
dlgScApplicationStarterRestart.btn"Restart"=重新启动
dlgScApplicationStarterRestart.fur=下载的程序在重启后生效。
dlgScApplicationStarterRestart.hdl=SmartGit 需要重新启动。
dlgScApplicationStarterRestart.tle=重新启动
dlgScConflictSolverAdd.hdl=添加冲突解决方案
dlgScConflictSolverAdd.tle=添加
dlgScConflictSolverEdit.hdl=变基冲突解决方案
dlgScConflictSolverEdit.tle=编辑
dlgScConflictSolverInconsistentLineEndings.fur=合并文件内容包含混合不一致的行尾序列. 如果这些行尾序列有意混合, 保存此文件时请确保不要覆盖它们.
dlgScConflictSolverInconsistentLineEndings.hdl=文件包含混合不一致的行尾序列.
dlgScConflictSolverInconsistentLineEndings.tle%1=\[$1\] - 冲突解决工具
dlgScConflictSolverUnresolvedConflicts.chk=不再显示警告
dlgScConflictSolverUnresolvedConflicts.fur=并非所有冲突都已得到解决。
dlgScConflictSolverUnresolvedConflicts.hdl=你想关闭冲突解决工具吗？
dlgScConflictSolverUnresolvedConflicts.tle=未解决的冲突
dlgScConflictSolver(Add|Edit).edt"Arguments"=参数
dlgScConflictSolver(Add|Edit).edt"Command"=命令
dlgScConflictSolver(Add|Edit).edt"File Pattern"=文件模式
dlgScConflictSolver(Add|Edit).inf=定义文件模式 \(例如：\*.txt\) 并选择合并工具，该工具用于解决与此模式匹配的冲突文件。
dlgScConflictSolver(Add|Edit).lbl"Valid wildcards are ?\u00a0\(one arbitrary character\) and \*\u00a0\(any number of arbitrary characters\). Separate multiple patterns by comma. Example:\u00a0\*.txt,\u00a0\*.html"=\
 有效的通配符是 ?\u00a0\(一个任意字符\)和\*\u00a0\(任意数量的任意字符\)。用逗号分隔多个模式。例如：\u00a0\*.txt,\u00a0\*.html。
dlgScConflictSolver(Add|Edit).lbl"You must use the variables \$\{leftFile\}, \$\{rightFile\} and \$\{mergedFile\}."=\
 必须使用 \$\{leftFile\}, \$\{rightFile\} 和 \$\{mergedFile\} 变量.
dlgScConflictSolver(Add|Edit).mni"Base File"=基准文件
dlgScConflictSolver(Add|Edit).mni"Encoding"=编码
dlgScConflictSolver(Add|Edit).mni"Left File"=左侧文件
dlgScConflictSolver(Add|Edit).mni"Left Title"=左侧文件标题
dlgScConflictSolver(Add|Edit).mni"Merged File"=已合并文件
dlgScConflictSolver(Add|Edit).mni"Merged Title"=已合并文件标题
dlgScConflictSolver(Add|Edit).mni"Right File"=右侧文件
dlgScConflictSolver(Add|Edit).mni"Right Title"=右侧文件标题
dlgScConflictSolver(Add|Edit).rbt"Built-in Conflict Solver"=内置冲突解决工具
dlgScConflictSolver(Add|Edit).rbt"External Conflict Solver"=外部冲突解决工具
dlgScCustomizeAccelerators.btn"Assign"=分配
dlgScCustomizeAccelerators.btn"Clear"=清除
dlgScCustomizeAccelerators.btn"Reset"=重置
dlgScCustomizeAccelerators.col"Accelerator"=快捷键
dlgScCustomizeAccelerators.col"Default"=默认
dlgScCustomizeAccelerators.col"Menu Item"=菜单项
dlgScCustomizeAccelerators.edt"Accelerator"=快捷键
dlgScCustomizeAccelerators.hdl=自定义加速器
dlgScCustomizeAccelerators.inf=双击要更改的快捷键菜单项，然后按加速器键并单击 “分配” 按钮。
dlgScCustomizeAccelerators.tle=自定义
dlgScCustomizeToolBar.btn"Add"=添加
dlgScCustomizeToolBar.btn"Remove"=移除
dlgScCustomizeToolBar.btn"Reset to Default"=重置为默认值
dlgScCustomizeToolBar.chk"Show text below icon"=在图标下方显示文本
dlgScCustomizeToolBar.col"Available"=可用
dlgScCustomizeToolBar.col"Selected"=选择
dlgScCustomizeToolBar.tle=配置工具栏
dlgScDevOpsCredentials.btn"Login"=登录
dlgScDevOpsCredentials.chk"Store password"=存储密码
dlgScDevOpsCredentials.edt"Password"=密码
dlgScDevOpsCredentials.edt"User Name"=用户名
dlgScDevOpsCredentials.hdl%1=登录 “$1”
dlgScDevOpsCredentials.inf=提供用于向 JIRA 进行身份验证的用户名和密码。
dlgScDevOpsCredentials.tle=登录到 JIRA
dlgScDevOpsCredentials.wrn"HTTP response code $1"=HTTP 响应代码 $1
dlgScDevOpsSslClientCertificate.btn"Login"=登录
dlgScDevOpsSslClientCertificate.chk"Store passphrase"=存储密码
dlgScDevOpsSslClientCertificate.edt"Certificate"=证书
dlgScDevOpsSslClientCertificate.edt"Passphrase"=密码
dlgScDevOpsSslClientCertificate.hdl%1=选择 $1 的客户端证书
dlgScDevOpsSslClientCertificate.inf=选择用于向 JIRA 进行身份验证的客户端证书文件。
dlgScDevOpsSslClientCertificate.tle=JIRA 客户证书
dlgScDevOpsSslClientCertificate.wrn"$1"=$1
dlgScDevOpsSslFingerprintNew.btn"Accept"=接受
dlgScDevOpsSslFingerprintNew.btn"Reject"=拒绝
dlgScDevOpsSslFingerprintNew.edt"MD5 fingerprint"=MD5 指纹
dlgScDevOpsSslFingerprintNew.edt"SHA fingerprint"=SHA 指纹
dlgScDevOpsSslFingerprintNew.edt"Server"=服务器
dlgScDevOpsSslFingerprintNew.lbl"Is the following server fingerprint correct?"=\
 以下服务器指纹是否正确？
dlgScDevOpsSslFingerprintNew.lbl"When in doubt, contact your server administrator."=\
 如有疑问，请与你的服务器管理员联系。
dlgScDevOpsSslFingerprintNew.tle=SSL 身份验证
dlgScDialogAssertionHandler.btn"Send Logs"=发送记录
dlgScDialogAssertionHandler.edt"Details on frequency of the problem \(or steps to reproduce\)"=\
 问题详细描述 \(或复现步骤\)
dlgScDialogAssertionHandler.edt"Email"=电子邮箱
dlgScDialogAssertionHandler.edt"Optional comments or steps to reproduce \(in case you still recall\)"=\
 可选的评论注释或重现步骤 \(如果您还记得\)
dlgScDialogAssertionHandler.lbl"SmartGit has crashed due to insufficient system memory"=\
 SmartGit 由于系统内存不足而崩溃
dlgScDialogAssertionHandler.tle=本机崩溃记录
dlgScDialogAssertionHandlerLinkageError.btn"Copy"=复制
dlgScDialogAssertionHandlerLinkageError.btn"Force Exit"=强制退出
dlgScDialogAssertionHandlerLinkageError.lbl"SmartGit has detected inconsistencies within its installation files \(JAR files\), what has most likely been caused by a faulty installation.\n\nPlease uninstall SmartGit completely, make sure there are no more installation files left \(especially JAR files\), then reinstall.\n\nIf the problem persists, send following log file as an attachment to smartgit@syntevo.com."=\
 SmartGit 已检测到其安装文件 \(JAR 文件\) 中的不一致，这很可能是由安装错误引起的。\n\n请完全卸载 SmartGit，确保没有剩余的安装文件 \(尤其是 JAR 文件\) ，然后重新安装。\n\n如果问题仍然存在，请将以下记录文件作为附件发送到 smartgit@syntevo.com。
dlgScDialogAssertionHandlerLinkageError.tle=内部错误
dlgScEvaluationReminderContinue.btn"Continue"=继续
dlgScEvaluationReminderContinue.btn"Register"=注册
dlgScEvaluationReminderContinue.fur%2=在商业环境中使用 SmartGit，您必须 \[$1 购买许可证 \]。\n\n对于 \[$2 某些用途 \]，我们授予免费许可证。
dlgScEvaluationReminderContinue.hdl%1=您的 SmartGit 试用将在 $1 天后结束。
dlgScEvaluationReminderContinue.tle=试用
dlgScExternalFileStarterCommandInvocationFailed.hdl%2=无法运行 "$1": $2
dlgScExternalFileStarterCommandInvocationFailed.tle%1=\[$1\] - 冲突解决工具
dlgScFileComparatorAdd.hdl=添加外部差异工具
dlgScFileComparatorAdd.mni"Base Encoding"=基准编码
dlgScFileComparatorAdd.mni"Base File"=基准文件
dlgScFileComparatorAdd.mni"Base Title"=基准标题
dlgScFileComparatorAdd.tle=添加
dlgScFileComparatorEdit.hdl=编辑外部差异工具
dlgScFileComparatorEdit.mni"Base Encoding"=基准编码
dlgScFileComparatorEdit.mni"Base File"=基准文件
dlgScFileComparatorEdit.mni"Base Title"=基准标题
dlgScFileComparatorEdit.tle=编辑
dlgScFileComparator(Add|Edit).edt"Arguments"=参数
dlgScFileComparator(Add|Edit).edt"Command"=命令
dlgScFileComparator(Add|Edit).edt"File Pattern"=文件模式
dlgScFileComparator(Add|Edit).inf=定义文件模式 \(例如：\*.png\) 并选择比较命令，该命令应用于比较与文件模式匹配的文件。
dlgScFileComparator(Add|Edit).lbl"Valid wildcards are ?\u00a0\(one arbitrary character\) and \*\u00a0\(any number of arbitrary characters\). Separate multiple patterns by comma. Example:\u00a0\*.txt,\u00a0\*.html"=\
 有效的通配符是 ?\u00a0\(一个任意字符\)和\*\u00a0\(任意数量的任意字符\)。用逗号分隔多个模式。例如：\u00a0\*.txt,\u00a0\*.html。
dlgScFileComparator(Add|Edit).mni"File"=文件
dlgScFileComparator(Add|Edit).mni"Left Encoding"=左侧编码
dlgScFileComparator(Add|Edit).mni"Left File"=左侧文件
dlgScFileComparator(Add|Edit).mni"Left Local File"=左侧本地文件
dlgScFileComparator(Add|Edit).mni"Left Title"=左侧标题
dlgScFileComparator(Add|Edit).mni"Right Encoding"=右侧编码
dlgScFileComparator(Add|Edit).mni"Right File"=右侧文件
dlgScFileComparator(Add|Edit).mni"Right Local File"=右侧本地文件
dlgScFileComparator(Add|Edit).mni"Right Title"=右侧标题
dlgScFileComparator(Add|Edit).rbt"Built-in file compare"=内置文件比较
dlgScFileComparator(Add|Edit).rbt"External diff tool:"=外部差异工具：
dlgScFileComparator(Add|Edit).rbt"External viewer \(invoked for both compared files\):"=\
 外部查看器 \(两个文件比较时使用\)
dlgScFileCompareFileChanged.btn"Discard"=丢弃
dlgScFileCompareFileChanged.btn"Save"=保存
dlgScFileCompareFileChanged.fur=如果您不保存更改，您的更改将会丢失。
dlgScFileCompareFileChanged.hdl=你确定要保存更改吗？
dlgScFileCompareFileChanged.tle=文件已更改
dlgScFileCompareSaveAll.btn"Discard Changes"=丢弃变更
dlgScFileCompareSaveAll.btn"Save"=保存
dlgScFileCompareSaveAll.chk"Left file"=左侧文件
dlgScFileCompareSaveAll.chk"Right file"=右侧文件
dlgScFileCompareSaveAll.hdl=保存文件变更
dlgScFileCompareSaveAll.inf=确定要保存的文件内容.
dlgScFileCompareSaveAll.tle=保存变更
dlgScFilePatternsEdit.edt"File Pattern"=文件模式
dlgScFilePatternsEdit.hdl%1=语言：$1
dlgScFilePatternsEdit.inf=文件模式用于确定文件语言，该文件用于语法着色。
dlgScFilePatternsEdit.lbl"Valid wildcards are ?\u00a0\(one arbitrary character\) and \*\u00a0\(any number of arbitrary characters\). Separate multiple patterns by comma. Example:\u00a0\*.txt,\u00a0\*.html"=\
 有效的通配符是 ?\u00a0\(一个任意字符\)和\*\u00a0\(任意数量的任意字符\)。用逗号分隔多个模式。例如：\u00a0\*.txt,\u00a0\*.html。
dlgScFilePatternsEdit.tle=文件模式
dlgScFindAction.edt"Action name"=命令
dlgScFindAction.tle=查找命令
dlgScHostKeyVerifier.btn"Accept"=接受
dlgScHostKeyVerifier.btn"Reject"=拒绝
dlgScHostKeyVerifier.edt"Fingerprint"=指纹
dlgScHostKeyVerifier.edt"Server"=服务器
dlgScHostKeyVerifier.fur=如果您不确定，请与管理员联系。
dlgScHostKeyVerifier.hdl=请确认 SSH 服务器指纹。
dlgScHostKeyVerifier.tle=SSH 服务器验证
dlgScJiraCommitMessageSelect.btn"Refresh"=刷新
dlgScJiraCommitMessageSelect.btn"Reset to default"=重置为默认
dlgScJiraCommitMessageSelect.btn"Select"=选择
dlgScJiraCommitMessageSelect.chk"Query Configuration"=查询配置
dlgScJiraCommitMessageSelect.col"Fix Version"=修复版本
dlgScJiraCommitMessageSelect.col"Key"=键
dlgScJiraCommitMessageSelect.col"Status"=状态
dlgScJiraCommitMessageSelect.col"Summary"=摘要
dlgScJiraCommitMessageSelect.hdl=按 JIRA 问题选择提交消息
dlgScJiraCommitMessageSelect.inf=选定的问题摘要将用作提交消息。
dlgScJiraCommitMessageSelect.lbl"Enter the JQL-Queries which will be loaded in the specified order: every query on a new line, \$\{projects\} will be substituted by the JIRA project key\(s\) which is derived or explicitly specified in your .gitbugtraq file.\n\nYou can compose a JQL query directly in JIRA, using Issues\|Search and go to Advanced view there."=\
 输入将按指定顺序加载的 JQL 查询：新行上的每个查询，\$\{projects\} 将替换为 .gitbugtraq 文件中派生或明确指定的 JIRA 项目密钥。\r\n您可以直接在 JIRA 中编写 JQL 查询，使用问题|搜索并转到高级视图。
dlgScJiraCommitMessageSelect.lbl"Load All Issues"=加载所有问题
dlgScJiraCommitMessageSelect.lbl"Query Configuration"=查询配置
dlgScJiraCommitMessageSelect.tle=选择问题
dlgScJiraResolveIssue.btn"Don't Resolve"=不解决
dlgScJiraResolveIssue.btn"Ignore"=忽略
dlgScJiraResolveIssue.btn"Resolve Issue"=解决问题
dlgScJiraResolveIssue.btn"Resolve"=解决
dlgScJiraResolveIssue.edt"Resolution"=解决
dlgScJiraResolveIssue.edt"Summary"=摘要
dlgScJiraResolveIssue.hdl%1=解决问题 $1
dlgScJiraResolveIssue.inf=选择是否解决此问题以及要标记为已解决的版本。
dlgScJiraResolveIssue.tle=解决 JIRA 问题
dlgScMasterPasswordChange.edt"Current Master Password"=当前主密码
dlgScMasterPasswordChange.edt"New Master Password"=新主密码
dlgScMasterPasswordChange.edt"Retype New Master Password"=再次输入
dlgScMasterPasswordChange.hdl=更改或重置主密码
dlgScMasterPasswordChange.inf=要更改主密码，请输入当前密码。要没有主密码，请将字段留空。
dlgScMasterPasswordChange.lbl"When setting a new master password, all stored passwords and passphrases will be lost and need to be re-entered when required!"=\
 设置新的主密码时，所有存储的密码和口令都将丢失，需要时需要重新输入！
dlgScMasterPasswordChange.rbt"Change master password"=更改主密码
dlgScMasterPasswordChange.rbt"Set new master password"=设置新的主密码
dlgScMasterPasswordChange.tle=更改主密码
dlgScMasterPasswordCreate.edt"Master Password"=主密码
dlgScMasterPasswordCreate.edt"Retype Again"=重新输入
dlgScMasterPasswordCreate.hdl=配置加密密码存储的主密码
dlgScMasterPasswordCreate.inf=主密码用于保护用于向服务器进行身份验证的密码和口令。
dlgScMasterPasswordCreate.lbl"Not using a master password makes your passwords and passphrases readable for everyone who has access to the password file located at $1. Use this option only if you are sure that this file is safe."=\
 不使用主密码使您的密码和密码短语对访问位于 $1 的密码文件的每个人都是可读的。仅当您确定此文件安全时才使用此选项。
dlgScMasterPasswordCreate.lbl"This master password is case-sensitive and should contain lowercase and uppercase characters, digits and other characters. Longer passwords are in general more secure than shorter ones."=\
 此主密码区分大小写，应包含小写和大写字符、数字和其他字符。长密码通常比短密码更安全。
dlgScMasterPasswordCreate.rbt"Don't use a master password"=不要使用主密码
dlgScMasterPasswordCreate.rbt"Use the following master password"=使用以下主密码
dlgScMasterPasswordCreate.tle=主密码
dlgScMasterPasswordEnter.edt"Master Password"=主密码
dlgScMasterPasswordEnter.hdl=输入主密码
dlgScMasterPasswordEnter.inf=已从密码库中申请了存储的密码或口令。
dlgScMasterPasswordEnter.tle=密码
dlgScNotificationUpdateCheckHandlerUpdateFailure.fur=无法启动进程.
dlgScNotificationUpdateCheckHandlerUpdateFailure.hdl=更新程序启动失败.
dlgScNotificationUpdateCheckHandlerUpdateFailure.tle=SmartGit 安装更新
dlgScPasswordMasterChangeSuccessfulChange.fur=请务必记住它，否则您将无法再访问您存储的密码。
dlgScPasswordMasterChangeSuccessfulChange.hdl=主密码已更改。
dlgScPasswordMasterChangeSuccessfulChange.tle=更改主密码
dlgScPropertiesReset.btn"Reset"=重置
dlgScPropertiesReset.fur=新值只有在重新启动 SmartGit 后才会激活。
dlgScPropertiesReset.hdl%1=是否要将系统属性 $1 重置为默认值？
dlgScPropertiesReset.tle=重置属性
dlgScPropertyEdit.edt"Value"=值
dlgScPropertyEdit.hdl=编辑低级属性值
dlgScPropertyEdit.inf%1=设置属性 “$1” 的值
dlgScPropertyEdit.rbt"false"=假
dlgScPropertyEdit.rbt"true"=真
dlgScPropertyEdit.tle=编辑属性
dlgScRegisterFormLicenseConfirmDetails.edt"Add-on"=附加组件
dlgScRegisterFormLicenseConfirmDetails.edt"Address"=地址
dlgScRegisterFormLicenseConfirmDetails.edt"Email"=电子邮箱
dlgScRegisterFormLicenseConfirmDetails.edt"Free Updates Until"=免费更新有效期
dlgScRegisterFormLicenseConfirmDetails.edt"Name"=用户名
dlgScRegisterFormLicenseConfirmDetails.edt"Support Until"=技术支持有效期
dlgScRegisterFormLicenseConfirmDetails.edt"User Count"=用户计数
dlgScRegisterFormLicenseConfirmDetails.tle=SmartGit 许可证
dlgScRegisterFreeUpdatesExpiredLicense.btn"Purchase Update"=购买更新
dlgScRegisterFreeUpdatesExpiredLicense.fur=您可以使用旧的 SmartGit 版本或购买更新许可证。
dlgScRegisterFreeUpdatesExpiredLicense.hdl=此许可证的免费更新期不包括此版本。
dlgScRegisterFreeUpdatesExpiredLicense.tle=SmartGit 许可证
dlgScRegisterRequestRejected.fur=许可证服务器拒绝了该请求。请手动注册你通过电子邮件得到的最新许可文件，或稍后再试。
dlgScRegisterRequestRejected.hdl=更新许可文件失败。
dlgScRegisterRequestRejected.tle=SmartGit 许可证
dlgScSetupLicense.btn"Configure Proxy"=设置代理
dlgScSetupLicense.btn"Purchase Update"=购买更新
dlgScSetupLicense.btn"Register"=注册产品
dlgScSetupLicense.edt"License File"=许可证文件
dlgScSetupLicense.hdl=注册许可证文件
dlgScSetupLicense.inf=请提供您在购买后通过电子邮件收到的 SmartGit 许可文件。
dlgScSetupLicense.tle=SmartGit 许可证
dlgScSpellCheckDictionaryAdd.hdl=添加拼写检查字典
dlgScSpellCheckDictionaryAdd.tle=添加
dlgScSpellCheckDictionaryEdit.hdl=编辑拼写检查字典
dlgScSpellCheckDictionaryEdit.tle=编辑
dlgScSpellCheckDictionary(Add|Edit).edt"Dictionary File"=字典文件
dlgScSpellCheckDictionary(Add|Edit).edt"Name"=名称
dlgScSpellCheckDictionary(Add|Edit).inf=指定拼写字典文件 \(例如:\*.dic 来自 Mozilla Firefox 或 Thunderbird 的 “词典” 目录\). 该名称用来切换不同的字典。
dlgScSslFingerprint.btn"Accept"=接受
dlgScSslFingerprint.btn"Reject"=拒绝
dlgScSslFingerprint.edt"SHA fingerprint"=SHA 指纹
dlgScSslFingerprint.edt"Server"=服务器
dlgScSslFingerprint.lbl"The server fingerprint has changed! Is the change correct?"=\
 服务器指纹已更改！ 变化是否正确？
dlgScSslFingerprint.lbl"This might indicate a security problem! When in doubt, contact your server administrator."=\
 这可能表示存在安全问题！ 如有疑问，请与服务器管理员联系。
dlgScSslFingerprint.tle=服务器指纹
dlgScTextFinderFindFromEnd.btn"Find from End"=从后向前查找
dlgScTextFinderFindFromEnd.fur=从文档开头未找到结果.
dlgScTextFinderFindFromEnd.hdl=是否从文档末尾继续?
dlgScTextFinderFindFromEnd.tle=查找文件
dlgScTextFinderFindFromStart.btn"Find from Beginning"=从头查找
dlgScTextFinderFindFromStart.fur=直到文档底部无法查找更多文本
dlgScTextFinderFindFromStart.hdl=您想从文档的开头继续查找吗？
dlgScTextFinderFindFromStart.tle=查找文本
dlgScTextFinderNothingFound.hdl=没有找到 \(更多\) 文本。
dlgScTextFinderNothingFound.tle=查找文本
dlgScTextMultiComponentGoToLine.edt"Line Number"=行号
dlgScTextMultiComponentGoToLine.tle=转到行
dlgScTextMultiComponentSyntaxHighlightingSelection.tle=选择语法-高亮显示
dlgScTextReplace.btn"< Find"=向上查找
dlgScTextReplace.btn"Find >"=向下查找
dlgScTextReplace.btn"Replace All"=全部替换
dlgScTextReplace.btn"Replace"=替换
dlgScTextReplace.chk"Case-sensitive"=区分大小写
dlgScTextReplace.chk"Regular Expression search"=正则表达式
dlgScTextReplace.chk"Replace With:"=替换为：
dlgScTextReplace.edt"Text to Find"=查找文本
dlgScTextReplace.tle=查找并替换
dlgScTextSettings.chk"Coalesce nearby change blocks"=合并附近的变更块
dlgScTextSettings.chk"Split leading/trailing added or removed lines into separate blocks"=\
 将创建或删除的前导/尾随行拆分为单独的块
dlgScTextSettings.chk"Trim equal start/end of Inner-Line changes"=\
 修剪内线变化的相等开始/结束
dlgScTextSettings.edt"Inner-Line Comparison"=内线比较
dlgScTextSettings.edt"Show Whitespaces"=显示空格
dlgScTextSettings.edt"Tab Size"=Tab 大小
dlgScTextSettings.rbt"All"=所有
dlgScTextSettings.rbt"Alphanumeric words"=字母数字
dlgScTextSettings.rbt"C identifiers"=C 标识符
dlgScTextSettings.rbt"Character-based"=基于字符
dlgScTextSettings.rbt"Java identifiers"=Java 标识符
dlgScTextSettings.rbt"None"=不显示
dlgScTextSettings.rbt"Off"=关闭
dlgScTextSettings.rbt"Trailing and changed"=跟踪和变更
dlgScTextSettings.tab"Compare"=比较
dlgScTextSettings.tab"General"=常规
dlgScTextSettings.tle=设置
dlgScUpdateInstallationUpdateManuallyFailure.fur=进程无法启动.
dlgScUpdateInstallationUpdateManuallyFailure.hdl=更新程序启动失败.
dlgScUpdateInstallationUpdateManuallyFailure.tle=SmartGit 安装更新
dlgScUpdateInstallationUpdateManuallyInfo.fur%1=请手动删除 '$1' 并重试.
dlgScUpdateInstallationUpdateManuallyInfo.hdl=清除更新程序目录失败.
dlgScUpdateInstallationUpdateManuallyInfo.tle=SmartGit 安装更新
dlgScUpdateInstallationUpgrade.btn"Upgrade Now"=立即升级
dlgScUpdateInstallationUpgrade.fur%1=新版本 $1 已经下载，需要安装。
dlgScUpdateInstallationUpgrade.hdl=是否要立即升级 SmartGit？
dlgScUpdateInstallationUpgrade.tle=升级 SmartGit
dlgSelectDiff.col"Command"=命令
dlgSelectDiff.hdl=选择比较工具
dlgSelectDiff.inf=选择应使用的匹配比较工具。
dlgSelectDiff.tle=文件比较
dlgSgAbortBisectingConfirm.btn"Abort Bisect"=中止二分
dlgSgAbortBisectingConfirm.fur=您的工作区处于 “二分” 状态。您可以中止它以退出此状态。\n\n在开始二分之前，将检查分支或提交。
dlgSgAbortBisectingConfirm.hdl=是否要重置工作区？
dlgSgAbortBisectingConfirm.tle=中止
dlgSgAbortCherryPickingConfirm.btn"Abort Cherry-Pick"=中止摘取
dlgSgAbortCherryPickingConfirm.fur=您的工作区处于 “摘取” 状态。你可以中止它以摆脱这种状态，然后重新开始摘取。\n\n中止将清理任何本地修改 \(通过调用 “git reset --hard”\)！
dlgSgAbortCherryPickingConfirm.hdl=您想重置您的工作区吗？
dlgSgAbortCherryPickingConfirm.tle=中止
dlgSgAbortMergingConfirm.btn"Abort Merge"=中止合并
dlgSgAbortMergingConfirm.fur=您的工作区处于 “合并” 状态。您可以中止它以退出此状态，然后重新开始合并。\n\n中止将尝试重建合并前状态 \(通过调用 “git merge --abort”\)！
dlgSgAbortMergingConfirm.hdl=您想中止当前的合并吗？
dlgSgAbortMergingConfirm.tle=丢弃
dlgSgAbortRebasingConfirm.btn"Abort Rebase"=中止变基
dlgSgAbortRebasingConfirm.fur=您的工作区处于 “变基” 状态。你可以放弃变基; 如果您只想跳过当前的补丁，请使用 分支 \| 变基 \| 将 HEAD 变基至。\n\n中止将清除任何本地修改 \(通过调用 “git reset --hard”\)！
dlgSgAbortRebasingConfirm.hdl=您想中止变基吗？
dlgSgAbortRebasingConfirm.tle=丢弃
dlgSgAbortRevertingConfirm.btn"Abort Revert"=中止还原
dlgSgAbortRevertingConfirm.fur=您的工作区处于 “还原” 状态。您可以中止它以退出此状态，然后重新开始还原。\n\n中止将清除任何本地修改 \(通过调用 “git reset --hard”\)!
dlgSgAbortRevertingConfirm.hdl=你想重置你的工作区吗？
dlgSgAbortRevertingConfirm.tle=丢弃
dlgSgAbout.btn"Register"=注册
dlgSgAbout.edt"Add-on"=插件
dlgSgAbout.edt"Address"=地址
dlgSgAbout.edt"Build Date"=编译日期
dlgSgAbout.edt"Email"=电子邮箱
dlgSgAbout.edt"Free Updates Until"=免费更新有效期
dlgSgAbout.edt"Java Version"=Java 版本
dlgSgAbout.edt"Maximum Heap"=最大内存
dlgSgAbout.edt"Name"=用户名
dlgSgAbout.edt"Settings Path"=设置路径
dlgSgAbout.edt"Support Until"=技术支持有效期
dlgSgAbout.edt"User Count"=用户数量
dlgSgAbout.edt"Version"=版本
dlgSgAbout.tab"Credits"=基本信息
dlgSgAbout.tab"Information"=软件信息
dlgSgAbout.tab"Licensee"=授权信息
dlgSgAbout.tle=关于 SmartGit
dlgSgApplicationUpgradeError.fur=进程无法启动.
dlgSgApplicationUpgradeError.hdl=更新程序启动失败.
dlgSgApplicationUpgradeError.tle=更新
dlgSgAuthenticationRemoveAllCredentials.btn"Remove All"=移除所有
dlgSgAuthenticationRemoveAllCredentials.fur=您必须重新输入所有身份验证详细信息。
dlgSgAuthenticationRemoveAllCredentials.hdl=您确定要删除所有已知凭据吗？
dlgSgAuthenticationRemoveAllCredentials.tle=移除所有
dlgSgAuthenticationShowPassword.edt"Password"=密码
dlgSgAuthenticationShowPassword.tle%1=$1 的密码
dlgSgBisectResult.btn"Continue Bisect"=继续二分
dlgSgBisectResult.btn"Leave Bisect"=离开二分
dlgSgBisectResult.fur%1=$1
dlgSgBisectResult.hdl=二分决定了第一次错误的提交。
dlgSgBisectResult.tle=完成二分
dlgSgBisectStartConfirm.btn"Start Bisect with Bad HEAD"=从损坏的 HEAD 开始二分
dlgSgBisectStartConfirm.btn"Start Bisect"=开始二分
dlgSgBisectStartConfirm.fur=在 Git 开始二进制搜索之前，你需要将 1 个提交标记为正常，1 个提交为损坏。
dlgSgBisectStartConfirm.hdl=是否应该以错误的提交开始？
dlgSgBisectStartConfirm.tle=开始二分
dlgSgBitbucketGenerateToken.edt"Code"=代码
dlgSgBitbucketGenerateToken.edt"Link"=链接
dlgSgBitbucketGenerateToken.hdl=输入生成的代码
dlgSgBitbucketGenerateToken.inf=在 Bitbucket 进行身份验证并输入生成的令牌
dlgSgBitbucketGenerateToken.lbl"Your browser should have opened automatically, let you authenticate with your preferred account at Bitbucket and grant access to SmartGit. If this didn't happen, manually open following link:"=\
 您的浏览器应该已自动打开，请使用 Bitbucket 上的首选账户进行身份验证并授予对 SmartGit 的访问权限。如果没有发生这种情况，请手动打开以下链接：
dlgSgBitbucketGenerateToken.tle=请求访问令牌
dlgSgBranchAddCheckout.btn"Add Branch && Checkout"=创建分支并检出
dlgSgBranchAddCheckout.btn"Add Branch"=创建分支
dlgSgBranchAddCheckout.edt"Branch"=分支
dlgSgBranchAddCheckout.err"A remote branch with this name already exists. Use a different name."=\
 已存在具有此名称的远程分支。请使用不同的名称。
dlgSgBranchAddCheckout.err"Choose a different branch, the current branch can't be used."=\
 选择其他分支，当前分支不能使用。
dlgSgBranchAddCheckout.err"Enter the name of the local branch."=\
 输入本地分支的名称。
dlgSgBranchAddCheckout.err"The name must not end with a slash or dot."=\
 名称不得以斜杠或点结尾。
dlgSgBranchAddCheckout.err"This branch already exists at this commit."=\
 此分支在此提交时已存在。
dlgSgBranchAddCheckout.hdl"Add branch at commit $1"=在 $1 提交处创建分支
dlgSgBranchAddCheckout.hdl"Add branch at current HEAD commit"=\
 在当前 HEAD 提交处创建分支
dlgSgBranchAddCheckout.inf=输入要创建的本地分支的名称。
dlgSgBranchAddCheckout.tle=创建分支
dlgSgBranchAddCheckoutOverwriteExisting.btn"Overwrite"=覆盖
dlgSgBranchAddCheckoutOverwriteExisting.fur=单击 “取消” 以选择其他分支名称。
dlgSgBranchAddCheckoutOverwriteExisting.hdl%1=分支 “$1” 已经存在。你想覆盖吗？
dlgSgBranchAddCheckoutOverwriteExisting.tle=创建分支
dlgSgBranchDeleteCurrentNotPossible.fur=默认情况下，SmartGit 不允许删除当前分支。 要跳过此限制，请设置低级属性 “branch.delete.allowToDeleteCurrentBranch”。
dlgSgBranchDeleteCurrentNotPossible.hdl=您无法删除当前分支。
dlgSgBranchDeleteCurrentNotPossible.tle=删除
dlgSgBranchDeleteLocalConfirmMultiple.btn"Delete"=删除
dlgSgBranchDeleteLocalConfirmMultiple.chk"Delete from remote repository"=从远程仓库中删除
dlgSgBranchDeleteLocalConfirmMultiple.chk"Delete tracked branches"=删除跟踪的分支
dlgSgBranchDeleteLocalConfirmMultiple.fur=还原已删除的分支可能会变得很复杂。\n\n您只能从本地远程分支列表中删除分支，但这分支可能会在下一次获取中恢复。
dlgSgBranchDeleteLocalConfirmMultiple.hdl%1=您确定要删除 $1 本地分支吗？
dlgSgBranchDeleteLocalConfirmMultiple.tle=删除
dlgSgBranchDeleteLocalConfirmSingle.btn"Delete"=删除
dlgSgBranchDeleteLocalConfirmSingle.chk"Delete from remote repository '$1'"=从远程仓库 “$1” 中删除
dlgSgBranchDeleteLocalConfirmSingle.chk"Delete tracked branch '$1'"=删除跟踪分支 “$1”
dlgSgBranchDeleteLocalConfirmSingle.fur=您可能会丢失未经推送的变更，或还原分支可能会很复杂 \(es\)！
dlgSgBranchDeleteLocalConfirmSingle.hdl%1=您确定要删除本地分支 “$1” 吗？
dlgSgBranchDeleteLocalConfirmSingle.tle=删除
dlgSgBranchDeleteRemoteConfirmSingle.btn"Delete"=删除
dlgSgBranchDeleteRemoteConfirmSingle.chk"Delete from remote '$1'"=从远程 “$1” 删除
dlgSgBranchDeleteRemoteConfirmSingle.chk"Delete from remote repository '$1'"=从远程仓库中删除 '$1'
dlgSgBranchDeleteRemoteConfirmSingle.fur=您只能从本地远程分支列表中删除分支，但这分支可能会在下一次获取中恢复。
dlgSgBranchDeleteRemoteConfirmSingle.hdl"Do you want to delete the branch '$1'?"=\
 您要删除分支 “$1” 吗？
dlgSgBranchDeleteRemoteConfirmSingle.hdl"Do you want to delete the remote branch '$1'?"=\
 您要删除远程分支 “$1” 吗？
dlgSgBranchDeleteRemoteConfirmSingle.tle=删除
dlgSgBranchTrackingResetConfirm.btn"Stop Tracking"=停止跟踪
dlgSgBranchTrackingResetConfirm.fur=必要的配置将在 .git/config 文件中执行。
dlgSgBranchTrackingResetConfirm.hdl%2=分支 '$1' 是否应该停止跟踪 '$2'？
dlgSgBranchTrackingResetConfirm.tle=停止跟踪
dlgSgBranchTrackingSetConfirm.btn"Configure"=配置
dlgSgBranchTrackingSetConfirm.fur=必要的配置将在 .git/config 文件中执行。
dlgSgBranchTrackingSetConfirm.hdl%2=你想配置 '$1' 跟踪 '$2' 吗？
dlgSgBranchTrackingSetConfirm.tle=设置跟踪分支
dlgSgBugReportSettings.btn"Exit"=退出
dlgSgBugReportSettings.chk"Automatically send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后自动发送 “崩溃追踪”
dlgSgBugReportSettings.chk"Send 'crash footprints' after an internal error has occurred"=\
 在发生内部错误后发送 “崩溃追踪”
dlgSgBugReportSettings.err"Sending 'crash footprints' is required for preview builds, because their main purposes is to get as much as possible bugs reported and fixed before release."=\
 预览版本需要发送 “崩溃追踪”，因为它们的主要目的是尽可能多地获取在发布之前报告和修复的错误。
dlgSgBugReportSettings.hdl=崩溃报告
dlgSgBugReportSettings.inf=请通过自动发送不包含任何敏感信息的 “崩溃追踪” 来帮助提高 SmartGit 的质量。您可以稍后在偏好设置中更改此选项。
dlgSgBugReportSettings.lbl"A 'crash footprint' contains details about your machine \(e.g. version of operating system\), SmartGit's version/build number, the JVM state and where the internal error occurred.\n\nIt contains NO POTENTIALLY SENSITIVE INFORMATION like user names, email addresses, file contents, file paths or server names."=\
 “崩溃追踪” 包含有关您的计算机的详细信息 \(例如，操作系统的版本\)，SmartGit 的版本/内部版本号，JVM 状态以及发生内部错误的位置。\n\n它不包含任何潜在的敏感信息，如用户名，电子邮件地址，文件内容，文件路径或服务器名称。
dlgSgBugReportSettings.tle=SmartGit
dlgSgCheckout.btn"Branches"=分支
dlgSgCheckout.btn"Check Out"=检出
dlgSgCheckout.hdl=检出提交
dlgSgCheckout.inf=选择要检出的提交. 允许将工作树切换到任何提交.
dlgSgCheckout.tle=检出
dlgSgCheckoutFastForwardMerge.btn"Fast-Forward-Merge"=快进合并
dlgSgCheckoutFastForwardMerge.btn"Just Checkout"=仅检出
dlgSgCheckoutFastForwardMerge.fur=快进合并会自动将分支向前移动到跟踪的远程分支。
dlgSgCheckoutFastForwardMerge.hdl%1=检出 “$1” 后，您想要快进合并远程变更吗？
dlgSgCheckoutFastForwardMerge.tle=检出
dlgSgCheckoutLocalBranchConfirm.btn"Checkout"=检出
dlgSgCheckoutLocalBranchConfirm.chk=不再显示
dlgSgCheckoutLocalBranchConfirm.fur%1=这将使 “$1” 成为您当前的分支。
dlgSgCheckoutLocalBranchConfirm.hdl%1=你想检出 “$1” 分支吗?
dlgSgCheckoutLocalBranchConfirm.tle=检出
dlgSgCheckoutTarget.btn"Checkout"=检出
dlgSgCheckoutTarget.chk"Track remote branch '$1'"=跟踪远程分支 “$1”
dlgSgCheckoutTarget.chk"Track remote branch"=跟踪远程分支
dlgSgCheckoutTarget.hdl"Check out commit"=检出提交
dlgSgCheckoutTarget.hdl"Check out remote branch"=检出远程分支
dlgSgCheckoutTarget.hdl"Checkout commit"=检出提交
dlgSgCheckoutTarget.hdl"Checkout remote branch"=检出远程分支
dlgSgCheckoutTarget.inf=当检出提交而不是本地分支的时候需要小心：在该提交之后的提交很容易丢失。
dlgSgCheckoutTarget.rbt"Checkout and fast-forward local branch 'dev'"=\
 检出并快进本地分支 'dev'
dlgSgCheckoutTarget.rbt"Checkout local branch '$1'"=检出本地分支 '$1'
dlgSgCheckoutTarget.rbt"Create local branch:"=创建本地分支：
dlgSgCheckoutTarget.rbt"Don't create local branch \(just work read-only\)"=\
 不创建本地分支 \(只是以只读方式工作\)
dlgSgCheckoutTarget.tle=检出
dlgSgCheckoutTarget.wrn"Local branch '$1' is behind checkout target '$2'."=\
 本地分支 “$1” 落后于检出目标 “$2”。
dlgSgCheckoutTarget.wrn"Local branch '$1' is diverged from checkout target '$2'."=\
 本地分支 “$1” 与检出目标 “$2” 不同。
dlgSgCheckoutTarget.wrn"Local branch is ahead of remote branch. The checkout will end up at a more recent commit."=\
 本地分支位于远程分支之前。检出将在最近的提交时结束。
dlgSgCheckoutTargetAlreadyExistsOverwrite.btn"Overwrite"=覆盖
dlgSgCheckoutTargetAlreadyExistsOverwrite.fur=单击 “取消” 以选择其他分支名称。
dlgSgCheckoutTargetAlreadyExistsOverwrite.hdl%1=分支 “$1” 已经存在。您想覆盖吗？
dlgSgCheckoutTargetAlreadyExistsOverwrite.tle=检出
dlgSgCherryPickConfigurationFile.btn"Cherry-Pick"=摘取
dlgSgCherryPickConfigurationFile.fur=只有这些文件的变更才会被摘取 \(不提交\)。
dlgSgCherryPickConfigurationFile.hdl"Do you want to cherry-pick changes of $1 files?"=\
 你想要摘取 $1 文件的变更？
dlgSgCherryPickConfigurationFile.hdl"Do you want to cherry-pick changes of '$1'?"=\
 你想要摘取 $1 文件的变更？
dlgSgCherryPickConfigurationFile.tle=摘取
dlgSgCherryPickConfirmation.btn"Cherry-Pick && Commit"=摘取并提交
dlgSgCherryPickConfirmation.btn"Cherry-Pick"=摘取
dlgSgCherryPickConfirmation.chk=将源 SHA 附加到提交消息
dlgSgCherryPickConfirmation.fur=选中的提交将会被摘取到工作区中
dlgSgCherryPickConfirmation.hdl=你想要摘取提交吗？
dlgSgCherryPickConfirmation.tle=摘取
dlgSgCherryPickFailedBecauseOfConflicts.chk=不再显示
dlgSgCherryPickFailedBecauseOfConflicts.fur=您可能需要在继续之前解决冲突。
dlgSgCherryPickFailedBecauseOfConflicts.hdl=由于冲突，摘取失败。
dlgSgCherryPickFailedBecauseOfConflicts.tle=摘取
dlgSgCherryPickUnpushedCommits.btn"Cherry-Pick"=摘取
dlgSgCherryPickUnpushedCommits.fur=存在选定的提交尚未推送，因此摘取只是本地的，不会转换为 SVN \(合并信息\)。
dlgSgCherryPickUnpushedCommits.hdl=你想要摘取未推送的提交吗？
dlgSgCherryPickUnpushedCommits.tle=摘取
dlgSgClean.btn"Clean Working Tree"=清理工作区
dlgSgClean.chk"Remove only ignored files"=仅删除忽略的文件
dlgSgClean.chk"Remove untracked directories"=删除未跟踪的目录
dlgSgClean.hdl=删除未跟踪的文件
dlgSgClean.inf=选择应删除哪些未跟踪的文件。
dlgSgClean.tle=清理工作区
dlgSgClone.chk"Create upstream remote"=同时创建上游仓库的远程连接
dlgSgClone.chk"Fetch all Heads and Tags"=获取所有 HEAD 和标签
dlgSgClone.chk"Fetch all commits"=获取所有提交
dlgSgClone.chk"Include Submodules"=包括子模块
dlgSgClone.chk"Just initialize clone \(expert mode, not officially supported!\)"=\
 刚刚初始化克隆 \(专家模式，非官方支持！\)
dlgSgClone.chk"Map SVN trunk, tags and branches to Git"=\
 将 SVN 主干，标签和分支映射到 Git
dlgSgClone.chk"Skip large files \(\"partial clone\"\)"=跳过大文件 \(“部分克隆”\)
dlgSgClone.edt"Check Out Branch"=检出分支
dlgSgClone.edt"Fetch Only"=仅获取
dlgSgClone.edt"Fetch only the latest"=获取最新内容
dlgSgClone.edt"Local Directory"=本地目录
dlgSgClone.edt"Omit files larger than"=省略大于
dlgSgClone.edt"Path"=路径
dlgSgClone.edt"Repository URL"=仓库地址
dlgSgClone.err"Please select an empty, local directory for the new repository."=\
 请为新仓库选择空的本地目录。
dlgSgClone.err"Please specify the URL of the remote repository to be cloned."=\
 请指定要克隆的远程仓库的地址。
dlgSgClone.err"Please specify the root directory of a local repository."=\
 请指定本地仓库的根目录。
dlgSgClone.inf"Customize how and what to clone."=\
 自定义克隆的方式和内容。
dlgSgClone.inf"Specify the Git or SVN repository to clone."=\
 指定要克隆的 Git 或 SVN 仓库。
dlgSgClone.inf"Specify the Git, Mercurial or SVN repository to clone."=\
 指定要克隆的 Git，Mercurial 或 SVN 仓库。
dlgSgClone.inf"Specify the local directory for the new repository."=\
 指定新仓库的本地目录。
dlgSgClone.inf"Specify the repository to clone."=指定需要克隆的仓库.
dlgSgClone.lbl"Note: Pull or Fetch will not bring other refs, you will need to use Fetch More."=\
 注意: 拉取和推送不会加载其他引用, 你可能需要使用获取更多来加载其他引用.
dlgSgClone.lbl"e.g. https://user@server:port/path/to/repository"=e.g. https://user@server:port/path/to/repository
dlgSgClone.mni"Add Hosting Provider"=添加主机提供商
dlgSgClone.rbt"Clone all revisions \(recommended\)"=克隆所有修订版 \(推荐\)
dlgSgClone.rbt"Clone from revision:"=从修订版中克隆:
dlgSgClone.rbt"Local Git or Mercurial repository"=本地 Git 或 Mercurial 仓库
dlgSgClone.rbt"Local Git repository"=本地 Git 仓库
dlgSgClone.rbt"Local repository"=本地仓库
dlgSgClone.rbt"Remote Git or SVN repository"=远程 Git 或 SVN 仓库
dlgSgClone.rbt"Remote Git, Mercurial or SVN repository"=\
 远程 Git，Mercurial 或 SVN 仓库
dlgSgClone.rbt"Remote repository"=远程仓库
dlgSgClone.tle=克隆
dlgSgCloneRepositoryType.btn"Git"=Git
dlgSgCloneRepositoryType.btn"Mercurial"=Mercurial
dlgSgCloneRepositoryType.btn"SVN"=SVN
dlgSgCloneRepositoryType.fur=指定的 URL 协议不明确，可能引用不同类型的仓库。
dlgSgCloneRepositoryType.hdl=选择要克隆的仓库类型。
dlgSgCloneRepositoryType.tle=克隆
dlgSgCloneSvnDetachedHeadSuccess.fur=SmartGit 现在继续在后台获取所有其他修订版。 您现在可以安全地开始使用仓库; 只有与记录相关的操作才会受到此中间状态的影响。\n\n一旦 SmartGit 完成了克隆的后台部分，它会在通知区域 \(状态栏\) 中通知您，您可以在那里完成克隆。
dlgSgCloneSvnDetachedHeadSuccess.hdl=已成功克隆 HEAD 修订版。
dlgSgCloneSvnDetachedHeadSuccess.tle=克隆
dlgSgCommit.btn"Commit && Push"=提交并推送
dlgSgCommit.btn"Commit"=提交
dlgSgCommit.btn"Select from Log"=从日志中选择
dlgSgCommit.btn"Select"=选择
dlgSgCommit.chk"Add 'Signed-off-by' signature"=添加 “签名”
dlgSgCommit.chk"Amend last commit instead of creating new one"=\
 修改最后一次提交而不是创建新的提交
dlgSgCommit.chk"Amend last commit"=修订上次的提交
dlgSgCommit.chk"Bypass commit hook"=绕过提交钩子
dlgSgCommit.chk"More Options"=更多选项
dlgSgCommit.col"Directory"=目录
dlgSgCommit.col"Name"=名称
dlgSgCommit.edt"Commit Message"=提交信息
dlgSgCommit.edt"Create"=创建
dlgSgCommit.err"Enter a commit message describing \(the reason for\) the commit."=\
 输入提交消息
dlgSgCommit.hdl=提交本地或暂存的变更
dlgSgCommit.inf=选择要提交的文件并提供提交消息。
dlgSgCommit.mni"Deselect All"=取消全选
dlgSgCommit.mni"JIRA"=JIRA
dlgSgCommit.mni"Log"=日志
dlgSgCommit.mni"Select All"=全选
dlgSgCommit.mni"Select from Log"=从日志中选择
dlgSgCommit.mni"Show Changes"=显示修改
dlgSgCommit.mni"Toggle"=切换
dlgSgCommit.rbt"Local Changes"=本地修改
dlgSgCommit.rbt"Merge commit \(multiple parents\)"=合并提交 \(多个父系\)
dlgSgCommit.rbt"Simple commit \(one parent, \"squash\"\)"=简单提交 \(1个父系, “压缩”\)
dlgSgCommit.rbt"Staged Changes"=暂存的修改
dlgSgCommit.tle=提交
dlgSgCommit.wrn"All staged changes have been selected for commit, as this is necessary in 'Reverting' state."=\
 已选择所有暂存的变更进行提交，因为这在 “还原” 状态中是必需的。
dlgSgCommit.wrn"When modifying or splitting a commit, you first need to commit all local changes before being able to continue the rebase."=\
 当修改或拆分提交时，需要先提交所有本地变更，然后才能继续使用变基。
dlgSgCommitAmendAlreadyPushedCommit.btn"Amend"=修改
dlgSgCommitAmendAlreadyPushedCommit.fur=如果修改已推送的提交，你需要稍后强制推送它。这可能会覆盖其他用户的变更。
dlgSgCommitAmendAlreadyPushedCommit.hdl=你确定要修改已推送的提交吗？
dlgSgCommitAmendAlreadyPushedCommit.tle=提交
dlgSgCommitCantAmend.fur=无法修订已推送的提交. 如果你了解风险并想要启用, 请在设置中选择 '允许修改推送的提交'.
dlgSgCommitCantAmend.hdl=无法修订提交.
dlgSgCommitCantAmend.tle=提交
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.btn"Continue Rebase"=继续变基
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.btn"Create Commit"=创建提交
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.fur=仓库处于 “变基” 状态。 您通常只想继续使用变基，而不是在重新提交的提交中创建额外的提交。
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.hdl=您想继续使用变基还是创建额外的提交？
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.tle=变基
dlgSgCommitDirectlyTo.btn"Commit Anyway"=Commit Anyway
dlgSgCommitDirectlyTo.fur=你配置了 Git-Flow, 不应该直接提交到 Git-Flow master 分支, 只能通过 Git-Flow 命令和合并操作.\n\n如有疑问, 请联系仓库管理员.
dlgSgCommitDirectlyTo.hdl=确定要直接提交到 'master'?
dlgSgCommitDirectlyTo.tle=提交
dlgSgCommitIndexAllWorkingTreeChanges.btn"Commit All Working Tree Changes"=提交所有工作区变更
dlgSgCommitIndexAllWorkingTreeChanges.chk=不再显示
dlgSgCommitIndexAllWorkingTreeChanges.fur=至今没有文件被暂存。 要暂存个别变更，请单击 “取消”。 否则，所有工作区变更将被暂存和提交。
dlgSgCommitIndexAllWorkingTreeChanges.hdl=您想要提交所有工作区的变更吗？
dlgSgCommitIndexAllWorkingTreeChanges.tle=提交
dlgSgCommitIndexNoFilesFound.fur=找不到暂存文件或本地变更的文件。
dlgSgCommitIndexNoFilesFound.hdl=没有需要提交的。
dlgSgCommitIndexNoFilesFound.tle=提交
dlgSgCommitNoFilesFoundNotAllowEmpty.fur=找不到暂存或本地变更的文件。
dlgSgCommitNoFilesFoundNotAllowEmpty.hdl=没有东西需要提交
dlgSgCommitNoFilesFoundNotAllowEmpty.tle=提交
dlgSgCommitSelectMessageFromLog.btn"Branches"=分支
dlgSgCommitSelectMessageFromLog.btn"Select"=选择
dlgSgCommitSelectMessageFromLog.chk"Add 'fixup!' prefix for easier automatic squashing using Interactive Rebase"=\
 创建 “修复！” 前缀,以便使用交互式变基轻松自动压缩
dlgSgCommitSelectMessageFromLog.hdl=选择一个提交
dlgSgCommitSelectMessageFromLog.inf=选择应使用其消息的提交。
dlgSgCommitSelectMessageFromLog.mni"Author"=作者
dlgSgCommitSelectMessageFromLog.mni"Branches and Tags"=分支和标签
dlgSgCommitSelectMessageFromLog.mni"Committer"=修订者
dlgSgCommitSelectMessageFromLog.mni"Copy ID"=复制 ID
dlgSgCommitSelectMessageFromLog.mni"Copy Message"=复制消息
dlgSgCommitSelectMessageFromLog.mni"File Content \(very expensive\)"=文件内容 \(非常昂贵代价\)
dlgSgCommitSelectMessageFromLog.mni"File \(expensive\)"=文件 \(昂贵代价\)
dlgSgCommitSelectMessageFromLog.mni"Forget Pattern"=忘记模式
dlgSgCommitSelectMessageFromLog.mni"ID"=ID
dlgSgCommitSelectMessageFromLog.mni"Message"=消息
dlgSgCommitSelectMessageFromLog.mni"Refresh"=刷新
dlgSgCommitSelectMessageFromLog.mni"Regular Expressions"=常用表达式
dlgSgCommitSelectMessageFromLog.mni"Remember Pattern"=记住模式
dlgSgCommitSelectMessageFromLog.tle=选择提交消息
dlgSgCommitSingleOrAllWorkingTreeChanges.btn"Commit All Changes"=提交所有变更
dlgSgCommitSingleOrAllWorkingTreeChanges.btn"Commit File"=提交文件
dlgSgCommitSingleOrAllWorkingTreeChanges.fur=您可以提交单个选定文件，也可以提交所有已变更的文件。
dlgSgCommitSingleOrAllWorkingTreeChanges.hdl=您想提交什么？
dlgSgCommitSingleOrAllWorkingTreeChanges.tle=提交
dlgSgCommitToDetachedHead.btn"Commit Anyway"=总是提交
dlgSgCommitToDetachedHead.fur=仓库 HEAD 当前不指向分支，而是直接引用提交 \(SHA\)。提交时，新创建的提交只能通过其 SHA 访问，因此可能很容易丢失。\n\n现在，您应该首先为当前 HEAD 创建新分支，然后再提交。
dlgSgCommitToDetachedHead.hdl=你想提交独立的 HEAD 吗？
dlgSgCommitToDetachedHead.tle=提交
dlgSgCompareTwoFiles.btn"Compare with Each Other"=相互比较
dlgSgCompareTwoFiles.btn"Compare with Repository"=与仓库比较
dlgSgCompareTwoFiles.fur=这些文件可以与它们的仓库内容或相互比较。
dlgSgCompareTwoFiles.hdl=所选的两个文件是否应相互比较？
dlgSgCompareTwoFiles.tle=比较
dlgSgConflictResolverExternalStarted.btn"Mark Resolved"=标记已解决
dlgSgConflictResolverExternalStarted.fur=外部冲突解决工具已启动. 解决完冲突, 就可以将文件标记为已解决了.
dlgSgConflictResolverExternalStarted.hdl=是否标记为已解决?
dlgSgConflictResolverExternalStarted.tle=外部冲突解决工具
dlgSgConflictSolverMarkResolved.btn"Leave Conflicted"=离开冲突
dlgSgConflictSolverMarkResolved.btn"Mark Resolved"=标记已解决
dlgSgConflictSolverMarkResolved.fur=要完成冲突解决，需要将文件标记为已解决 \(Git 阶段\)。在标记为已解决之前，文件将保持冲突状态，您可以尝试其他冲突解决方案。
dlgSgConflictSolverMarkResolved.hdl=您是否要将该文件标记为已解决？
dlgSgConflictSolverMarkResolved.tle=标记已解决
dlgSgConflictSolverStageForCommit.btn"Don't Stage"=放弃暂存
dlgSgConflictSolverStageForCommit.btn"Stage"=暂存
dlgSgConflictSolverStageForCommit.fur=暂存是解决文件冲突状态所必需的。
dlgSgConflictSolverStageForCommit.hdl=您想现在提交暂存文件吗？
dlgSgConflictSolverStageForCommit.tle=提交暂存
dlgSgCustomizeProjectUi.btn"Add"=创建
dlgSgCustomizeProjectUi.btn"Assign"=应用
dlgSgCustomizeProjectUi.btn"Clear"=清除
dlgSgCustomizeProjectUi.btn"Remove"=移除
dlgSgCustomizeProjectUi.btn"Reset"=重置
dlgSgCustomizeProjectUi.chk"Show text below icon"=在图标下方显示文字
dlgSgCustomizeProjectUi.col"Accelerator"=快捷键
dlgSgCustomizeProjectUi.col"Available"=可选
dlgSgCustomizeProjectUi.col"Default"=默认
dlgSgCustomizeProjectUi.col"Menu Item"=菜单项
dlgSgCustomizeProjectUi.col"Selected"=已选择
dlgSgCustomizeProjectUi.edt"Accelerator"=快捷键
dlgSgCustomizeProjectUi.mni"Regular Expressions"=常用表达式
dlgSgCustomizeProjectUi.tab"Accelerators"=快捷键
dlgSgCustomizeProjectUi.tab"Toolbar"=工具栏
dlgSgCustomizeProjectUi.tle=自定义
dlgSgDeleteFileTrash.hdl%1=确定要删除 “$1” 吗？
dlgSgDeleteFilesTrash.hdl%1=您确定要删除所选的 $1 文件吗？
dlgSgDiscard.btn"Discard to Stash"=丢弃到暂存
dlgSgDiscard.btn"Discard"=丢弃
dlgSgDiscard.col"Directory"=目录
dlgSgDiscard.col"Name"=名称
dlgSgDiscard.edt"Revert to"=还原
dlgSgDiscard.hdl=丢弃本地或暂存的变更
dlgSgDiscard.inf=选择应丢弃变更的文件以及是否将其设置回索引或 HEAD 状态。
dlgSgDiscard.mni"Copy Selection in Column"=按列复制
dlgSgDiscard.mni"Deselect All"=取消全选
dlgSgDiscard.mni"Directory"=目录
dlgSgDiscard.mni"Name"=名称
dlgSgDiscard.mni"Select All"=全选
dlgSgDiscard.mni"Show Changes"=显示变更
dlgSgDiscard.mni"Toggle"=切换
dlgSgDiscard.rbt"HEAD"=HEAD
dlgSgDiscard.rbt"Index"=索引
dlgSgDiscard.tle=丢弃
dlgSgDiscardNoFilesFound.fur=找不到暂存文件或本地变更的文件。
dlgSgDiscardNoFilesFound.hdl=没有什么可以丢弃的。
dlgSgDiscardNoFilesFound.tle=丢弃
dlgSgDiscardRevertToHead.hdl%1=您确定要将 $1 文件重置为 HEAD 状态吗？
dlgSgDiscardRevertToIndex.hdl%1=您确定要将 $1 文件重置为其索引状态吗？
dlgSgDiscardRevertTo(Head|Index).btn"Discard"=丢弃
dlgSgDiscardRevertTo(Head|Index).fur=内容可能很难还原！
dlgSgDiscardRevertTo(Head|Index).tle=丢弃
dlgSgErrorUtilsClientException.fur"Commit '$1' was not found in repository."=\
 未在仓库内找到提交 '$1'.
dlgSgErrorUtilsClientException.fur"Could not determine URL for submodule $1. Is it correctly initialized?"=\
 无法确定子模块 $1 的URL. 确定已经正常初始化?
dlgSgErrorUtilsClientException.fur"GIT_DIR for repository at '$1' does not exist."=\
 位于 '$1' 的仓库的 GIT_DIR 不存在。
dlgSgErrorUtilsClientException.fur"Repository '$1' is not valid."=仓库 “$1” 无效。
dlgSgErrorUtilsClientException.fur"svn: $1"=svn: $1
dlgSgErrorUtilsClientException.hdl=执行命令失败。
dlgSgErrorUtilsClientException.tle=命令失败
dlgSgExitConfirmation.btn"Exit Now"=立即退出
dlgSgExitConfirmation.chk=不再显示
dlgSgExitConfirmation.fur=关闭所有窗口后退出 SmartGit。
dlgSgExitConfirmation.hdl=你想立即退出 SmartGit 吗？
dlgSgExitConfirmation.tle=退出
dlgSgFileCompareNoChanges.btn"Open"=打开
dlgSgFileCompareNoChanges.chk=不再显示
dlgSgFileCompareNoChanges.fur=两个文件内容按字节顺序相等。\n要查看文件内容，请单击 “打开” 。
dlgSgFileCompareNoChanges.hdl=打开文件将显示比较尽管没有变化？
dlgSgFileCompareNoChanges.tle=文件比较
dlgSgFindObject.edt"Repository Path, Commit ID or Ref"=\
 仓库路径、提交 ID 或引用
dlgSgFindObject.tle=查找对象
dlgSgFlowBranchDivergedHandlerFastForward.btn"Fast-Forward"=快进
dlgSgFlowBranchDivergedHandlerFastForward.fur%3=本地分支 “$1” 位于其跟踪分支 “$2” 的后面。您可以现在快进，也可以稍后手动前进，例如签出分支 $3 。
dlgSgFlowBranchDivergedHandlerFastForward.hdl%2=分支 “$1” 是否应快速转发到 “$2”？
dlgSgFlowBranchDivergedHandlerFastForward.tle=开始 feature
dlgSgFlowBranchDivergedHandlerReplaceRemote.btn"Replace"=替换
dlgSgFlowBranchDivergedHandlerReplaceRemote.fur%2=本地分支 “$1” 似乎包含远程分支 “$2” 的更新但已重写的提交。\n\n如果您不确定本地分支是否实际比远程分支更新，则最好取消此操作并更详细地审查本地和远程变更。
dlgSgFlowBranchDivergedHandlerReplaceRemote.hdl%2=分支 “$1” 是否应替换远程分支 “$2”？
dlgSgFlowBranchDivergedHandlerReplaceRemote.tle=完成 feature
dlgSgFlowBranchDivergedHandlerResetToRemote.btn"Reset"=重置
dlgSgFlowBranchDivergedHandlerResetToRemote.fur%2=远程分支 '$1' 似乎包含更近期但被重写的本地分支 '$2' 的提交。\r\n如果您不确定远程分支是否实际上比本地分支更新，您应该取消此操作并进行审查本地和远程变更更详细。
dlgSgFlowBranchDivergedHandlerResetToRemote.hdl%2=分支 '$1' 是否应重置为远程分支 '$2' ？
dlgSgFlowBranchDivergedHandlerResetToRemote.tle=完成 Feature
dlgSgFlowConfigure.btn"Reset to Defaults"=重置为默认
dlgSgFlowConfigure.edt"Develop Branch"=Develop 分支
dlgSgFlowConfigure.edt"Feature Branches"=Feature 分支
dlgSgFlowConfigure.edt"Git-Flow Type"=Git 工作流类型
dlgSgFlowConfigure.edt"Hot-Fix Branches"=Hot-Fix 分支
dlgSgFlowConfigure.edt"Main Development Branch"=主开发分支
dlgSgFlowConfigure.edt"Master Branch"=Master 分支
dlgSgFlowConfigure.edt"Prefix for Feature Branches"=Feature 分支的前缀
dlgSgFlowConfigure.edt"Release Branches"=Release 分支
dlgSgFlowConfigure.edt"Remote"=远程
dlgSgFlowConfigure.edt"Support Branches"=Support 分支
dlgSgFlowConfigure.edt"Version Tags"=版本标签
dlgSgFlowConfigure.hdl=配置分支命名方案
dlgSgFlowConfigure.inf=配置应如何命名 feature、release 和 hotfix 分支。
dlgSgFlowConfigure.rbt"Full \(feature, release, hotfix, support branches\)"=\
 所有 \(feature, release, hotfix, support 分支\)
dlgSgFlowConfigure.rbt"Light \(just feature branches\)"=轻量 \(只有 feature 分支\)
dlgSgFlowConfigure.tle=配置 Git 工作流
dlgSgFlowConfigureChangeOrSwitchOff.btn"Change Configuration"=更改配置
dlgSgFlowConfigureChangeOrSwitchOff.btn"Switch-Off Git-Flow"=关闭 Git 工作流
dlgSgFlowConfigureChangeOrSwitchOff.fur=已经为此仓库配置了 Git 工作流。您可以更改 Git 工作流配置或关闭 Git 工作流功能。在这两种情况下，文件 ~/.git/config 都将被相应地修改。
dlgSgFlowConfigureChangeOrSwitchOff.hdl=您想更改或关闭 Git 工作流配置吗？
dlgSgFlowConfigureChangeOrSwitchOff.tle=配置 Git 工作流
dlgSgFlowFeatureFinish.btn"Finish"=完成
dlgSgFlowFeatureFinish.btn"Select from Log"=从日志中选择
dlgSgFlowFeatureFinish.btn"Select"=选择
dlgSgFlowFeatureFinish.chk"Delete feature branch"=删除 feature 分支
dlgSgFlowFeatureFinish.chk"Fetch latest commits and remove remote feature branch"=\
 获取最新提交并删除远程 feature 分支
dlgSgFlowFeatureFinish.edt"Commit Message"=提交消息
dlgSgFlowFeatureFinish.hdl=完成当前 feature
dlgSgFlowFeatureFinish.inf"Choose how to finish the current feature. This operation will integrate the feature into the '$1' branch."=\
 选择如何完成当前 feature。此操作将该 feature 集成到 $1 分支中。
dlgSgFlowFeatureFinish.inf"Choose how to finish the feature branch '$1'. This operation will integrate the feature into the '$2' branch."=\
 选择如何完成 feature 分支 “$1”。此操作将 feature 集成到 “$2” 分支中。
dlgSgFlowFeatureFinish.mni"JIRA"=JIRA
dlgSgFlowFeatureFinish.mni"Log"=日志
dlgSgFlowFeatureFinish.rbt"Create merge commit"=创建合并提交
dlgSgFlowFeatureFinish.rbt"Create simple commit \(squash\)"=创建简单提交 \(压缩\)
dlgSgFlowFeatureFinish.rbt"Rebase onto '$1'"=变基至 “$1”
dlgSgFlowFeatureFinish.tle=完成 Feature
dlgSgFlowFeatureStart.btn"Start"=开始
dlgSgFlowFeatureStart.edt"Base"=根基
dlgSgFlowFeatureStart.edt"Feature Name"=Feature 名称
dlgSgFlowFeatureStart.err"A feature with this name already exists. Choose a different name."=\
 已存在相同名称的 feature。选择其他名称。
dlgSgFlowFeatureStart.err"Invalid feature name: The name must not end with a slash or dot."=\
 无效的 feature 名称：名称不能以斜线或点结尾。
dlgSgFlowFeatureStart.hdl=开始新 feature
dlgSgFlowFeatureStart.inf%1=输入新 feature 分支的名称。此操作将从 $1 分支派生出新的分支。
dlgSgFlowFeatureStart.lbl"Resulting Branch: $1"=结果分支：$1
dlgSgFlowFeatureStart.tle=开始 Feature
dlgSgFlowHotfixFinish.btn"Finish"=完成
dlgSgFlowHotfixFinish.btn"Select from Log"=从日志中选择
dlgSgFlowHotfixFinish.chk"Create version tag"=创建版本标签
dlgSgFlowHotfixFinish.chk"Create version tag:"=创建版本标签：
dlgSgFlowHotfixFinish.chk"Delete hotfix branch"=删除 hotfix 分支
dlgSgFlowHotfixFinish.chk"Fetch latest '$1' commits"=获取最新的 “$1” 提交
dlgSgFlowHotfixFinish.chk"Merge to develop"=合并到开发
dlgSgFlowHotfixFinish.chk"Push results and remove remote hotfix branch"=\
 推送结果并删除远程 hotfix 分支
dlgSgFlowHotfixFinish.edt"Commit Message"=提交消息
dlgSgFlowHotfixFinish.edt"Commit/Tag Message"=提交/标签信息
dlgSgFlowHotfixFinish.hdl=完成 hotfix
dlgSgFlowHotfixFinish.inf"Choose how to finish the current hotfix. This operation will merge the hotfix into the '$1' and '$2' branches."=\
 选择如何完成当前的修补程序。 此操作将修补程序合并到 “$1” 和 “$2” 分支中。
dlgSgFlowHotfixFinish.inf"Choose how to finish the hotfix branch '$1'. This operation will merge the hotfix into the '$2' and '$3' branches."=\
 选择如何完成 hotfix 分支 “$1”。此操作将 hotfix 合并到 “$2” 和 “$3” 分支中。
dlgSgFlowHotfixFinish.inf"Choose how to finish the hotfix branch '$1'."=\
 选择如何完成 hotfix 分支 “$1”。
dlgSgFlowHotfixFinish.tle=完成 Hotfix
dlgSgFlowHotfixStart.btn"Start"=开始
dlgSgFlowHotfixStart.chk"Fetch from '$1' branch"=从 '$1' 分支获取
dlgSgFlowHotfixStart.chk"Fetch from base branch"=从根基分支获取
dlgSgFlowHotfixStart.edt"Base"=根基
dlgSgFlowHotfixStart.edt"Hotfix Name"=修补程序名称
dlgSgFlowHotfixStart.hdl=启动新的修补程序
dlgSgFlowHotfixStart.inf%1=输入新修补程序分支的名称。 此操作将从 '$1' 分支中分叉出新分支。
dlgSgFlowHotfixStart.lbl"Resulting Branch: $1"=结果分支：$1
dlgSgFlowHotfixStart.tle=启动修补程序
dlgSgFlowIntegrateDevelop.btn"Integrate"=整合
dlgSgFlowIntegrateDevelop.chk"Fetch latest '$1' commits from remote repository"=\
 从远程仓库获取最新的 “$1” 提交
dlgSgFlowIntegrateDevelop.hdl%1=整合来自 “$1” 的提交
dlgSgFlowIntegrateDevelop.inf"Merge or rebase commits from the base branch to the current feature."=\
 把基础分支合并或变基提交到当前 feature 分支。
dlgSgFlowIntegrateDevelop.inf"Merge or rebase commits from the main development line to the current feature."=\
 把主开发线合并或变基提交到当前 feature 分支。
dlgSgFlowIntegrateDevelop.inf"Merge or rebase commits from the main development line to the feature branch '$1'."=\
 把主开发线合并或变基提交到 “$1” feature 分支。
dlgSgFlowIntegrateDevelop.rbt"Merge from '$1'"=合并 “$1”
dlgSgFlowIntegrateDevelop.rbt"Rebase current feature onto '$1'"=将当前 feature 变基至 “$1”
dlgSgFlowIntegrateDevelop.tle=整合开发
dlgSgFlowReleaseFinish.btn"Finish"=完成
dlgSgFlowReleaseFinish.btn"Select from Log"=从日志中选择
dlgSgFlowReleaseFinish.chk"Create version tag"=创建版本标签
dlgSgFlowReleaseFinish.chk"Create version tag:"=创建版本标签：
dlgSgFlowReleaseFinish.chk"Delete release branch"=删除 release 分支
dlgSgFlowReleaseFinish.chk"Fetch latest '$1' and '$2' commits"=\
 获取最新的 “$1” 和 “$2” 提交
dlgSgFlowReleaseFinish.chk"Push results and remove remote release branch"=\
 推送结果并删除远程 release 分支
dlgSgFlowReleaseFinish.edt"Commit Message"=提交消息
dlgSgFlowReleaseFinish.hdl=完成 release
dlgSgFlowReleaseFinish.inf"Choose how to finish the release branch '$1'. This operation will merge the current release into the '$2' and '$3' branches."=\
 选择如何完成 release 分支 “$1”。此操作将当前版本合并到 “$2” 和 “$3” 分支中。
dlgSgFlowReleaseFinish.inf"Choose how to finish the release branch '$1'."=\
 选择如何完成 release 分支 “$1”。
dlgSgFlowReleaseFinish.tle=完成 release
dlgSgFlowReleaseStart.btn"Start"=开始
dlgSgFlowReleaseStart.chk"Fetch from base branch"=从根基分支获取
dlgSgFlowReleaseStart.edt"Base"=根基
dlgSgFlowReleaseStart.edt"Release Name"=发布分支名称
dlgSgFlowReleaseStart.hdl=开始新版本
dlgSgFlowReleaseStart.inf%1=输入新发布分支的名称。 此操作将从 '$1' 分支中分叉一个新分支。
dlgSgFlowReleaseStart.lbl"Resulting Branch: $1"=结果分支：$1
dlgSgFlowReleaseStart.tle=开始发布
dlgSgFlowSupportStart.btn"Start"=开始
dlgSgFlowSupportStart.chk"Fetch from '$1' branch"=从 '$1' 分支获取
dlgSgFlowSupportStart.edt"Support Name"=支持名称
dlgSgFlowSupportStart.hdl=Start a new support
dlgSgFlowSupportStart.inf%1=Enter the name of the new support branch. This operation will fork a new branch from the '$1' branch.
dlgSgFlowSupportStart.lbl"Resulting Branch: $1"=正在生成分支: $1
dlgSgFlowSupportStart.tle=开始支持服务
dlgSgGarbageCollector.btn"Run Garbage Collector"=运行垃圾回收
dlgSgGarbageCollector.chk"Also prune recently created objects"=同时删除最近创建的对象
dlgSgGarbageCollector.chk"Expire reflog now \(will also delete stashes!\)"=\
 立即过期操作记录 \(也会删除贮藏\)
dlgSgGarbageCollector.chk"Optimize repository more aggressively \(may take a while\)"=\
 更积极地优化仓库 \(可能需要点时间\)
dlgSgGarbageCollector.hdl=运行垃圾回收
dlgSgGarbageCollector.inf=运行 Git 垃圾回收器将删除不可访问的对象并优化本地仓库，以减少磁盘空间并提高性能。
dlgSgGarbageCollector.tle=运行垃圾回收
dlgSgGarbageCollectorDeleteAllStashes.btn"Delete Stashes"=删除贮藏
dlgSgGarbageCollectorDeleteAllStashes.fur=立即失效 reflog 并删除所有的贮藏.
dlgSgGarbageCollectorDeleteAllStashes.hdl=确定要删除所有贮藏吗?
dlgSgGarbageCollectorDeleteAllStashes.tle=运行垃圾回收
dlgSgGitHubGenerateToken.btn"Authenticate"=认证
dlgSgGitHubGenerateToken.edt"Account"=账号
dlgSgGitHubGenerateToken.edt"Code"=代码
dlgSgGitHubGenerateToken.edt"Link"=链接
dlgSgGitHubGenerateToken.edt"Password"=密码
dlgSgGitHubGenerateToken.hdl=为 GitHub 生成新的 API 令牌
dlgSgGitHubGenerateToken.inf=使用 OAuth 或提供凭据在 GitHub 进行身份验证。
dlgSgGitHubGenerateToken.lbl"Your browser should have opened automatically, let you authenticate with your preferred account at GitHub and grant access to SmartGit. If this didn't happen, manually open following link:"=\
 您的浏览器应该已自动打开，让您通过 GitHub 上的首选账户进行身份验证并授予对 SmartGit 的访问权限。 如果没有发生这种情况，请手动打开以下链接：
dlgSgGitHubGenerateToken.rbt"Authenticate using OAuth \(recommended\)"=使用 OAuth 进行身份验证 \(推荐\)
dlgSgGitHubGenerateToken.rbt"Authenticate with your GitHub account and password"=\
 使用您的 GitHub 账户和密码进行身份验证
dlgSgGitHubGenerateToken.tle=生成 API 令牌
dlgSgGitHubPullRequestCreate.btn"Create"=创建
dlgSgGitHubPullRequestCreate.chk"Draft \(don\'t notify code owners yet\)"=\
 草稿 \(尚未通知代码所有者\)
dlgSgGitHubPullRequestCreate.edt"$1 \u21d2"=$1 \u21d2
dlgSgGitHubPullRequestCreate.edt"Title and Description"=标题和描述
dlgSgGitHubPullRequestCreate.hdl=创建拉取请求
dlgSgGitHubPullRequestCreate.inf=将拉取请求发送到其他仓库或分支。
dlgSgGitHubPullRequestCreate.tle=创建拉取请求
dlgSgGitHubPullRequestMerge.btn"Merge"=合并
dlgSgGitHubPullRequestMerge.btn"Select from Log"=从日志中选择
dlgSgGitHubPullRequestMerge.edt"Commit Message"=提交消息
dlgSgGitHubPullRequestMerge.hdl=合并请求
dlgSgGitHubPullRequestMerge.inf=选择如何合并选定的请求。
dlgSgGitHubPullRequestMerge.lbl"If you have integrated the Pull Request manually, choose this option to close the Pull Request on the server."=\
 如果手动集成了拉取请求，请选择此选项以关闭服务器上的拉取请求。
dlgSgGitHubPullRequestMerge.lbl"If your are fine with the Pull Request changes, choose this option to perform the merge directly on the GitHub server."=\
 如果您对拉取请求变更没有问题，请选择此选项直接在 GitHub 服务器上执行合并。
dlgSgGitHubPullRequestMerge.lbl"To locally check how a Pull Request integrates with the latest commits, choose this option."=\
 要在本地检查拉取请求与最新提交的集成情况，请选择此选项。
dlgSgGitHubPullRequestMerge.rbt"Mark as merged on GitHub Server"=\
 在 GitHub 服务器上标记为已合并
dlgSgGitHubPullRequestMerge.rbt"Merge on GitHub Server"=在 GitHub 服务器上合并
dlgSgGitHubPullRequestMerge.rbt"Merge to Local Repository"=合并到本地仓库
dlgSgGitHubPullRequestMerge.tle=合并拉取请求
dlgSgGitLabGenerateToken.edt"Code"=代码
dlgSgGitLabGenerateToken.edt"Link"=链接
dlgSgGitLabGenerateToken.edt"Token"=令牌
dlgSgGitLabGenerateToken.hdl=输入生成的令牌
dlgSgGitLabGenerateToken.inf=在 Gitlab 验证并输入生成的令牌。
dlgSgGitLabGenerateToken.lbl"Your browser should have opened automatically, let you authenticate with your preferred account at GitLab and grant access to SmartGit. If this didn't happen, manually open following link:"=\
 您的浏览器应该已自动打开，允许您使用您在 Gitlab 的首选账户进行身份验证，并授予对 SmartGit 的访问权限。如果没有发生这种情况，请手动打开以下链接：
dlgSgGitLabGenerateToken.tle=请求访问令牌
dlgSgGitLabMergeRequestCreate.btn"Create"=创建
dlgSgGitLabMergeRequestCreate.edt"$1 \u21d2"=$1 \u21d2
dlgSgGitLabMergeRequestCreate.edt"Title and Description"=标题和描述
dlgSgGitLabMergeRequestCreate.hdl=创建合并请求
dlgSgGitLabMergeRequestCreate.inf=将合并请求发送到其他仓库或分支。
dlgSgGitLabMergeRequestCreate.tle=创建合并请求
dlgSgGitLabSettingsInvalidToken.fur=使用您的 Gitlab 账户中的个人访问令牌。
dlgSgGitLabSettingsInvalidToken.hdl=请为您的 Gitlab 账户输入个人访问令牌。
dlgSgGitLabSettingsInvalidToken.tle=输入验证
dlgSgHeadMessageListenerReplaceMessage.btn"Don't Replace"=不替换
dlgSgHeadMessageListenerReplaceMessage.btn"Replace This Time"=这次更换
dlgSgHeadMessageListenerReplaceMessage.chk=如果已输入消息，请勿更换
dlgSgHeadMessageListenerReplaceMessage.fur=如果提交消息输入字段为空，则将自动重用 HEAD 提交的消息。
dlgSgHeadMessageListenerReplaceMessage.hdl=用 HEAD 提交的消息替换输入的提交消息？
dlgSgHeadMessageListenerReplaceMessage.tle=提交
dlgSgHistoryEditAuthor.btn"Set Author"=设置作者
dlgSgHistoryEditAuthor.edt"Email"=电子邮箱
dlgSgHistoryEditAuthor.edt"User Name"=用户名
dlgSgHistoryEditAuthor.hdl=编辑提交作者
dlgSgHistoryEditAuthor.inf=输入新的提交作者及其电子邮件地址。
dlgSgHistoryEditAuthor.tle=编辑作者
dlgSgHistoryEditMessage.btn"JIRA"=JIRA
dlgSgHistoryEditMessage.btn"Select from Log"=从日志中选择
dlgSgHistoryEditMessage.btn"Select"=选择
dlgSgHistoryEditMessage.btn"Set Message"=设置消息
dlgSgHistoryEditMessage.edt"Commit Message"=提交消息
dlgSgHistoryEditMessage.hdl=修改提交消息
dlgSgHistoryEditMessage.inf=输入新的提交消息。
dlgSgHistoryEditMessage.mni"JIRA"=JIRA
dlgSgHistoryEditMessage.mni"Log"=日志
dlgSgHistoryEditMessage.tle=修改提交消息
dlgSgHistoryModifySplitConfirm.btn"Modify"=修改
dlgSgHistoryModifySplitConfirm.btn"Split"=拆分
dlgSgHistoryModifySplitConfirm.fur=提交后，修改将停止。\n\n 拆分 会将变更放入索引中。您可以放弃应该进入第二次提交的一些变更。\n\n完成变更后，通过继续变基处理剩余的提交。
dlgSgHistoryModifySplitConfirm.hdl%1=你想修改或拆分提交 $1 吗？
dlgSgHistoryModifySplitConfirm.tle=修改或拆分提交
dlgSgHistoryPushCommitsReplaceRemoteBranch.btn"Force Push"=强制推送
dlgSgHistoryPushCommitsReplaceRemoteBranch.fur=推送到远程分支不是快进，所以必须强制推送。远程分支中的提交将丢失。
dlgSgHistoryPushCommitsReplaceRemoteBranch.hdl%1=是否要用提交 $1 替换远程分支？
dlgSgHistoryPushCommitsReplaceRemoteBranch.tle=推送到
dlgSgHistoryPushCommitsUpToCommit.btn"Push"=推送
dlgSgHistoryPushCommitsUpToCommit.fur=对所选提交的所有提交都将被推送到远程仓库。
dlgSgHistoryPushCommitsUpToCommit.hdl%1=是否要将变更向上推送到提交 $1？
dlgSgHistoryPushCommitsUpToCommit.tle=推送到
dlgSgHistoryPushedCommitsModifyPushedCommits.btn"Modify Pushed Commits"=修改已推送的提交
dlgSgHistoryPushedCommitsModifyPushedCommits.fur=已推送的提交对于其他用户是已知的，并且可能已被他们用于构建他们的提交。修改此类提交时，这些用户可能会在以后遇到意外冲突。
dlgSgHistoryPushedCommitsModifyPushedCommits.hdl=你想修改已推送的提交吗？
dlgSgHistoryPushedCommitsModifyPushedCommits.tle=日志
dlgSgHistorySplitConfirm.btn"Split"=拆分
dlgSgHistorySplitConfirm.chk=不再显示
dlgSgHistorySplitConfirm.fur=这会将提交的变更添加到索引中. 取消应进行第二次提交的变更, 然后提交阶段性的变更. 在第二（或第三）次提交中提交其余变更.\n\n完成后, 通过继续重新变基来处理剩余的提交.
dlgSgHistorySplitConfirm.hdl=是否要将所选提交拆分为多个提交?
dlgSgHistorySplitConfirm.tle=拆分提交
dlgSgHistorySquash.btn"JIRA"=JIRA
dlgSgHistorySquash.btn"Select from Log"=从日志中选择
dlgSgHistorySquash.btn"Select"=选择
dlgSgHistorySquash.btn"Squash Commits"=压缩提交
dlgSgHistorySquash.edt"Authorship"=原创
dlgSgHistorySquash.edt"Commit Message"=提交消息
dlgSgHistorySquash.hdl=压缩多个提交
dlgSgHistorySquash.inf=所选提交将被替换为1个压缩提交，该提交包含各个提交的所有变更。
dlgSgHistorySquash.mni"JIRA"=JIRA
dlgSgHistorySquash.mni"Log"=日志
dlgSgHistorySquash.tle=压缩提交
dlgSgHostingProviderAdd.btn"Add"=创建
dlgSgHostingProviderAdd.btn"Generate API Token"=生成 API 令牌
dlgSgHostingProviderAdd.btn"Generate Token"=生成令牌
dlgSgHostingProviderAdd.chk"Use OAuth token for repository authentication \(instead of password\)"=\
 使用 OAuth 令牌进行仓库验证 \(而不是密码\)
dlgSgHostingProviderAdd.chk"Use SSH instead of HTTPS to access repositories"=\
 使用 SSH 替代 HTTPS 来访问仓库
dlgSgHostingProviderAdd.chk"Use SSL client certificates \(usually not required\)"=\
 使用 SSL 客户端证书 \(通常不需要\)
dlgSgHostingProviderAdd.chk"Use a GitHub Enterprise instance"=使用 GitHub 企业实例
dlgSgHostingProviderAdd.chk"Use a custom Azure DevOps server"=\
 使用自定义 Azure DevOps 服务器
dlgSgHostingProviderAdd.chk"Use a custom GitLab server"=使用自定义 GitLab 服务器
dlgSgHostingProviderAdd.edt"Account"=账户
dlgSgHostingProviderAdd.edt"Certificate Password"=证书密码
dlgSgHostingProviderAdd.edt"Client Certificate"=客户端证书
dlgSgHostingProviderAdd.edt"Domain"=域名
dlgSgHostingProviderAdd.edt"Password"=密码
dlgSgHostingProviderAdd.edt"Server URL \(including collection\)"=服务器 URL \(包括集合\)
dlgSgHostingProviderAdd.edt"Server URL"=服务器地址
dlgSgHostingProviderAdd.edt"Token"=令牌
dlgSgHostingProviderAdd.edt"User Name"=用户名
dlgSgHostingProviderAdd.hdl=配置新的主机提供商账户
dlgSgHostingProviderAdd.inf=选择要为其配置新账户的托管服务提供商。
dlgSgHostingProviderAdd.lbl"For example: https://azure.devops.server/DefaultCollection"=例如: https://azure.devops.server/DefaultCollection
dlgSgHostingProviderAdd.lbl"The \(API\) token is a special auto-generated credential which SmartGit will use to authenticate at GitHub. It adds another layer of security, as you can easily revoke access by removing the token from the GitHub front-end."=\
 \(API\) 令牌是一种特殊的自动生成凭证，SmartGit 将使用该凭证在 GitHub 进行身份验证。它增加了另一层安全性，因为您可以通过在 GitHub 网站删除令牌来轻松撤销访问权限。
dlgSgHostingProviderAdd.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your Azure DevOps account settings."=\
 令牌可以是自动生成的 OAuth 令牌 \(使用下面的 “生成令牌”\) ，也可以是可以在 Azure DevOps 账户设置中自行生成 “个人访问令牌”。
dlgSgHostingProviderAdd.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your GitHub account settings."=\
 令牌可以是自动生成的 OAuth 令牌 \(使用下面的 “生成令牌”\) ，也可以是可以在 GitHub 账户设置中自行生成的 “个人访问令牌”。
dlgSgHostingProviderAdd.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your GitLab account settings."=\
 令牌生成方式有两种：1. 点击下面的 “生成令牌” 2. 以在 GitLab 账户设置中手动生成 “个人访问令牌” 。
dlgSgHostingProviderAdd.lbl"Use the same login information as for the assembla website."=\
 使用与 Assembla 网站相同的登录信息。
dlgSgHostingProviderAdd.lbl"Use the same login information as for the beanstalk website and make sure that for 'My Profile' - 'Account' - 'Account Settings' - 'Developer API' is enabled."=\
 使用与 Beanstalk 网站相同的登录信息，并确保在 “我的个人资料” - “账户” - “账户设置” - “开发人员 API” 中启用该功能。
dlgSgHostingProviderAdd.lbl"Use the same login information as for the codebasehq website."=\
 使用与 Codebasehq 网站相同的登录信息。
dlgSgHostingProviderAdd.lbl"Use the same login information as for the unfuddle website."=\
 使用与 Unfuddle 网站相同的登录信息。
dlgSgHostingProviderAdd.tle=添加主机提供商
dlgSgHostingProviderEdit.btn"Generate API Token"=生成 API 令牌
dlgSgHostingProviderEdit.btn"Generate Token"=生成令牌
dlgSgHostingProviderEdit.chk"Use OAuth token for repository authentication \(instead of password\)"=\
 使用 OAuth 令牌进行仓库验证 \(而不是密码\)
dlgSgHostingProviderEdit.chk"Use SSH instead of HTTPS to access repositories"=\
 使用 SSH 替代 HTTPS 来访问仓库
dlgSgHostingProviderEdit.chk"Use SSL client certificates \(usually not required\)"=\
 使用 SSL 客户端证书 \(通常不需要\)
dlgSgHostingProviderEdit.chk"Use a GitHub Enterprise instance"=使用 GitHub 企业实例
dlgSgHostingProviderEdit.chk"Use a custom GitLab server"=使用自定义 GitLab 服务器
dlgSgHostingProviderEdit.edt"Account"=账户
dlgSgHostingProviderEdit.edt"Certificate Password"=证书密码
dlgSgHostingProviderEdit.edt"Client Certificate"=客户端证书
dlgSgHostingProviderEdit.edt"Name"=用户名
dlgSgHostingProviderEdit.edt"Password"=密码
dlgSgHostingProviderEdit.edt"Server URL"=服务器地址
dlgSgHostingProviderEdit.edt"Token"=令牌
dlgSgHostingProviderEdit.err"Please enter a Personal Access Token for your GitLab account."=\
 请为您的 GitLab 账户输入个人访问令牌。
dlgSgHostingProviderEdit.err"Please enter an OAuth 'refresh' token."=\
 请输入 OAuth '刷新'令牌。
dlgSgHostingProviderEdit.err"Please enter the API token."=请输入 API 令牌。
dlgSgHostingProviderEdit.err"Please specify the private key file."=\
 请指定私钥文件。
dlgSgHostingProviderEdit.hdl%1=配置 $1 账户
dlgSgHostingProviderEdit.inf%1=请指定您的凭据以连接到 $1。
dlgSgHostingProviderEdit.lbl"The \(API\) token is a special auto-generated credential which SmartGit will use to authenticate at GitHub. It adds another layer of security, as you can easily revoke access by removing the token from the GitHub front-end."=\
 \(API\) 令牌是一种特殊的自动生成的凭证，SmartGit 将使用该凭证在 GitHub 上进行身份验证。 它增加了另一层安全性，因为您可以通过从 GitHub 前端删除令牌轻松撤消访问。
dlgSgHostingProviderEdit.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your GitHub account settings."=\
 令牌可以是自动生成的 OAuth 令牌 \(使用下面的 “生成令牌”\) ，也可以是可以在 GitHub 账户设置中自行生成的 “个人访问令牌”。
dlgSgHostingProviderEdit.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your GitLab account settings."=\
 令牌生成方式有两种：1. 点击下面的 “生成令牌” 2. 以在 GitLab 账户设置中手动生成 “个人访问令牌”。
dlgSgHostingProviderEdit.tle=GitLab
dlgSgHostingProviderEdit.wrn"Connection to '$1' failed: $2"=连接到 '$1' 失败：$2
dlgSgHostingProviderSelectRepository.btn"Select"=选择
dlgSgHostingProviderSelectRepository.col"Name"=名称
dlgSgHostingProviderSelectRepository.col"Namespace"=命名空间
dlgSgHostingProviderSelectRepository.col"Repository"=仓库
dlgSgHostingProviderSelectRepository.mni"Copy Selection in Column"=按列复制
dlgSgHostingProviderSelectRepository.mni"Name"=名称
dlgSgHostingProviderSelectRepository.mni"Owner"=所有者
dlgSgHostingProviderSelectRepository.mni"Repository"=仓库
dlgSgHostingProviderSelectRepository.tle=GitHub 项目
dlgSgHttpPasswordAuthenticationFailedCause1.fur%3=无法请求 OAuth 访问令牌。很可能您的 $1 配置已更改且 SmartGit 存储的 OAuth 凭据无效。\n\n要解析，请在偏好设置中重新创建 $2 主机提供商。\n\n详细信息：\n\n $3
dlgSgHttpPasswordAuthenticationFailedCause1.hdl%1=$1 OAuth 身份验证失败
dlgSgHttpPasswordAuthenticationFailedCause1.tle=HTTP 身份验证
dlgSgHttpPasswordCredentials.btn"Login"=登录
dlgSgHttpPasswordCredentials.chk"Store password"=存储密码
dlgSgHttpPasswordCredentials.edt"Password"=密码
dlgSgHttpPasswordCredentials.edt"User Name"=用户名
dlgSgHttpPasswordCredentials.hdl%1=登录到 “$1”
dlgSgHttpPasswordCredentials.inf=提供用于对仓库进行身份验证的用户名和密码。
dlgSgHttpPasswordCredentials.tle=登录
dlgSgIgnoreChanged.btn"Discard Changes"=放弃变更
dlgSgIgnoreChanged.fur=继续操作时，变更将被丢弃！
dlgSgIgnoreChanged.hdl=您确定要删除已变更的文档？
dlgSgIgnoreChanged.tle=忽略
dlgSgIgnoreDirectoryConfirm.btn"Ignore"=忽略
dlgSgIgnoreDirectoryConfirm.edt"Ignore File"=忽略文件
dlgSgIgnoreDirectoryConfirm.fur=目录名称将添加到忽略文件中。如果忽略文件不存在，则将自动创建。
dlgSgIgnoreDirectoryConfirm.hdl%1=你想忽略目录 “$1” 吗？
dlgSgIgnoreDirectoryConfirm.tle=忽略
dlgSgIgnoreEdit.btn"Edit"=修改
dlgSgIgnoreEdit.hdl=修改 Git 忽略文件
dlgSgIgnoreEdit.inf=选择要修改的 Git 忽略文件
dlgSgIgnoreEdit.mni"Copy Path"=复制路径
dlgSgIgnoreEdit.mni"Reveal"=显示
dlgSgIgnoreEdit.tle=修改忽略文件
dlgSgIgnoreFile.btn"Ignore"=忽略
dlgSgIgnoreFile.btn"Remove && Ignore"=删除并忽略
dlgSgIgnoreFile.edt"Ignore File"=忽略文件
dlgSgIgnoreFile.err"The pattern must match all selected file names. For instance, '$1' is not matched."=\
 模式必须匹配所有选定的文件名。例如，“$1” 不匹配。
dlgSgIgnoreFile.hdl=标记要忽略的文件
dlgSgIgnoreFile.inf=选择是仅忽略所选文件还是忽略与指定模式匹配的所有文件。跟踪的文件将被删除 \(停止跟踪\)。
dlgSgIgnoreFile.lbl"Use ? to match a single or \* to match multiple arbitrary characters. The pattern will be saved in the .gitignore file of the same directory."=\
 使用 ? 匹配单个或 \* 以匹配多个任意字符。该模式将保存在同一目录的 .gitignore 文件中。
dlgSgIgnoreFile.rbt"Ignore as pattern \(e.g. '\*.obj'\):"=正则忽略 \(例如 \*.obj \)：
dlgSgIgnoreFile.rbt"Ignore explicitly \(e.g. 'Makefile'\)"=明确忽略 \(例如 Makefile \)：
dlgSgIgnoreFile.tle=忽略
dlgSgIndexEditorSaveOrDiscard.btn"Discard"=丢弃
dlgSgIndexEditorSaveOrDiscard.btn"Save"=保存
dlgSgIndexEditorSaveOrDiscard.fur=如果您现在不保存变更，则变更将丢失。
dlgSgIndexEditorSaveOrDiscard.hdl=要保存变更吗？
dlgSgIndexEditorSaveOrDiscard.tle=关闭
dlgSgJournalDoubleClick.btn"Check Out '$1'"=检出 '$1'
dlgSgJournalDoubleClick.btn"Open Log"=打开日志
dlgSgJournalDoubleClick.fur%1=选择以检出 '$1' 或打开所选提交的日志.
dlgSgJournalDoubleClick.hdl%1=确定要检出 '$1' 吗?
dlgSgJournalDoubleClick.tle=日志视图
dlgSgJournalFormCommitCantBeModified.fur=不是您 HEAD 主要父系历史的一部分
dlgSgJournalFormCommitCantBeModified.hdl=至少有一个选定的提交无法修改。
dlgSgJournalFormCommitCantBeModified.tle=编辑作者
dlgSgLfsInstallConfirm.btn"Install"=安装
dlgSgLfsInstallConfirm.fur=这将配置 LFS 所需的挂钩和过滤器。
dlgSgLfsInstallConfirm.hdl=是否要为大文件支持 \(LFS\) 初始化此仓库？
dlgSgLfsInstallConfirm.tle=LFS 安装
dlgSgLfsTrack.edt"Pattern"=模式
dlgSgLfsTrack.err"File '$1' does not match the specified pattern."=\
 文件 “$1” 不匹配指定的模式。
dlgSgLfsTrack.hdl=将文件或模式标记为已跟踪
dlgSgLfsTrack.inf=指定应该由大文件支持 \(LFS\) 处理的文件名模式。
dlgSgLfsTrack.tle=LFS 跟踪
dlgSgLocalChangesFormTakeBlockListenerRevertWorkingTreeFile.btn"Revert"=还原
dlgSgLocalChangesFormTakeBlockListenerRevertWorkingTreeFile.fur%1=您将要将索引中的行应用到工作区文件 “$1”。修改将立即保存。
dlgSgLocalChangesFormTakeBlockListenerRevertWorkingTreeFile.hdl=您真的想要还原工作区中文件的变更吗？
dlgSgLocalChangesFormTakeBlockListenerRevertWorkingTreeFile.tle=还原工作区文件
dlgSgLocalCommandRepositoryEmpty.fur=无法在空仓库上执行请求的操作.
dlgSgLocalCommandRepositoryEmpty.hdl=该仓库为空.
dlgSgLocalCommandRepositoryEmpty.tle=保存贮藏
dlgSgLogCheckoutFileAs.btn"Save After"=保存提交之后的结果
dlgSgLogCheckoutFileAs.btn"Save Before"=保存提交之前的结果
dlgSgLogCheckoutFileAs.edt"Target File"=目标文件
dlgSgLogCheckoutFileAs.hdl=保存仓库文件
dlgSgLogCheckoutFileAs.inf"Select the local file to saved to."=\
 选择要保存到的本地文件。
dlgSgLogCheckoutFileAs.inf"Select whether to save the file state Before or After the selected commit."=\
 选择保存在所选提交之前还是之后的文件状态。
dlgSgLogCheckoutFileAs.tle=文件另存为
dlgSgLogCommentDeleteConfirm.hdl%1=您真的想删除 “$1” 注释吗？
dlgSgLogComment(|s)DeleteConfirm.btn"Delete Comment"=删除注释
dlgSgLogComment(|s)DeleteConfirm.fur=注释被删除后无法还原.
dlgSgLogComment(|s)DeleteConfirm.tle=删除注释
dlgSgLogCommentsDeleteConfirm.hdl%1=您真的想删除 $1 注释吗？
dlgSgLogCompareSelectedFilesAgainstEachOther.btn"Compare Separately"=单独比较
dlgSgLogCompareSelectedFilesAgainstEachOther.btn"Compare With Each Other"=相互比较
dlgSgLogCompareSelectedFilesAgainstEachOther.fur=您可以将所选文件相互比较，或者为每个文件打开单独与其之前的状态比较。
dlgSgLogCompareSelectedFilesAgainstEachOther.hdl=您想要将所选文件相互比较吗？
dlgSgLogCompareSelectedFilesAgainstEachOther.tle=比较
dlgSgLogCompareWithWorkingTree.btn"Compare After"=比较之后
dlgSgLogCompareWithWorkingTree.btn"Compare Before"=比较之前
dlgSgLogCompareWithWorkingTree.edt"Working Tree File"=工作区文件
dlgSgLogCompareWithWorkingTree.hdl=将仓库文件与本地文件进行比较
dlgSgLogCompareWithWorkingTree.inf=选择是与选定提交之前还是之后的仓库文件进行比较。
dlgSgLogCompareWithWorkingTree.tle=与工作区比较
dlgSgLogGraphRootSwitch.chk"Include tracked remote branches"=包括跟踪的远程分支
dlgSgLogGraphRootSwitch.hdl=选择显示的分支
dlgSgLogGraphRootSwitch.inf=选择要在图表中显示提交的分支。
dlgSgLogGraphRootSwitch.mni"Toggle"=切换
dlgSgLogGraphRootSwitch.tle=选择分支
dlgSgLogOpenFailedRepository.fur=仓库是否仍然有效？
dlgSgLogOpenFailedRepository.hdl=仓库无法打开。
dlgSgLogOpenFailedRepository.tle=日志
dlgSgLogOpenFailedSubmodule.fur=仓库是否仍然有效？
dlgSgLogOpenFailedSubmodule.hdl=子模块无法打开。
dlgSgLogOpenFailedSubmodule.tle=日志
dlgSgLogOpenNewWindow.btn"Existing Window"=现有窗口
dlgSgLogOpenNewWindow.btn"New Window"=新建窗口
dlgSgLogOpenNewWindow.fur=已经存在一个可以显示的日志窗口。
dlgSgLogOpenNewWindow.hdl=是否要打开新的日志窗口？
dlgSgLogOpenNewWindow.tle=日志
dlgSgLogOpenSubmoduleLinkOrRepository.btn"History of Updates"=更新历史
dlgSgLogOpenSubmoduleLinkOrRepository.btn"Submodule Log"=子模块日志
dlgSgLogOpenSubmoduleLinkOrRepository.fur=子模块更新的历史日志将显示从父仓库的角度对子模块链接 \('GITLINK'\) 的变更。 子模块仓库的日志将显示子模块仓库本身中发生的所有提交。
dlgSgLogOpenSubmoduleLinkOrRepository.hdl=是否要显示子模块更新的历史日志或子模块仓库的日志？
dlgSgLogOpenSubmoduleLinkOrRepository.tle=打开日志
dlgSgLogRefActionsDeleteConfirm.btn"Delete Branch"=删除分支
dlgSgLogRefActionsDeleteConfirm.fur=您可能会丢失未推送的变更，或还原分支可能会很复杂 \(es\)！
dlgSgLogRefActionsDeleteConfirm.hdl%1=你真的想删除本地分支 “$1” 吗？
dlgSgLogRefActionsDeleteConfirm.tle=删除本地分支
dlgSgLogRefreshRepositoryInvalid.btn"Close Repository"=关闭仓库
dlgSgLogRefreshRepositoryInvalid.btn"Remove Repository"=移除仓库
dlgSgLogRefreshRepositoryInvalid.fur%1=这可能意味着在\n\n $1 的仓库被删除或在 SmartGit 外部重命名。
dlgSgLogRefreshRepositoryInvalid.hdl%1=打开的仓库 “$1” 变为无效。
dlgSgLogRefreshRepositoryInvalid.tle=刷新
dlgSgMerge.btn"Branches"=分支
dlgSgMerge.btn"Create Merge-Commit"=创建合并提交
dlgSgMerge.btn"Merge to Working Tree"=合并到工作区
dlgSgMerge.btn"Squash-Merge"=压缩合并
dlgSgMerge.hdl=合并
dlgSgMerge.inf=选择要合并的分支或提交以及如何将它们合并到工作区中。
dlgSgMerge.mni"Copy ID"=复制 ID
dlgSgMerge.mni"Copy Message"=复制信息
dlgSgMerge.mni"Refresh"=刷新
dlgSgMerge.tle=合并
dlgSgMergeConfirmNoCommit.btn"Merge"=合并
dlgSgMergeConfirmNoCommit.fur=所选修订将合并到工作树.\n\n请注意, 不推荐直接合并到 GitFlow-master 分支. 相反, 你应该先进行 hotfix.
dlgSgMergeConfirmNoCommit.hdl=是否要执行合并?
dlgSgMergeConfirmNoCommit.tle=合并
dlgSgMergeHowToMerge.btn"Create Merge-Commit"=创建合并提交
dlgSgMergeHowToMerge.btn"Fast-Forward"=快进
dlgSgMergeHowToMerge.btn"Merge to Working Tree"=合并到工作区
dlgSgMergeHowToMerge.btn"Squash-Merge"=压缩合并
dlgSgMergeHowToMerge.fur=快进合并意味着只将当前分支 \(HEAD\) 向前移动到选定的提交。作为替代方法，您可以创建合并提交或合并到工作区。 在后一种情况下，您可以查看变更，然后稍后创建合并或普通 \(压缩\) 提交。
dlgSgMergeHowToMerge.hdl"How to merge from branch '$1'?"=\
 如何从分支 “$1” 合并？
dlgSgMergeHowToMerge.hdl"How to merge from tag '$1'?"=\
 如何从标签 '$1' 合并?
dlgSgMergeHowToMerge.tle=合并
dlgSgMergeNoop.fur=虽然 Git 在技术上允许将提交的历史记录合并到其自身中, 但这是禁止的操作，因为不会给出新的提交或任何其他有意义的更改.
dlgSgMergeNoop.hdl=没有内容需要合并.
dlgSgMergeNoop.tle=合并
dlgSgOpenRepository.edt"Repository"=仓库
dlgSgOpenRepository.err"Please specify the root directory of a Git or Mercurial repository."=\
 请指定 Git 或 Mercurial 仓库的根目录。
dlgSgOpenRepository.err"Please specify the root directory of a Git repository."=\
 请指定 Git 仓库的根目录。
dlgSgOpenRepository.hdl=添加现有或创建新仓库
dlgSgOpenRepository.inf=指定要打开的本地 Git 或 Mercurial 仓库。要创建新仓库，请指定一个空目录。
dlgSgOpenRepository.tle=添加或创建仓库
dlgSgOpenRepositoryInitializeChooseVcs.btn"Git"=Git
dlgSgOpenRepositoryInitializeChooseVcs.btn"Mercurial"=Mercurial
dlgSgOpenRepositoryInitializeChooseVcs.fur=指定的目录似乎不是有效的 Git 或 Mercurial 仓库。
dlgSgOpenRepositoryInitializeChooseVcs.hdl=什么 VCS 应该用于初始化 “swt”？
dlgSgOpenRepositoryInitializeChooseVcs.tle=添加或创建仓库
dlgSgOpenRepositoryInitializeGit.btn"Initialize"=初始化
dlgSgOpenRepositoryInitializeGit.fur=指定的目录似乎不是有效的 Git 仓库。
dlgSgOpenRepositoryInitializeGit.hdl%1=是否应该将 '$1' 初始化为新的 Git 仓库？
dlgSgOpenRepositoryInitializeGit.tle=添加或创建仓库
dlgSgOpenRepositorySvnWorkingCopy.fur%1=You are trying to open an existing SVN working copy which is not possible with SmartGit. Instead, please use $1 to create a Git clone of your SVN repository \(i.e. a working copy based on Git instead of SVN\).
dlgSgOpenRepositorySvnWorkingCopy.hdl=无法打开 SVN 工作副本, 请使用 SmartGit 重新克隆.
dlgSgOpenRepositorySvnWorkingCopy.tle=添加或创建仓库
dlgSgOutput.chk"Don't show again for these $1 warnings"=\
 不要再显示这些 $1 警告
dlgSgOutput.chk"Don't show again for this warning"=\
 不要再显示此警告
dlgSgOutput.chk"Show automatically for failed command"=自动显示失败的命令
dlgSgOutput.lbl"Branches need merging first."=需要先合并分支.
dlgSgOutput.lbl"Command Abort failed!"=终止命令失败!
dlgSgOutput.lbl"Command Check Out Branch failed!"=检出分支命令失败!
dlgSgOutput.lbl"Command Cherry-Pick produced warnings."=摘取命令产生了警告.
dlgSgOutput.lbl"Command Commit failed!"=提交失败!
dlgSgOutput.lbl"Command Discard failed!"=丢弃失败!
dlgSgOutput.lbl"Command Pull \(Rebase\) failed!"=拉取 \(变基\) 失败!
dlgSgOutput.lbl"Command Pull \(Rebase\) produced warnings."=拉取 \(变基\) 命令产生了警告.
dlgSgOutput.lbl"Command Reset failed!"=重置失败!
dlgSgOutput.lbl"Command Start Support Branch failed!"=Command Start Support Branch failed!
dlgSgOutput.lbl"If in question, please ask your repository administrator."=\
 如果有问题，请咨询您的仓库管理员。
dlgSgOutput.lbl"Not all refs have been pushed."=\
 有些引用未被推送.
dlgSgOutput.lbl"Your local changes to the following files would be overwritten by checkout:\ncould not detach HEAD"=\
 您对以下文件的本地更改将被签出覆盖:\n无法分离 HEAD
dlgSgOutput.tle"Command Failed"=命令失败
dlgSgOutput.tle"Command Output"=命令输出
dlgSgOutput.tle"Command Succeeded"=命令成功
dlgSgOutput.tle"Output"=输出
dlgSgPingRepositoryFailed.fur%1=请检查仓库 URL。\n\n$1
dlgSgPingRepositoryFailed.hdl%1=无法连接到仓库 “$1”。
dlgSgPingRepositoryFailed.tle=克隆
dlgSgPreferences.btn"Add"=创建
dlgSgPreferences.btn"Assign"=分配
dlgSgPreferences.btn"Change Master Password"=更改主密码
dlgSgPreferences.btn"Clear Cache"=清除缓存
dlgSgPreferences.btn"Clear"=清除
dlgSgPreferences.btn"Copy"=复制
dlgSgPreferences.btn"Edit"=编辑
dlgSgPreferences.btn"Export"=导出
dlgSgPreferences.btn"I accept the risk!"=我接受风险！
dlgSgPreferences.btn"Import"=导入
dlgSgPreferences.btn"Move Down"=下移
dlgSgPreferences.btn"Move Up"=上移
dlgSgPreferences.btn"Re-Add Defaults"=重新添加默认值
dlgSgPreferences.btn"Remove All"=移除所有
dlgSgPreferences.btn"Remove"=移除
dlgSgPreferences.btn"Reset to Defaults"=重置为默认
dlgSgPreferences.btn"Reset"=重置
dlgSgPreferences.btn"Show Password"=显示密码
dlgSgPreferences.cdl"Authentication"=认证
dlgSgPreferences.cdl"Background Commands"=后台命令
dlgSgPreferences.cdl"Built-in Text Editors"=内置文本编辑器
dlgSgPreferences.cdl"Commands"=命令
dlgSgPreferences.cdl"Conflict Solvers"=冲突解决工具
dlgSgPreferences.cdl"Diff Tools"=差异工具
dlgSgPreferences.cdl"Executables"=可执行文件
dlgSgPreferences.cdl"Git Config"=Git 配置
dlgSgPreferences.cdl"Git Executable"=Git 可执行文件
dlgSgPreferences.cdl"Hosting Providers"=托管服务提供商
dlgSgPreferences.cdl"Keyboard Shortcuts"=键盘快捷键
dlgSgPreferences.cdl"Log and Working Tree window"=日志和工作区窗口
dlgSgPreferences.cdl"Log"=日志
dlgSgPreferences.cdl"Low-level Properties"=低级属性
dlgSgPreferences.cdl"Privacy"=隐私
dlgSgPreferences.cdl"Proxy"=代理
dlgSgPreferences.cdl"Refresh"=刷新
dlgSgPreferences.cdl"SmartGit Updates"=SmartGit 更新
dlgSgPreferences.cdl"Spell Checker"=拼写检查
dlgSgPreferences.cdl"Standard Window"=标准窗口
dlgSgPreferences.cdl"Tools"=工具
dlgSgPreferences.cdl"User Interface"=用户界面
dlgSgPreferences.chk"Add untracked files"=添加未跟踪的文件
dlgSgPreferences.chk"Allow all commands on stash and pull request commits"=\
 允许所有关于贮藏和拉取请求提交的命令
dlgSgPreferences.chk"Allow modifying pushed commits \(e.g. forced-push\)"=\
 允许修改推送的提交 \(例如：强制推送\)
dlgSgPreferences.chk"Allow to open multiple Log windows for the same repository/file"=\
 允许为同一仓库/文件打开多个日志窗口
dlgSgPreferences.chk"Also detect renames for untracked and missing files"=\
 检测未跟踪和丢失的文件的重命名
dlgSgPreferences.chk"Always fetch new commits, tags and branches from submodule"=\
 始终从子模块中获取新的提交、标签和分支
dlgSgPreferences.chk"Ask for master password on startup"=\
 在启动时询问主密码
dlgSgPreferences.chk"Autoindent new lines"=自动缩进新行
dlgSgPreferences.chk"Automatically save stash on common commands, if they fail due to local changes"=\
 如果由于本地变更而导致失败，则自动将贮藏保存在常用命令上
dlgSgPreferences.chk"Automatically send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后自动发送 “崩溃追踪”
dlgSgPreferences.chk"Automatically set up tracking for new branches \(requires push.default to be unset\)"=\
 自动设置新分支的跟踪 \(需要取消设置 push.default \)
dlgSgPreferences.chk"Automatically set up tracking for new branches"=\
 自动设置新分支的跟踪
dlgSgPreferences.chk"Begin of line: jump to first non-whitespace character"=\
 行首：跳转到第1个非空白字符
dlgSgPreferences.chk"Closed 'favorite' repositories"=“我的收藏” 已关闭的仓库
dlgSgPreferences.chk"Compare with working tree, even if all changes are staged"=\
 与工作区比较，即使所有变更都已暂存
dlgSgPreferences.chk"Detect local changes in closed 'favorite' repositories"=\
 检测 “我的收藏” 中已关闭仓库中的本地变更
dlgSgPreferences.chk"Detect remote changes"=检测远程变更
dlgSgPreferences.chk"Detect renames \(for added and removed files, as command line Git does\)"=\
 检测重命名 \(创建和删​​除文件，如 Git 命令行所做的那样\)
dlgSgPreferences.chk"Distinguish between content and EOL-only changes \(slightly more expensive\)"=\
 区分内容和 EOL-only 的变更 \(稍微昂贵的代价\)
dlgSgPreferences.chk"Enable integration for configured hosting providers \(pull requests, comments\)"=\
 为已配置的主机提供商启用集成 \(拉取请求，注释\)
dlgSgPreferences.chk"Focus next change after accepting change \(Take Left/Take Right\)"=\
 接受变更后，关注下一个变化 \(采用左侧/右侧\)
dlgSgPreferences.chk"For Preview versions, automatically download the latest build"=\
 对于预览版本，自动下载最新版本
dlgSgPreferences.chk"For ambiguous protocols like 'https', show dialog to choose between Git and SVN clone"=\
 对于像 "https" 这样含糊不清的协议，显示选择Git或SVN克隆的对话框
dlgSgPreferences.chk"Highlight current line in text content"=\
 突出显示文本内容中的当前行
dlgSgPreferences.chk"Home and end: operate on line, not the document"=\
 首页和结尾：在线操作，而不是文档
dlgSgPreferences.chk"Include untracked files"=包括未跟踪的文件
dlgSgPreferences.chk"Initialize new submodules"=初始化新的子模块
dlgSgPreferences.chk"Left and right cursor moves: limit to current line"=\
 左右光标移动：限制为当前行
dlgSgPreferences.chk"Open repositories when idle"=空闲时打开仓库
dlgSgPreferences.chk"Open the last used repositories"=打开最后使用的仓库
dlgSgPreferences.chk"Periodically invoke Git's garbage collection when idle"=\
 空闲时定期调用 Git 的垃圾回收
dlgSgPreferences.chk"Preselect 'Staged' if files are staged, even if a file without staged changes is selected"=\
 如果文件已暂存，则预选 “已暂存”，即使选择了没有暂存变更的文件也是如此
dlgSgPreferences.chk"Proxy requires authentication"=代理需要身份验证
dlgSgPreferences.chk"Prune obsolete remote tracked branches"=修剪废弃的远程跟踪分支
dlgSgPreferences.chk"Push all tags"=推送所有标签
dlgSgPreferences.chk"Refresh file system also while SmartGit is in background"=\
 SmartGit 在后台工作时也刷新文件系统
dlgSgPreferences.chk"Remember from last used single Log or Working Tree window"=\
 记住最后使用的日志或者工作区的窗口
dlgSgPreferences.chk"Remove leading and trailing whitespace from commit message"=\
 从提交消息中删除前导和尾随空格
dlgSgPreferences.chk"Remove missing files"=删除丢失的文件
dlgSgPreferences.chk"Restore all confirmation dialogs"=还原所有确认对话框
dlgSgPreferences.chk"Send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后发送 “崩溃跟踪”
dlgSgPreferences.chk"Send usage statistics"=发送使用量统计
dlgSgPreferences.chk"Show also the resolve dialog for external conflict solvers"=\
 也显示外部冲突解决工具的解决对话框
dlgSgPreferences.chk"Show chooser dialog if multiple entries match"=\
 如果匹配多个条目，显示选择器对话框
dlgSgPreferences.chk"Show line length guides \(only useful for monospaced-font\)"=\
 显示行长参考线 \(仅适用于单空格字体\)
dlgSgPreferences.chk"Show verbose date for last days, e.g. Yesterday"=\
 显示最后几天的详细日期，例如：昨天
dlgSgPreferences.chk"Show welcome dialog if no repository has been reopened"=\
 如果没有重新打开仓库，则显示欢迎对话框
dlgSgPreferences.chk"Sign all commits"=对所有提交进行签名
dlgSgPreferences.chk"Swap 'ours' and 'theirs' on Rebase conflicts for easier understanding"=\
 在变基冲突上使用 “我们的” 和 “他们的” 显示以便于理解
dlgSgPreferences.chk"Tab enters and Backspace deletes multiple leading spaces"=\
 制表符 \(Tab\) 输入和退格键 \(Backspace\)删除多个前导空格
dlgSgPreferences.chk"Trim whitespace"=删除空格
dlgSgPreferences.chk"Update registered submodules"=更新已注册的子模块
dlgSgPreferences.chk"Use gravatar.com to show images for the users"=\
 使用 gravatar.com 为用户显示图像
dlgSgPreferences.chk"Use indentation from previous non-empty line"=\
 使用前一个非空行的缩进
dlgSgPreferences.chk"Use pre-installed \(\"system\"\) Git-Flow\*"=使用预装 \(系统\) Git 工作流\*
dlgSgPreferences.chk"Warn for slow rename detection"=重命名检测缓慢时发出警告
dlgSgPreferences.col"Accelerator"=快捷键
dlgSgPreferences.col"Account"=账号
dlgSgPreferences.col"Applies To"=适用于
dlgSgPreferences.col"Arguments"=参数
dlgSgPreferences.col"Command + Arguments"=命令和参数
dlgSgPreferences.col"Command"=命令
dlgSgPreferences.col"Default"=默认
dlgSgPreferences.col"Details"=详情
dlgSgPreferences.col"Dictionary File"=字典文件
dlgSgPreferences.col"File Pattern"=文件模式
dlgSgPreferences.col"Key"=键
dlgSgPreferences.col"Language"=语言
dlgSgPreferences.col"Name"=名称
dlgSgPreferences.col"Patterns"=模式
dlgSgPreferences.col"Repository"=仓库
dlgSgPreferences.col"Shortcut"=快捷键
dlgSgPreferences.col"Value"=值
dlgSgPreferences.edt"Date Format\*"=日期格式\*
dlgSgPreferences.edt"Double-Clicking Local File"=双击本地文件
dlgSgPreferences.edt"Email"=电子邮箱
dlgSgPreferences.edt"Example"=例如
dlgSgPreferences.edt"Fetch"=获取
dlgSgPreferences.edt"File Double-Click"=双击文件
dlgSgPreferences.edt"File Name Matches\*"=文件名匹配\*
dlgSgPreferences.edt"Font Family"=字体系列
dlgSgPreferences.edt"Font Size"=字体大小
dlgSgPreferences.edt"Functionality\*"=功能\*
dlgSgPreferences.edt"GPG Program"=GPG 程序
dlgSgPreferences.edt"Git Executable"=Git 可执行文件
dlgSgPreferences.edt"Hg Executable"=Hg 可执行文件
dlgSgPreferences.edt"Host"=服务器
dlgSgPreferences.edt"Known credentials"=已知凭据
dlgSgPreferences.edt"Language\*"=语言\*
dlgSgPreferences.edt"Name"=Name
dlgSgPreferences.edt"On startup"=在启动时
dlgSgPreferences.edt"Password"=密码
dlgSgPreferences.edt"Port"=端口
dlgSgPreferences.edt"Prefer"=喜欢
dlgSgPreferences.edt"Preview"=预览
dlgSgPreferences.edt"Shortcut"=快捷键
dlgSgPreferences.edt"Signing Key"=签名密钥
dlgSgPreferences.edt"Startup Window"=标准窗口
dlgSgPreferences.edt"Submodule handling\*"=子模块处理\*
dlgSgPreferences.edt"Suggest to"=建议
dlgSgPreferences.edt"Text File Encoding"=文本文件编码
dlgSgPreferences.edt"Theme"=主题
dlgSgPreferences.edt"Theme\*"=主题\*
dlgSgPreferences.edt"Time Format\*"=时间格式\*
dlgSgPreferences.edt"Username"=用户名
dlgSgPreferences.hnt"Search"=搜索
dlgSgPreferences.lbl"Application can be updated manually in the About dialog"=\
 可以在“关于”对话框中手动更新应用程序
dlgSgPreferences.lbl"Changing these low-level properties can be harmful to the stability or performance of SmartGit. You should only continue if you are sure of what you are doing. Changed properties with a trailing \* need a restart to be applied."=\
 更改这些低级别属性可能会损害 SmartGit 的稳定性或性能。只有在确定自己在做什么的情况下才能继续。结尾含 \* 的属性更改之后需要重新启动才能生效。
dlgSgPreferences.lbl"Define external tools which will show up in the Tools menu. Those marked with a leading \* in front of the name can be used by the Open command."=\
 定义将显示在 “工具” 菜单中的外部工具。“打开” 命令可以使用在名称前面标有前导 \* 的那些。
dlgSgPreferences.lbl"Here you can edit your account's 'gitconfig' which contains the defaults for all repositories."=\
 在这里，您可以编辑帐户的 'gitconfig' ，其中包含所有仓库的默认值。
dlgSgPreferences.lbl"Here you can view your account's 'gitconfig'. Because it contains 'include'-sections you need to edit it manually."=\
 在这里，您可以查看您帐户的 'gitconfig' 。由于它包含“包含”部分，因此您需要手动编辑它。
dlgSgPreferences.lbl"If you are using SSH to connect to other Git repositories, select what SSH client to use."=\
 如果您使用 SSH 连接到其他 Git 仓库，请选择要使用的 SSH 客户端。
dlgSgPreferences.lbl"In order to use all SmartGit functionality, you need to have command line Git installed on your system. Provide here the full path to the installed 'git' executable."=\
 要使用所有 SmartGit 功能，您需要在系统上安装 Git 命令行。在这里提供已安装的 “git” 可执行文件的完整路径。
dlgSgPreferences.lbl"In order to use all SmartGit functionality, you need to have command line Git or Mercurial installed on your system. Provide here the full path to the installed 'git' or 'hg' executable."=\
 要使用所有 SmartGit 功能，您需要在系统上安装 Git 命令行或 Mercurial。在这里提供已安装的 “git” 或 “hg” 可执行文件的完整路径。
dlgSgPreferences.lbl"Note: The password will be stored in plain text in SmartGit's configuration area!"=\
 注意：密码将以纯文本形式存储在 SmartGit 的配置区域中！
dlgSgPreferences.lbl"Please help to improve SmartGit's quality by automatically sending 'crash footprints' which do not contain any sensitive information. You can change this option later in the preferences.\n\nA 'crash footprint' contains details about your machine \(e.g. version of operating system\), SmartGit's version/build number, the JVM state and where the internal error occurred.\n\nIt contains NO POTENTIALLY SENSITIVE INFORMATION like user names, email addresses, file contents, file paths or server names."=\
 请通过自动发送不包含任何敏感信息的 “崩溃踪迹” 来帮助提高 SmartGit 的质量。您可以稍后在偏好设置中更改此选项。\n\n崩溃踪迹包含有关您的计算机\的详细信息 \(例如，操作系统的版本\)，SmartGit 的版本/内部版本号，JVM 状态以及发生内部错误的位置。\n\n它不包含任何潜在的敏感信息，如用户名，电子邮件地址，文件内容，文件路径或服务器名称。
dlgSgPreferences.lbl"The proxy is primarily used for the Check for New Version. It will also be used for Git HTTP\(s\) connections if no reasonable system proxy configuration seems to be present already \(see documentation for details\)."=\
 代理主要用于检查新版本。如果似乎没有合理的系统代理配置，它也将用于 Git HTTP\(s\)连接 \(请参阅文档了解详细信息\)。
dlgSgPreferences.lbl"This file will be sent as is: $1"=\
 将发送文件: $1
dlgSgPreferences.lbl"When comparing files, this list is searched from top to bottom to find a matching diff tool. If none is found, the built-in file compare is used for text files."=\
 比较文件时，将从上到下搜索此列表以查找匹配的差异工具。如果未找到，则内置文件比较用于文本文件。
dlgSgPreferences.lbl"When invoking the Conflict Solver feature, this list is searched from top to bottom to find a matching entry. If none is found, the built-in Conflict Solver is used for text files."=\
 调用冲突解决工具功能时，将从上到下搜索此列表以查找匹配的条目。如果未找到，则内置的冲突解决工具用于文本文件。
dlgSgPreferences.lbl"You may configure hosting provider accounts to simplify accessing your hosted repositories or to enable the GitHub pull request and comment features."=\
 您可以配置主机提供商账户以简化对托管仓库的访问或启用 GitHub 拉取请求和注释功能。
dlgSgPreferences.lbl"\* if repository commit references non-pushed submodule commit"=\
 \* if repository commit references non-pushed submodule commit
dlgSgPreferences.lbl"\*\) these options require an application restart to be applied"=\
 \*\) 这些选项需要重新启动应用程序
dlgSgPreferences.lbl"\*\) this option requires an application restart to be applied"=\
 \*\) 这些选项需要重新启动应用程序
dlgSgPreferences.lbl"easy to set up and use, supports public key and password authentication"=\
 轻松设置和使用, 支持公钥和密码身份验证
dlgSgPreferences.lbl"may be harder to configure and use for new users, but is more flexible"=\
 对新手来说稍微复杂, 但更灵活
dlgSgPreferences.mni"Accelerator"=快捷键
dlgSgPreferences.mni"Account"=账户
dlgSgPreferences.mni"Applies To"=适用于
dlgSgPreferences.mni"Arguments"=参数
dlgSgPreferences.mni"Command + Arguments"=命令和参数
dlgSgPreferences.mni"Command"=命令
dlgSgPreferences.mni"Copy Key"=复制键
dlgSgPreferences.mni"Copy Selection in Column"=复制列中的选定内容
dlgSgPreferences.mni"Default"=默认
dlgSgPreferences.mni"Details"=详情
dlgSgPreferences.mni"Dictionary File"=字典文件
dlgSgPreferences.mni"Edit"=编辑
dlgSgPreferences.mni"File Pattern"=文件模式
dlgSgPreferences.mni"Language"=语言
dlgSgPreferences.mni"Name"=名称
dlgSgPreferences.mni"Patterns"=模式
dlgSgPreferences.mni"Repository"=仓库
dlgSgPreferences.mni"Reset to Default"=重置为默认值
dlgSgPreferences.mni"Reset"=重置
dlgSgPreferences.mni"Select"=选择
dlgSgPreferences.mni"Shortcut"=快捷键
dlgSgPreferences.mni"Swap"=交换
dlgSgPreferences.rbt"Advanced \(merge, rebase, ignore, stashes, tags, history modifications\)"=\
 高级 \(合并、变基、忽略、隐藏、标签、历史记录修改\)
dlgSgPreferences.rbt"Auto-detect the system proxy"=自动检测系统代理
dlgSgPreferences.rbt"Automatically download and install updates"=自动下载并安装更新
dlgSgPreferences.rbt"Basic \(for simple workflows\)"=基础 \(用于简单工作流\)
dlgSgPreferences.rbt"Check and report new updates"=检查更新并提醒
dlgSgPreferences.rbt"Dark"=深色
dlgSgPreferences.rbt"Do not check for new updates"=\
 不检查更新
dlgSgPreferences.rbt"Don't use a proxy"=不使用代理
dlgSgPreferences.rbt"Exact case \('Foo' will match 'Foo', but not 'foo'\)"=\
 精确匹配 \(“Foo” 会匹配 “Foo”, 但不会匹配 “foo”\)
dlgSgPreferences.rbt"Ignore case \('Foo' will match 'Foo' and 'foo'\)"=\
 忽略大小写 \(“Foo” 会匹配 “Foo” 和 “foo”\)
dlgSgPreferences.rbt"Light"=轻量
dlgSgPreferences.rbt"Log Graph"=日志图
dlgSgPreferences.rbt"Log graph \(commit oriented\)"=日志图 \(面向提交\)
dlgSgPreferences.rbt"Prefer light-weight updates stored in home directory"=\
 首选存储在主目录中的轻量级更新
dlgSgPreferences.rbt"Show changes or open"=显示变更或打开
dlgSgPreferences.rbt"Shows changes or opens the file"=\
 显示变更或打开文件
dlgSgPreferences.rbt"Smart upper case \('FoB' will match 'FooBar', but neither 'foobar' nor 'Fob'\)"=\
 智能大写 \(“FoB” 将匹配 “FooBar”，但既不 “foobar” 也不 “Fob”\)
dlgSgPreferences.rbt"Stage or unstage"=暂存或取消暂存
dlgSgPreferences.rbt"Stages or unstages changes"=暂存或取消暂存变更
dlgSgPreferences.rbt"Standard \(workflow oriented\)"=标准 \(面向工作流\)
dlgSgPreferences.rbt"Update SmartGit application in-place \(may require administrator permissions\)"=\
 就地更新 SmartGit 应用程序 \(可能需要管理员权限\)
dlgSgPreferences.rbt"Use SmartGit as SSH client"=使用 Smart Git 作为 SSH 客户端
dlgSgPreferences.rbt"Use following proxy"=使用以下代理
dlgSgPreferences.rbt"Use system SSH client"=使用系统 SSH 客户端
dlgSgPreferences.rbt"Working Tree"=工作区
dlgSgPreferences.rbt"Working tree \(file oriented\)"=工作区 \(面向文档\)
dlgSgPreferences.tab"Behavior"=行为
dlgSgPreferences.tab"Colors"=颜色
dlgSgPreferences.tab"Encoding"=编码
dlgSgPreferences.tab"Font"=字体
dlgSgPreferences.tab"Languages"=语言
dlgSgPreferences.tab"Pull"=拉取
dlgSgPreferences.tab"Push"=推送
dlgSgPreferences.tab"Signing"=签名
dlgSgPreferences.tab"User"=用户
dlgSgPreferences.tle=偏好设置
dlgSgProcessKiller.btn"Kill Process"=终止进程
dlgSgProcessKiller.btn"Wait"=等待
dlgSgProcessKiller.lbl"If you think the process is hanging, click the 'Kill Process' button, otherwise 'Wait'."=\
 如果进程卡住了, 可以终止进程或等待.
dlgSgProcessKiller.tle=进程无响应
dlgSgProviderPullRequestCreateNoTargetRepositories.fur=该仓库不是 GitHub 复刻仓库，也没有复刻了此仓库的其它远程仓库。
dlgSgProviderPullRequestCreateNoTargetRepositories.hdl=找不到目标仓库。
dlgSgProviderPullRequestCreateNoTargetRepositories.tle=创建拉取请求
dlgSgProviderPullRequestDropConfirmMr.btn"Drop"=终止
dlgSgProviderPullRequestDropConfirmMr.fur=拉取请求本身不会在服务器上删除。
dlgSgProviderPullRequestDropConfirmMr.hdl%1=是否确定要删除请求 $1 的本地提交？
dlgSgProviderPullRequestDropConfirmMr.tle=终止拉取请求
dlgSgProviderPullRequestDropConfirmPr.btn"Drop"=终止
dlgSgProviderPullRequestDropConfirmPr.fur=拉取请求本身不会在服务器上删除。
dlgSgProviderPullRequestDropConfirmPr.hdl%1=是否确定要删除请求 $1 的本地提交？
dlgSgProviderPullRequestDropConfirmPr.tle=终止拉取请求
dlgSgProviderPullRequestRetractMr.btn"Retract"=撤消
dlgSgProviderPullRequestRetractMr.edt"Comment"=注释
dlgSgProviderPullRequestRetractMr.hdl=撤消合并请求
dlgSgProviderPullRequestRetractMr.inf=输入将使用已关闭的合并请求记录的注释。
dlgSgProviderPullRequestRetractMr.tle=撤消合并请求
dlgSgProviderPullRequestRetractPr.btn"Retract"=撤消
dlgSgProviderPullRequestRetractPr.edt"Comment"=注释
dlgSgProviderPullRequestRetractPr.hdl=撤消合并请求
dlgSgProviderPullRequestRetractPr.inf=输入将使用已关闭的合并请求记录的注释。
dlgSgProviderPullRequestRetractPr.tle=撤消合并请求
dlgSgPull.btn"Fetch Only"=获取
dlgSgPull.btn"Pull"=拉取
dlgSgPull.chk"Fetch from all remotes"=从全部远端获取更新
dlgSgPull.chk"More Options"=更多选项
dlgSgPull.chk"Remember as default for repository"=记住作为仓库的默认值
dlgSgPull.chk"Update existing and fetch new tags"=\
 更新现有标签并获取新标签
dlgSgPull.edt"Fetch From"=获取
dlgSgPull.hdl=从远程仓库中拉取提交
dlgSgPull.inf"In contrast to Fetch Only, Pull will also incorporate the fetched changes \(expand the options below to configure\)."=\
 与 “仅获取” 相比,拉取还将包含获取的变更 \(展开下面的选项进行配置\)。
dlgSgPull.inf"Select the remote repository to pull. In contrast to Fetch Only, Pull will also incorporate the fetched changes \(expand the options below to configure\)."=\
 选择要获取的远程仓库。与 “仅获取” 相比,拉取还将包含获取的变更 \(展开下面的选项进行配置\)。
dlgSgPull.tle=拉取
dlgSgPullConfiguration.btn"Configure"=配置
dlgSgPullConfiguration.chk"Remember as default for other repositories"=\
 记住作为其他仓库的默认选项
dlgSgPullConfiguration.hdl=配置如何拉取
dlgSgPullConfiguration.inf=指定是否在当前仓库的拉取上进行合并或变基。
dlgSgPullConfiguration.lbl"Merging produces additional 'merge'-commits and is not recommended. It might however be a convention of your repository \(ask the maintainer to find out\)."=\
 合并会产生额外的 “合并” 提交，通常不建议使用. 然而，它可能是您的仓库的惯例 \(要求维护者找出\)。
dlgSgPullConfiguration.lbl"Rebasing gives a clean linear history and is recommended in general."=\
 变基提供了清晰的线性历史记录，建议使用。
dlgSgPullConfiguration.rbt"Merge"=合并
dlgSgPullConfiguration.rbt"Rebase"=变基
dlgSgPullConfiguration.tle=配置拉取
dlgSgPullMergeInsteadOfRebase.btn"Merge"=合并
dlgSgPullMergeInsteadOfRebase.btn"Rebase"=变基
dlgSgPullMergeInsteadOfRebase.fur%1=在变基的变更中有合并提交 $1。 变基合并提交很容易造成麻烦。
dlgSgPullMergeInsteadOfRebase.hdl=您想合并本地变更而不是变基吗？
dlgSgPullMergeInsteadOfRebase.tle=拉取
dlgSgPullNoRemoteRepository.btn"Add Remote"=创建远程
dlgSgPullNoRemoteRepository.fur=您首先需要创建远程仓库来拉取。
dlgSgPullNoRemoteRepository.hdl=没有找到远程仓库。
dlgSgPullNoRemoteRepository.tle=拉取
dlgSgPullOrJustFetch.btn"Fetch"=获取
dlgSgPullOrJustFetch.btn"Pull"=拉取
dlgSgPullOrJustFetch.chk"Fetch from all remotes"=从所有远程获取
dlgSgPullOrJustFetch.chk"Update existing and fetch new tags"=\
 更新现有标签并获取新标签
dlgSgPullOrJustFetch.fur=您可以在仓库设置中变更拉取行为。
dlgSgPullOrJustFetch.hdl%1=你想拉取或只是获取 $1 的仓库？
dlgSgPullOrJustFetch.tle=拉取
dlgSgPushConfirmSingleBranch.btn"Push"=推送
dlgSgPushConfirmSingleBranch.chk=不再显示
dlgSgPushConfirmSingleBranch.fur%1=分支将被推至 “$1” 。
dlgSgPushConfirmSingleBranch.hdl%1=你想要推送分支 “$1” 吗？
dlgSgPushConfirmSingleBranch.tle=推送
dlgSgPushForced.btn"Force Push"=强制推送
dlgSgPushForced.fur=推送到远程分支不是快进的，因此必须强制推送。远程分支中的提交将丢失。
dlgSgPushForced.hdl=你想强制推送 \(替换\) 远程分支吗？
dlgSgPushForced.tle=推送
dlgSgPushForcedSvn.btn"Force Push"=强制推送
dlgSgPushForcedSvn.fur=您即将更换远程分支。该分支的修订可能不再是 \(容易\) 可访问的。
dlgSgPushForcedSvn.hdl=是否要强制推送 \(替换\) 远程分支吗？
dlgSgPushForcedSvn.tle=推送
dlgSgPushOverwriteRemoteBranchConfirm.btn"Push"=推送
dlgSgPushOverwriteRemoteBranchConfirm.chk=覆盖远程变更
dlgSgPushOverwriteRemoteBranchConfirm.fur=您即将更换远程分支，其中包含您根本没有看到的提交。也许你想在之前合并/改造远程变更？
dlgSgPushOverwriteRemoteBranchConfirm.hdl=你真的想要覆盖远程分支吗？
dlgSgPushOverwriteRemoteBranchConfirm.tle=推送
dlgSgPushToNoTagsOrLocalBranches.fur=您只能推送标签或本地分支。
dlgSgPushToNoTagsOrLocalBranches.hdl=没有标签或本地分支推送。
dlgSgPushToNoTagsOrLocalBranches.tle=推送到
dlgSgPushToRef.btn"Push"=推送
dlgSgPushToRef.chk"Force pushing \(even if it's not fast-forward\)"=\
 强制推送 \(即使非快进方式\)
dlgSgPushToRef.edt"Push To"=推送到
dlgSgPushToRef.edt"Target Repository"=目标仓库
dlgSgPushToRef.err"Enter the remote location to which the commits of the current branch should be pushed to."=\
 输入当前分支提交应推送到的远程位置。
dlgSgPushToRef.err"Please specify a valid Git ref."=\
 请指定有效的 Git 引用。
dlgSgPushToRef.hdl"Push '$1' to a remote repository"=\
 将 “$1” 推送到远程仓库
dlgSgPushToRef.hdl"Push '$1' to remote '$2'"=将 “$1” 推送到远程 “$2”
dlgSgPushToRef.inf=选择目标仓库，在其中推送引用。
dlgSgPushToRef.rbt"Custom Ref:"=自定义引用：
dlgSgPushToRef.rbt"Tracked or matching branch"=跟踪或匹配分支
dlgSgPushToRef.tle=推送到
dlgSgPushToRemote.btn"Push"=推送
dlgSgPushToRemote.chk"Force pushing \(even if it's not fast-forward\)"=\
 强制推送 \(即使非快进方式\)
dlgSgPushToRemote.chk"Remove remote branches which don't have a local counterpart"=\
 删除没有本地对应的远程分支
dlgSgPushToRemote.edt"Target Repository"=目标仓库
dlgSgPushToRemote.hdl%1=将 '$1' 分支推送到其他远程
dlgSgPushToRemote.inf%1='$1' 的所有分支（在本地由相应的远程分支代表）将被推送到目标仓库.
dlgSgPushToRemote.tle=推送到
dlgSgPushToRemoteRemoveTargetBranches.btn"Remove"=删除
dlgSgPushToRemoteRemoveTargetBranches.fur=删除之后会丢失的目标远程中的分支和它们的提交.
dlgSgPushToRemoteRemoveTargetBranches.hdl=确定要删除远程分支么?
dlgSgPushToRemoteRemoveTargetBranches.tle=推送到
dlgSgPushToRemoteResetTargetBranches.btn"Force Push"=强制推送
dlgSgPushToRemoteResetTargetBranches.chk=不再显示
dlgSgPushToRemoteResetTargetBranches.fur=强制推送将覆盖目标远程中的分支及其提交，这些分支及其提交随后将丢失。
dlgSgPushToRemoteResetTargetBranches.hdl=是否确定要重置目标远程分支？
dlgSgPushToRemoteResetTargetBranches.tle=推送到
dlgSgPushTrackingConfigureSingle.btn"Configure"=配置
dlgSgPushTrackingConfigureSingle.btn"Skip"=跳过
dlgSgPushTrackingConfigureSingle.fur=对于当前分支跟踪 \(其对应的远程分支\) 尚未配置。配置跟踪将使本地分支与远程分支保持同步。
dlgSgPushTrackingConfigureSingle.hdl%1=是否要为 “$1” 分支配置跟踪？
dlgSgPushTrackingConfigureSingle.tle=推送
dlgSgRebase.btn"Branches"=分支
dlgSgRebase.btn"Rebase HEAD to"=将 HEAD 变基至
dlgSgRebase.hdl=将 HEAD 变基至
dlgSgRebase.inf=选择应变基 HEAD 的提交。
dlgSgRebase.tle=变基
dlgSgRebaseConfirmUnreachable.btn"Rebase"=变基
dlgSgRebaseConfirmUnreachable.fur=You only might be able to access this commit using the 'Recyclable Commits' option of the Branches view.
dlgSgRebaseConfirmUnreachable.hdl%1=该提交 $1 将会被引用变为不可访问.
dlgSgRebaseConfirmUnreachable.tle=变基
dlgSgRebaseContinueAfterSplittingCommit.btn"Continue"=继续
dlgSgRebaseContinueAfterSplittingCommit.fur%1=提交 $1 的拆分仍在进行中，并且已应用此提交的所有变更。
dlgSgRebaseContinueAfterSplittingCommit.hdl=拆分提交后是否继续？
dlgSgRebaseContinueAfterSplittingCommit.tle=变基
dlgSgRebaseContinueConfirm.btn"Continue Rebase"=继续变基
dlgSgRebaseContinueConfirm.fur=在解决了所有冲突后继续执行变基操作。
dlgSgRebaseContinueConfirm.hdl=您想继续变基吗？
dlgSgRebaseContinueConfirm.tle=变基
dlgSgRebaseContinueNothingToCommitContinue.btn"Continue Rebase"=继续变基
dlgSgRebaseContinueNothingToCommitContinue.fur=仓库处于变基状态，但没有提交任何内容，因此您可以继续使用变基。
dlgSgRebaseContinueNothingToCommitContinue.hdl=您想继续变基吗？
dlgSgRebaseContinueNothingToCommitContinue.tle=变基
dlgSgRebaseContinueNothingToCommitSkip.btn"Skip Commit"=跳过提交
dlgSgRebaseContinueNothingToCommitSkip.fur=仓库处于变基状态，但没有提交任何内容，因此您可以跳过此重新提交的提交。
dlgSgRebaseContinueNothingToCommitSkip.hdl=您想跳过这个变基提交吗？
dlgSgRebaseContinueNothingToCommitSkip.tle=变基
dlgSgRebaseContinuePreserveUntrackedFiles.btn"Commit"=提交
dlgSgRebaseContinuePreserveUntrackedFiles.btn"Preserve"=保留
dlgSgRebaseContinuePreserveUntrackedFiles.fur=您的工作区包含未跟踪的文件。 您可以选择在工作区中保留它们，也可以将它们包含在已重新提交的提交中。
dlgSgRebaseContinuePreserveUntrackedFiles.hdl=是否要保留工作区中未跟踪的文件？
dlgSgRebaseContinuePreserveUntrackedFiles.tle=变基
dlgSgRebaseContinueWithoutApplyingAllChanges.btn"Continue Anyway"=总是继续
dlgSgRebaseContinueWithoutApplyingAllChanges.btn"Put Changes into Index"=将变更放入索引
dlgSgRebaseContinueWithoutApplyingAllChanges.fur%1=提交 $1 的拆分仍在进行中，但并未应用此提交的所有变更。\n\n如果这是故意的，您可以继续。否则，您应单击 “将变更置于索引中” 并查看变更。
dlgSgRebaseContinueWithoutApplyingAllChanges.hdl=是否继续拆分提交而不应用所有变更？
dlgSgRebaseContinueWithoutApplyingAllChanges.tle=变基
dlgSgRebaseHeadToCommitConfirmBc.fur%1=这将把工作区分支 “$1” \(HEAD\) 的所有提交应用到所选提交。
dlgSgRebaseHeadToCommitConfirmBc.hdl%1=是否要将 “$1” 变基至所选提交？
dlgSgRebaseHeadToCommitConfirmBr.fur%2=这将应用从工作区分支 “$1” \(HEAD\) 到 “$2” 的所有提交。
dlgSgRebaseHeadToCommitConfirmBr.hdl%2=是否要将 “$1” 变基至 “$2”？
dlgSgRebaseHeadToCommitConfirm(Br|Bc|Hr|Hc).btn"Rebase HEAD to"=将 HEAD 变基至
dlgSgRebaseHeadToCommitConfirm(Br|Bc|Hr|Hc).btn"Rebase Interactively"=以交互方式变基
dlgSgRebaseHeadToCommitConfirm(Br|Bc|Hr|Hc).tle=将 HEAD 变基至选定的提交
dlgSgRebaseInteractive.btn"Auto-Squash"=自动压缩
dlgSgRebaseInteractive.btn"Edit Message"=编辑消息
dlgSgRebaseInteractive.btn"Edit"=编辑
dlgSgRebaseInteractive.btn"Move Down"=下移
dlgSgRebaseInteractive.btn"Move Up"=上移
dlgSgRebaseInteractive.btn"Rebase"=变基
dlgSgRebaseInteractive.btn"Remove"=移除
dlgSgRebaseInteractive.btn"Squash"=压缩
dlgSgRebaseInteractive.col"IDs"=IDs
dlgSgRebaseInteractive.col"Message"=消息
dlgSgRebaseInteractive.hdl=重写历史
dlgSgRebaseInteractive.inf=您可以根据需要重新排序或取消提交。
dlgSgRebaseInteractive.mni"Neighboring Commits"=相邻提交
dlgSgRebaseInteractive.mni"To Bottom Commit"=转到底部提交
dlgSgRebaseInteractive.mni"To Top Commit"=转到顶部提交
dlgSgRebaseInteractive.tle=交互式变基
dlgSgRebaseInteractiveInitialCommitNotSupported.fur=你需要选择当前分支历史中想要被修改的第1个提交. 在此提交与 HEAD 中间的提交必须是1个父系.
dlgSgRebaseInteractiveInitialCommitNotSupported.hdl=交互式变基不支持变更初始提交.
dlgSgRebaseInteractiveInitialCommitNotSupported.tle=交互式变基
dlgSgRebaseInteractiveMessage.edt"Commit Message"=提交消息
dlgSgRebaseInteractiveMessage.hdl=编辑提交消息
dlgSgRebaseInteractiveMessage.inf=提供新的提交消息.
dlgSgRebaseInteractiveMessage.tle=编辑消息
dlgSgRebaseInteractiveRemoveCommit.btn"Remove"=删除
dlgSgRebaseInteractiveRemoveCommit.fur=再次恢复提交可能变得困难或不可能。
dlgSgRebaseInteractiveRemoveCommit.hdl%1=您确定要删除所选的提交 $1 吗？
dlgSgRebaseInteractiveRemoveCommit.tle=删除提交
dlgSgRebaseTagCommit.btn"Add Tag"=创建标签
dlgSgRebaseTagCommit.btn"Skip Tag"=跳过标签
dlgSgRebaseTagCommit.fur=在变基之后，剩余的提交将不再可用。
dlgSgRebaseTagCommit.hdl%1=应该标记提交 $1 吗？
dlgSgRebaseTagCommit.tle=变基
dlgSgRebasingAbortConfirm.btn"Abort Rebase"=中止变基
dlgSgRebasingAbortConfirm.fur=您的工作区处于变基状态。你可以放弃变基; 如果您只想跳过当前的补丁，请使用 分支 \| 变基 \| 将 HEAD 变基至。\n\n中止将清除任何本地修改 \(通过调用 “git reset --hard”\)！
dlgSgRebasingAbortConfirm.hdl=你想要中止变基吗?
dlgSgRebasingAbortConfirm.tle=变基
dlgSgRecursiveStage.btn"Stage"=暂存
dlgSgRecursiveStage.chk"Don't show again"=不再显示
dlgSgRecursiveStage.hdl=保存索引中的工作区变更以供以后提交
dlgSgRecursiveStage.inf=将选中的文件暂存到索引
dlgSgRecursiveStage.mni"Deselect All"=取消全选
dlgSgRecursiveStage.mni"Select All"=全选
dlgSgRecursiveStage.mni"Toggle"=切换
dlgSgRecursiveStage.tle=暂存
dlgSgRecursiveUnstage.btn"Unstage"=取消暂存
dlgSgRecursiveUnstage.chk"Don't show again"=不再显示
dlgSgRecursiveUnstage.hdl=将暂存变更从索引还原到工作区
dlgSgRecursiveUnstage.inf=从索引中选择要取消暂存的文件。
dlgSgRecursiveUnstage.tle=取消暂存
dlgSgRecursive(Stage|Unstage).col"Directory"=目录
dlgSgRecursive(Stage|Unstage).col"Name"=名称
dlgSgRemoteDeleteConfirm.btn"Delete"=删除
dlgSgRemoteDeleteConfirm.fur=这只会删除到远程仓库的链接。
dlgSgRemoteDeleteConfirm.hdl%1=是否要删除远程仓库 “$1”？
dlgSgRemoteDeleteConfirm.tle=删除远程仓库
dlgSgRemoteFetchMore.btn"Fetch"=获取
dlgSgRemoteFetchMore.col"Branch"=分支
dlgSgRemoteFetchMore.hdl=获取远程分支
dlgSgRemoteFetchMore.inf=选择要从远程仓库获取的分支。
dlgSgRemoteFetchMore.tle=获取更多
dlgSgRemoteFetchMoreNoMoreBranches.fur=远程仓库中存在的所有分支也都已在本地存在。
dlgSgRemoteFetchMoreNoMoreBranches.hdl=没有更多的远程分支。
dlgSgRemoteFetchMoreNoMoreBranches.tle=获取更多
dlgSgRemoteProperties.chk"Perform background Poll or Fetch"=执行后台轮询或获取
dlgSgRemoteProperties.edt"URL or Path"=URL 或路径
dlgSgRemoteProperties.hdl=配置远程属性
dlgSgRemoteProperties.inf=更改远程服务器的 URL 和其他属性。
dlgSgRemoteProperties.tle=远程属性
dlgSgRemoteSelect.edt"Remote"=远程
dlgSgRemoteSelect.hdl=初始化远程审阅数据库
dlgSgRemoteSelect.inf=选择要初始化审阅数据库的远程仓库。
dlgSgRemoteSelect.tle=初始化远程
dlgSgRemoteSetDepth.btn"Set Depth"=设置深度
dlgSgRemoteSetDepth.edt"Depth"=深度
dlgSgRemoteSetDepth.hdl=设置仓库深度
dlgSgRemoteSetDepth.inf=使用大数 \(例如 100000\) 来设置无限深度。
dlgSgRemoteSetDepth.tle=设置深度
dlgSgRemotesAdd.btn"Add"=添加
dlgSgRemotesAdd.chk"Verify repository connection"=验证仓库连接
dlgSgRemotesAdd.edt"Name"=名称
dlgSgRemotesAdd.edt"URL or Path"=URL 或路径
dlgSgRemotesAdd.hdl=添加远程仓库
dlgSgRemotesAdd.inf=输入远程仓库的 URL 和短名称。
dlgSgRemotesAdd.mni"Add Hosting Provider"=添加主机提供商
dlgSgRemotesAdd.mni"Select Local Repository"=选择本地仓库
dlgSgRemotesAdd.tle=添加远程仓库
dlgSgRemotesNoRemoteDetected.fur%1=要执行该操作，$1 仓库配置必须包含一个唯一确定的远程地址.
dlgSgRemotesNoRemoteDetected.hdl=未检测到远程.
dlgSgRemotesNoRemoteDetected.tle=推送到
dlgSgRemove.btn"Remove"=移除
dlgSgRemove.chk"Delete local files"=删除本地文件
dlgSgRemove.col"Directory"=目录
dlgSgRemove.col"Name"=名称
dlgSgRemove.hdl=从仓库中删除文件
dlgSgRemove.inf=选择要从仓库或工作区中删除的文件 \(停止\跟踪\)。
dlgSgRemove.tle=移除
dlgSgRenameBranch.btn"Rename"=重命名
dlgSgRenameBranch.edt"Name"=名称
dlgSgRenameBranch.hdl=重命名分支
dlgSgRenameBranch.inf%1=输入分支 “$1” 的新名称。
dlgSgRenameBranch.tle=重命名
dlgSgRenameFile.btn"Rename"=重命名
dlgSgRenameFile.edt"Path"=路径
dlgSgRenameFile.hdl=重命名文件
dlgSgRenameFile.inf=输入文件的新路径和名称。
dlgSgRenameFile.tle=重命名
dlgSgRenameRemote.btn"Rename"=重命名
dlgSgRenameRemote.edt"Name"=名称
dlgSgRenameRemote.hdl=远程仓库重命名
dlgSgRenameRemote.inf=为选择的远程提供新的名称
dlgSgRenameRemote.tle=远程仓库重命名
dlgSgRenameRepository.btn"Rename"=重命名
dlgSgRenameRepository.edt"Name"=名称
dlgSgRenameRepository.hdl=重命名仓库
dlgSgRenameRepository.inf=为仓库提供新的名称。仓库的目录不会被重命名。
dlgSgRenameRepository.tle=重命名
dlgSgRepositoriesSearch.btn"Start Search"=开始搜索
dlgSgRepositoriesSearch.col"Path"=路径
dlgSgRepositoriesSearch.edt"Found repository \(selected ones will be remembered\)"=\
 找到仓库 \(将记住选定的仓库\)
dlgSgRepositoriesSearch.edt"Search In"=搜索中
dlgSgRepositoriesSearch.hdl=搜索现有本地仓库
dlgSgRepositoriesSearch.inf=选择应开始搜索的根目录，然后单击 “开始搜索” 。
dlgSgRepositoriesSearch.mni"Deselect All"=取消全选
dlgSgRepositoriesSearch.mni"Path"=路径
dlgSgRepositoriesSearch.mni"Select All"=全选
dlgSgRepositoriesSearch.mni"Toggle"=切换
dlgSgRepositoriesSearch.tle=搜索仓库
dlgSgRepositoryAddGroup.btn"Add"=创建
dlgSgRepositoryAddGroup.edt"Group Name"=分组名字
dlgSgRepositoryAddGroup.hdl=输入分组名称
dlgSgRepositoryAddGroup.inf=创建组后，您可以在其中移动仓库。
dlgSgRepositoryAddGroup.tle=创建分组
dlgSgRepositoryClose.btn"Force Close"=强制关闭
dlgSgRepositoryClose.fur=请注意，当前运行的 Git 进程可能不会被中断。
dlgSgRepositoryClose.hdl=你真的想现在关闭吗？
dlgSgRepositoryClose.tle=关闭
dlgSgRepositoryFrameCloseWithoutPush.btn"Close Now"=立即关闭
dlgSgRepositoryFrameCloseWithoutPush.chk=不再显示
dlgSgRepositoryFrameCloseWithoutPush.fur=你有可推送的提交。也许你想在关闭这个窗口之前推它们。
dlgSgRepositoryFrameCloseWithoutPush.hdl=你确定在没有推送提交的情况下关闭吗？
dlgSgRepositoryFrameCloseWithoutPush.tle=关闭
dlgSgRepositoryOpen.btn"Remove"=删除
dlgSgRepositoryOpen.fur=如果重新定位，请将其删除并添加其新位置。
dlgSgRepositoryOpen.hdl%1=你想删除丢失的仓库 '$1' 吗？
dlgSgRepositoryOpen.tle=仓库打开
dlgSgRepositoryRemoveMultiGroup.fur=已删除组中的仓库将从该组中移出。
dlgSgRepositoryRemoveMultiGroup.hdl%1=您确定要删除 $1 组吗？
dlgSgRepositoryRemoveMultiRepo.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。
dlgSgRepositoryRemoveMultiRepo.hdl%1=您确定要删除 $1 仓库吗？
dlgSgRepositoryRemoveMultiRepoMultiGroup.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。已删除组中的仓库将移出组。
dlgSgRepositoryRemoveMultiRepoMultiGroup.hdl%2=您确定要删除 $1 仓库和 $2 组吗？
dlgSgRepositoryRemoveMultiRepoSingleGroup.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。已删除组中的仓库将移出组。
dlgSgRepositoryRemoveMultiRepoSingleGroup.hdl%2=您确定要删除 $1 仓库和组 “$2” 吗？
dlgSgRepositoryRemoveSingleGroup.fur=已删除组中的仓库将移出组。
dlgSgRepositoryRemoveSingleGroup.hdl%1=您确定要删除 “$1” 组吗？
dlgSgRepositoryRemoveSingleRepo.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。
dlgSgRepositoryRemoveSingleRepo.hdl%1=您确定要删除 $1 的仓库吗？
dlgSgRepositoryRemoveSingleRepoMultiGroup.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。已删除组中的仓库将移出组。
dlgSgRepositoryRemoveSingleRepoMultiGroup.hdl%2=您确定要删除仓库 “$1” 和 $2 组吗？
dlgSgRepositoryRemoveSingleRepoSingleGroup.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。已删除组中的仓库将移出组。
dlgSgRepositoryRemoveSingleRepoSingleGroup.hdl%2=您确定要删除仓库 “$1” 和组 “$2” 吗？
dlgSgRepositorySettings.chk"Always fetch new commits, tags and branches from submodule"=\
 始终从子模块中获取新的提交，标签和分支
dlgSgRepositorySettings.chk"Initialize new submodules"=初始化新的子模块
dlgSgRepositorySettings.chk"Prune obsolete remote tracked branches"=删除过时的远程跟踪分支
dlgSgRepositorySettings.chk"Remember as default"=记住默认
dlgSgRepositorySettings.chk"Sign all commits"=签名所有提交
dlgSgRepositorySettings.chk"Update registered submodules"=更新已注册的子模块
dlgSgRepositorySettings.edt"Email"=电子邮箱
dlgSgRepositorySettings.edt"GPG Program"=GPG 程序
dlgSgRepositorySettings.edt"Name"=用户名
dlgSgRepositorySettings.edt"Signing Key"=签名密钥
dlgSgRepositorySettings.edt"Submodule handling\*"=子模块处理\*
dlgSgRepositorySettings.edt"Text File Encoding"=文本编码
dlgSgRepositorySettings.err"Please enter a valid, comma-separated list of regular expressions."=\
 请输入有效的、以逗号分隔的正则表达式列表。
dlgSgRepositorySettings.hdl=编辑有效的仓库设置
dlgSgRepositorySettings.inf=在这里，您可以查看和编辑用户配置文件和仓库的有效 Git 设置。要将选项保存为用户设置，请选择 “记住默认” 。
dlgSgRepositorySettings.lbl"\* if repository commit references non-pushed submodule commit"=\
 \* if repository commit references non-pushed submodule commit
dlgSgRepositorySettings.tab"Encoding"=编码
dlgSgRepositorySettings.tab"Pull"=拉取
dlgSgRepositorySettings.tab"Push"=推送
dlgSgRepositorySettings.tab"Signing"=签名
dlgSgRepositorySettings.tab"User & Encoding"=用户和编码
dlgSgRepositorySettings.tab"User"=用户
dlgSgRepositorySettings.tle=仓库设置
dlgSgRepositorySettings.wrn"The entered email address does not look like a valid one."=\
 The entered email address does not look like a valid one.
dlgSgRepositorySettings.wrn"The name should not contain an email address."=\
 该名称不应包含电子邮件地址。
dlgSgRepositorySettings.wrn"Without setting your name, you won't be able to commit."=\
 Without setting your name, you won't be able to commit.
dlgSgResetAdv.btn"Reset"=重置
dlgSgResetAdv.chk"Thoroughly fix line endings according to .gitattributes"=\
 根据 .gitattributes 彻底修复行尾序列
dlgSgResetAdv.chk"Thoroughly fix line-endings according to .gitattributes"=\
 根据 .gitattributes 彻底修复行尾序列
dlgSgResetAdv.hdl%1=重置提交 $1
dlgSgResetAdv.inf=将当前分支 HEAD 重置为所选提交，并可选择更新索引和工作区。
dlgSgResetAdv.lbl"Current staged and local changes will be lost!"=\
 Current staged and local changes will be lost!
dlgSgResetAdv.lbl"Current staged changes will be lost!"=\
 Current staged changes will be lost!
dlgSgResetAdv.lbl"Similar to 'hard'. If a file to be replaced has working tree changes, the reset is aborted."=\
 Similar to 'hard'. If a file to be replaced has working tree changes, the reset is aborted.
dlgSgResetAdv.lbl"Similar to 'hard'. If a file to be replaced has working tree or Index changes, the reset is aborted."=\
 Similar to 'hard'. If a file to be replaced has working tree or Index changes, the reset is aborted.
dlgSgResetAdv.lbl"The Index will show all changes between the previous HEAD and the selected commit."=\
 The Index will show all changes between the previous HEAD and the selected commit.
dlgSgResetAdv.rbt"Don't touch the Index nor the working tree - 'soft'"=\
 不要变更索引或工作区 - “--soft”
dlgSgResetAdv.rbt"Reset the Index and the working tree - 'hard'"=\
 重置索引和工作区 - “--hard”
dlgSgResetAdv.rbt"Reset the Index and the working tree, skipping modified files - 'keep'"=\
 重置索引和工作区，跳过修改过的文件 - “--keep”
dlgSgResetAdv.rbt"Reset the Index and the working tree, skipping working tree modified files - 'merge'"=\
 重置索引和工作区，跳过工作区修改的文件 - “--merge”
dlgSgResetAdv.rbt"Reset the Index but not the working tree - 'mixed'"=\
 重置索引，但不重置工作区 - “--mixed”
dlgSgResetAdv.tle=重置
dlgSgResetConfirm.btn"Reset"=重置
dlgSgResetConfirm.fur=当前暂存和本地变更将丢失！
dlgSgResetConfirm.hdl%1=您确定要将 HEAD 重置为提交 $1 吗？
dlgSgResetConfirm.tle=重置
dlgSgResolve.btn"Resolve"=解决
dlgSgResolve.chk"Stage file \(reset conflict state\)"=暂存文件 \(重置冲突状态\)
dlgSgResolve.edt"Content"=内容
dlgSgResolve.hdl=解决冲突
dlgSgResolve.inf=选择要用于已解决的文件的内容。
dlgSgResolve.rbt"Leave as is"=保持不变
dlgSgResolve.rbt"Open Conflict Solver"=打开冲突解决工具
dlgSgResolve.rbt"Set to $1 \(\"ours\", $2\)"=设置为 $1 \(“我们的”，$2 \)
dlgSgResolve.rbt"Set to $1 \(\"theirs\", $2\)"=设置为 $1 \(“他们的”，$2 \)
dlgSgResolve.rbt"Set to rebase target \(\"theirs\", $1\)"=\
 设置为变基目标 \(“他们的”，$1\)
dlgSgResolve.rbt"Set to rebased branch '$1' \(\"ours\", $2\)"=\
 设置为变基分支 “$1” \(“我们的”，$2\)
dlgSgResolve.tle=解决
dlgSgResolveManuallyModifiedSingle.btn"Overwrite"=覆盖
dlgSgResolveManuallyModifiedSingle.fur%1=$1 似乎包含手动冲突解决方案。如果继续，它们将会丢失。
dlgSgResolveManuallyModifiedSingle.hdl=您确定要覆盖手动冲突解决？
dlgSgResolveManuallyModifiedSingle.tle=解决
dlgSgResolveSubmodule.btn"Resolve"=解决
dlgSgResolveSubmodule.hdl=解决冲突
dlgSgResolveSubmodule.inf=选择要解决的子模块提交。
dlgSgResolveSubmodule.rbt"Check out and set submodule pointer to 'theirs' version"=\
 检出并将子模块指针设置为 “他们的” 版本
dlgSgResolveSubmodule.rbt"Leave submodule pointer as is"=保持子模块指针不变
dlgSgResolveSubmodule.tle=解决
dlgSgRevealCommitLocalOrTracked.btn"Reveal Local"=显示本地
dlgSgRevealCommitLocalOrTracked.btn"Reveal Tracked"=显示跟踪
dlgSgRevealCommitLocalOrTracked.chk=始终显示当地分支
dlgSgRevealCommitLocalOrTracked.fur%2=选择是否显示 “$1” 或 “$2” 。
dlgSgRevealCommitLocalOrTracked.hdl=是否要显示本地分支或跟踪分支？
dlgSgRevealCommitLocalOrTracked.tle=显示提交
dlgSgRevertAndCommitConfirmSingle.btn"Revert && Commit"=还原并提交
dlgSgRevertAndCommitConfirmSingle.btn"Revert"=还原
dlgSgRevertAndCommitConfirmSingle.fur=这将撤消所选提交引入的变更。
dlgSgRevertAndCommitConfirmSingle.hdl=是否要还原所选提交？
dlgSgRevertAndCommitConfirmSingle.tle=还原
dlgSgRevertConfigurationFile.btn"Revert"=还原
dlgSgRevertConfigurationFile.fur=只有这些文件的变更才会被还原 \(不提交\)。
dlgSgRevertConfigurationFile.hdl"Do you want to revert changes of '$1'?"=\
 您确定要还原 '$1' 的变更？
dlgSgRevertConfigurationFile.tle=还原
dlgSgRevertInProgress.fur=您必须先完成还原，然后才能继续。 要完成 “还原” 使用 “提交”，要中止使用 “丢弃”。
dlgSgRevertInProgress.hdl=目前还有还原正在进行中。
dlgSgRevertInProgress.tle=还原
dlgSgRevertNotAllConflictsResolved.chk=不再显示
dlgSgRevertNotAllConflictsResolved.fur=您可能需要在继续之前解决冲突。
dlgSgRevertNotAllConflictsResolved.hdl=由于冲突而还原失败。
dlgSgRevertNotAllConflictsResolved.tle=还原
dlgSgReviewCommentAdd.btn"Add"=创建
dlgSgReviewCommentAdd.hdl=创建注释
dlgSgReviewCommentAdd.tle=创建注释
dlgSgReviewCommentEdit.btn"Edit"=编辑
dlgSgReviewCommentEdit.hdl=编辑注释
dlgSgReviewCommentEdit.tle=编辑注释
dlgSgReviewCommentReply.btn"Reply"=回复
dlgSgReviewCommentReply.hdl=回复所选注释
dlgSgReviewCommentReply.tle=回复注释
dlgSgReviewComment(Add|Edit|Reply).edt"Text"=文本
dlgSgReviewComment(Add|Edit|Reply).inf=输入注释的文本。
dlgSgReviewConfigureDisposeDatabase.btn"Dispose"=配置
dlgSgReviewConfigureDisposeDatabase.fur=这将禁用审阅系统，并且未推送的本地数据将丢失。
dlgSgReviewConfigureDisposeDatabase.hdl=您真的想要处理所有本地注释数据吗？
dlgSgReviewConfigureDisposeDatabase.tle=配置数据库
dlgSgReviewConfigureForGitHub.btn"Continue"=继续
dlgSgReviewConfigureForGitHub.fur=此仓库连接到 GitHub 服务器。GitHub 有自己的审阅概念，比如提交审阅和拉取请求。因此，除了 GitHub 的现有功能之外，您可能不希望拥有 SmartGit 的审阅数据库。
dlgSgReviewConfigureForGitHub.hdl=您真的想为您的 GitHub 仓库配置 SmartGit 的审阅数据库吗？
dlgSgReviewConfigureForGitHub.tle=配置审阅系统
dlgSgReviewConfigureIntializeNew.btn"Initialize"=初始化
dlgSgReviewConfigureIntializeNew.fur=这将在当前仓库中创建新的审阅数据库，稍后可能会将其推送到其他远程位置。
dlgSgReviewConfigureIntializeNew.hdl=是否要初始化新的审阅数据库？
dlgSgReviewConfigureIntializeNew.tle=配置审阅系统
dlgSgReviewConfigureWhat.btn"Dispose Database"=配置数据库
dlgSgReviewConfigureWhat.btn"Edit Users"=编辑用户
dlgSgReviewConfigureWhat.btn"Initialize a Remote"=初始化远程
dlgSgReviewConfigureWhat.fur=用户数据库允许定义别名 \(例如 @mike\)，使得在审阅注释中更容易解决队友问题。
dlgSgReviewConfigureWhat.hdl=选择要配置的内容。
dlgSgReviewConfigureWhat.tle=配置审核数据库
dlgSgReviewPullRequestClose.edt"Comment"=注释
dlgSgReviewPullRequestClose.hdl=关闭拉取请求
dlgSgReviewPullRequestClose.inf=输入关闭拉取请求时将记录的注释。
dlgSgReviewPullRequestClose.tle=关闭拉取请求
dlgSgReviewPullRequestCreate.btn"Create"=创建
dlgSgReviewPullRequestCreate.edt"Assignees"=申请人
dlgSgReviewPullRequestCreate.edt"Message"=消息
dlgSgReviewPullRequestCreate.err"Unknown user '$1'."=未知用户 “$1”。
dlgSgReviewPullRequestCreate.hdl=创建拉取请求
dlgSgReviewPullRequestCreate.inf=拉取请求建议将一个分支集成到另一个分支中。
dlgSgReviewPullRequestCreate.lbl"The message will be displayed for the pull request node and will be the default commit message when integrating the pull request."=\
 将为拉取请求节点显示该消息，并且在集成拉取请求时将是默认提交消息。
dlgSgReviewPullRequestCreate.lbl"The pull request will be highlighted to those users which are listed as assignees."=\
 拉取请求将高亮显示给列为申请人的用户。
dlgSgReviewPullRequestCreate.tle=创建拉取请求
dlgSgReviewPullRequestState.btn"Assign"=分配
dlgSgReviewPullRequestState.edt"Assignees"=申请人
dlgSgReviewPullRequestState.edt"Comment"=注释
dlgSgReviewPullRequestState.err"Unknown user '$1'."=未知用户 “$1”。
dlgSgReviewPullRequestState.hdl=分配拉取请求
dlgSgReviewPullRequestState.inf=输入应将拉取请求分配给的用户 \(s\)。
dlgSgReviewPullRequestState.tle=分配
dlgSgReviewUserAddEdit.edt"Aliases"=别名
dlgSgReviewUserAddEdit.edt"Contact URI"=联系 URI
dlgSgReviewUserAddEdit.edt"Email"=电子邮箱
dlgSgReviewUserAddEdit.edt"Name"=用户名
dlgSgReviewUserAddEdit.err"Email address is not valid."=电子邮件地址无效。
dlgSgReviewUserAddEdit.err"Enter at least one alias."=输入至少1个别名。
dlgSgReviewUserAddEdit.hdl=编辑用户
dlgSgReviewUserAddEdit.inf=输入用户的姓名和电子邮件地址 \(用于 Git\)，1个或多个空格或逗号分隔的别名和可选的联系人详细信息。
dlgSgReviewUserAddEdit.lbl"Aliases have to be alphanumeric and can be used in comments, like '@bob please check'."=\
 别名必须是字母数字，并且可以在注释中使用，例如 “@bob 请检查”。
dlgSgReviewUserAddEdit.lbl"Contact URIs are the primary way to contact users through SmartGit, e.g. 'mailto:bob@office.com' or 'skype:bob?chat'."=\
 联系 URI 是通过 SmartGit 与用户联系的主要方式，例如 “mailto:bob@office.com” 或 “skype:bob?chat”。
dlgSgReviewUserAddEdit.tle=编辑
dlgSgReviewUsersEdit.btn"Add"=创建
dlgSgReviewUsersEdit.btn"Edit"=编辑
dlgSgReviewUsersEdit.btn"Import"=导入
dlgSgReviewUsersEdit.btn"Remove"=删除
dlgSgReviewUsersEdit.col"Aliases"=别名
dlgSgReviewUsersEdit.col"Email"=电子邮箱
dlgSgReviewUsersEdit.col"Name"=名称
dlgSgReviewUsersEdit.hdl=配置审阅数据库用户
dlgSgReviewUsersEdit.inf=用户可以在注释文本中使用别名，并且可以选择联系人详细信息。
dlgSgReviewUsersEdit.tle=配置用户
dlgSgSelectBranch.edt"Auxiliary Branch"=辅助分支
dlgSgSelectBranch.edt"Tracked Branch"=跟踪分支
dlgSgSelectBranch.hdl"Select tracked branch"=选择跟踪分支
dlgSgSelectBranch.inf"Select the branch which should be tracked by '$1'."=\
 选择应由 “$1” 跟踪的分支。
dlgSgSelectBranch.inf"Select which auxiliary branch should be shown in addition to the current branch."=\
 选择除当前分支外还应显示的辅助分支。
dlgSgSelectBranch.tle=设置跟踪分支
dlgSgSetup.btn"Configure Proxy"=设置代理
dlgSgSetup.btn"Exit"=退出
dlgSgSetup.chk"Automatically send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后自动发送 “崩溃追踪”
dlgSgSetup.chk"I understand and agree to all terms and conditions of the"=\
 我理解并同意所有条款和条件
dlgSgSetup.chk"Register existing license"=注册现有许可证
dlgSgSetup.chk"Send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后自动发送 “崩溃追踪”
dlgSgSetup.chk"Send usage statistics"=发送使用量统计
dlgSgSetup.chk"Use gravatar.com to show images for the users"=\
 使用 gravatar.com 为用户显示图像
dlgSgSetup.edt"Email"=电子邮箱
dlgSgSetup.edt"Git Executable"=Git 可执行文件
dlgSgSetup.edt"Hg Executable"=Hg 可执行文件
dlgSgSetup.edt"License File"=许可证文件
dlgSgSetup.edt"Repository search"=仓库搜索
dlgSgSetup.edt"User Name"=用户名
dlgSgSetup.inf"Decide what SmartGit window you prefer. You can change this option later in the preferences."=\
 决定您喜欢的 SmartGit 窗口。您可以稍后在偏好设置中更改此选项。
dlgSgSetup.inf"If you are using SSH to connect to other Git repositories, select what SSH client to use. You can change it later in the Preferences."=\
 如果您使用 SSH 连接到其他 Git 仓库，请选择要使用的 SSH 客户端。 您可以稍后在偏好设置中进行更改。
dlgSgSetup.inf"Please review the following privacy options. You can change them later in the preferences."=\
 请查看以下隐私选项。您可以稍后在偏好设置中更改它们。
dlgSgSetup.inf"Please wait a few moments while searching for a Git installation."=\
 在搜索 Git 或 Hg 安装时，请稍等片刻。
dlgSgSetup.inf"SmartGit requires compatible Git installations on your system. Please specify the paths to your 'git' executable."=\
 SmartGit 要求在您的系统上安装兼容的 Git。请指定 'git' 可执行文档的路径。
dlgSgSetup.inf"User name and email will be stored as part of your commits. Here you can configure the default values which are stored in .gitconfig."=\
 用户名和电子邮件将作为提交的一部分存储。 您可以在此处配置并存储在 .gitconfig。
dlgSgSetup.inf"Welcome to SmartGit! Please confirm that you are accepting the license agreement."=\
 欢迎来到 SmartGit！请确认您正在接受许可协议。
dlgSgSetup.lbl"Please help to improve SmartGit's quality by automatically sending 'crash footprints' which do not contain any sensitive information. You can change this option later in the preferences.\n\nA 'crash footprint' contains details about your machine \(e.g. version of operating system\), SmartGit's version/build number, the JVM state and where the internal error occurred.\n\nIt contains NO POTENTIALLY SENSITIVE INFORMATION like user names, email addresses, file contents, file paths or server names."=\
 请通过自动发送不包含任何敏感信息的 “崩溃追踪” 来帮助提高 SmartGit 的质量。 您可以稍后在偏好设置中更改此选项。\n\n崩溃追踪包含有关您的计算机的详细信息 \(例如，操作系统的版本\)，SmartGit 的版本/内部版本号，JVM 状态以及发生内部错误的位置。 \n\n它不包含任何潜在的敏感信息，如用户名，电子邮件地址，文件内容，文件路径或服务器名称。
dlgSgSetup.lbl"You confirm that you will use SmartGit solely for non-commercial purposes."=\
 您确认将 SmartGit 仅用于非商业目的。
dlgSgSetup.lbl"You have purchased a SmartGit license and are eligible to use SmartGit for both commercial and non-commercial purposes."=\
 您已购买 SmartGit 许可证，并且有资格将 SmartGit 用于商业和非商业用途。
dlgSgSetup.lbl"You may try SmartGit free of charge for 30 days."=\
 您可以免费试用 SmartGit 30天。
dlgSgSetup.rbt"Commits \(Log History\)"=日志历史
dlgSgSetup.rbt"Free SmartGit evaluation for commercial use"=\
 免费的 SmartGit 评估用于商业用途
dlgSgSetup.rbt"Log Graph \(commit oriented\)"=日志图 \(面向提交\)
dlgSgSetup.rbt"Non-commercial use only \(most features, no support\)"=\
 仅限非商业用途 \(大多数功能, 无技术支持\)
dlgSgSetup.rbt"Registered user, commercial use \(all features, support\)"=\
 注册用户，商业用途 \(所有功能, 技术支持\)
dlgSgSetup.rbt"Standard \(workflow oriented\)"=标准 \(面向工作流\)
dlgSgSetup.rbt"Undecided"=待定
dlgSgSetup.rbt"Use SmartGit as SSH client"=使用 SmartGit 作为 SSH 客户端
dlgSgSetup.rbt"Use system SSH client"=使用系统 SSH 客户端
dlgSgSetup.rbt"Working tree \(file oriented\)"=工作区 \(面向文件\)
dlgSgSetup.tle=设置 SmartGit
dlgSgShowLocalChanges.btn"Compare"=比较
dlgSgShowLocalChanges.hdl%1=在索引和工作区中修改了文件 $1
dlgSgShowLocalChanges.inf=选择要比较的文件状态。
dlgSgShowLocalChanges.rbt"HEAD vs. Index"=HEAD 与索引
dlgSgShowLocalChanges.rbt"HEAD vs. Working Tree"=HEAD 与工作区
dlgSgShowLocalChanges.rbt"Index vs. Working Tree"=索引与工作区
dlgSgShowLocalChanges.tle=显示变更
dlgSgSplitOffFiles.btn"JIRA"=JIRA
dlgSgSplitOffFiles.btn"Split Off"=拆分
dlgSgSplitOffFiles.edt"Commit Message"=提交信息
dlgSgSplitOffFiles.hdl=将文件移动到第二次提交
dlgSgSplitOffFiles.inf=为第二个提交提供消息，该消息应包含所选文档中的变更。
dlgSgSplitOffFiles.tle=拆分文件
dlgSgSplitOffFilesEmptyCommit.fur=通过拆分所有文件，结果提交将变为空
dlgSgSplitOffFilesEmptyCommit.hdl=不能从1个提交中拆分所有文件
dlgSgSplitOffFilesEmptyCommit.tle=提交
dlgSgSshCredentials.btn"Login"=登录
dlgSgSshCredentials.chk"Store passphrase"=存储密码
dlgSgSshCredentials.chk"Store password"=存储密码
dlgSgSshCredentials.edt"Authentication Type"=验证类型
dlgSgSshCredentials.edt"Passphrase"=密码
dlgSgSshCredentials.edt"Password"=密码
dlgSgSshCredentials.edt"Private Key File"=私钥文件
dlgSgSshCredentials.hdl=SSH 凭据
dlgSgSshCredentials.inf=提供用于以 “root” 身份向 SSH 服务器 “git” 进行身份验证的凭据。
dlgSgSshCredentials.rbt"Password"=密码
dlgSgSshCredentials.rbt"Private Key"=私钥
dlgSgSshCredentials.tle=SSH 身份验证
dlgSgSshCredentials.wrn"$1"=$1
dlgSgStageConflict.btn"Stage Anyway"=总是暂存
dlgSgStageConflict.fur=该文件包含冲突标记，这些标记指示您尚未解决所有冲突。
dlgSgStageConflict.hdl%1=$1 真的应该暂存吗？
dlgSgStageConflict.tle=暂存
dlgSgStageNoFilesFound.fur=找不到包含已修改工作区，未跟踪或丢失文件的文件。
dlgSgStageNoFilesFound.hdl=找不到可以暂存的文件。
dlgSgStageNoFilesFound.tle=暂存
dlgSgStartupExpired.btn"&Continue \($1\)"=&继续 \($1\)
dlgSgStartupExpired.btn"Continue \($1\)"=继续 \($1\)
dlgSgStartupExpired.btn"Download New Version"=下载新版本
dlgSgStartupExpired.btn"Exit"=退出
dlgSgStartupExpired.fur=请下载安装新版本.
dlgSgStartupExpired.hdl=该 beta 版本已过期.
dlgSgStartupExpired.tle=Beta 版本已过期
dlgSgStashAll.btn"+ Keep Index"=+ 保持索引
dlgSgStashAll.btn"+ Keep Working Tree"=+ 保持工作区
dlgSgStashAll.btn"Stash All"=贮藏全部
dlgSgStashAll.btn"Stash Selection"=贮藏选择
dlgSgStashAll.edt"Message"=消息
dlgSgStashAll.hdl=存储索引和工作区变更
dlgSgStashAll.inf=保存的存储可以在以后应用。默认情况下，清理索引和工作区，但您可以保留索引或两者。
dlgSgStashAll.tle=贮藏
dlgSgStashApply.btn"Apply && Drop"=应用并删除
dlgSgStashApply.btn"Apply"=应用
dlgSgStashApply.chk"Restore Index"=还原索引
dlgSgStashApply.hdl"Apply a previously saved stash"=应用以前保存的存储
dlgSgStashApply.hdl"Apply the latest saved stash"=应用最新保存的存储
dlgSgStashApply.inf=确定如何将存储应用于索引或工作区。
dlgSgStashApply.tle=应用贮藏
dlgSgStashApplyWithoutRestoringIndex.btn"Try Without Restoring Index"=尝试不还原索引
dlgSgStashApplyWithoutRestoringIndex.fur=应用修补程序时还原索引失败。
dlgSgStashApplyWithoutRestoringIndex.hdl=是否应用存储而不还原索引？
dlgSgStashApplyWithoutRestoringIndex.tle=应用贮藏
dlgSgStashOnDemandConfirmation.btn"Discard"=丢弃
dlgSgStashOnDemandConfirmation.btn"Save Stash"=贮藏
dlgSgStashOnDemandConfirmation.chk=自动贮藏
dlgSgStashOnDemandConfirmation.fur=请选择将它们保存为存储，以便以后手动重新应用或丢弃它们。
dlgSgStashOnDemandConfirmation.hdl=如何处理工作区或索引变更？
dlgSgStashOnDemandConfirmation.tle=重置
dlgSgStashOnDemandLocalChangesCantBeReapplied.fur=完成拉取操作后，您应该手动应用最新的存储，以将本地变更还原到工作区中。
dlgSgStashOnDemandLocalChangesCantBeReapplied.hdl=您的本地变更已被贮藏，但无法重新应用。
dlgSgStashOnDemandLocalChangesCantBeReapplied.tle=拉取
dlgSgStashOnDemandProceedWithoutStashing.btn"Proceed"=继续
dlgSgStashOnDemandProceedWithoutStashing.fur=由于技术原因，无法自动贮藏变更. 变更将会被丢弃!
dlgSgStashOnDemandProceedWithoutStashing.hdl=是否继续并排除贮藏?
dlgSgStashOnDemandProceedWithoutStashing.tle=重置
dlgSgStashRename.btn"Rename"=重命名
dlgSgStashRename.edt"Message"=消息
dlgSgStashRename.hdl=重命名贮藏
dlgSgStashRename.inf=输入贮藏的新消息
dlgSgStashRename.tle=重命名
dlgSgStashesDropConfirm.btn"Drop Stash"=丢弃贮藏
dlgSgStashesDropConfirm.btn"Drop Stashes"=丢弃贮藏
dlgSgStashesDropConfirm.fur=贮藏的变更将会丢失。
dlgSgStashesDropConfirm.hdl=你想丢弃选定的贮藏吗？
dlgSgStashesDropConfirm.tle=丢弃贮藏
dlgSgSubmoduleAdd.chk"Map SVN trunk, tags and branches to Git"=\
 将 SVN 主干，标签和分支映射到 Git
dlgSgSubmoduleAdd.edt"Branch"=分支
dlgSgSubmoduleAdd.edt"Local Directory"=本地目录
dlgSgSubmoduleAdd.edt"Local Path"=本地路径
dlgSgSubmoduleAdd.edt"Repository URL"=仓库 URL
dlgSgSubmoduleAdd.edt"URL"=URL
dlgSgSubmoduleAdd.inf"Provide the path where the submodule should be added relative to the outer repository root directory."=\
 提供要添加的子模块相对于外部版本库根目录的相对路径.
dlgSgSubmoduleAdd.inf"Specify the repository to clone as submodule."=\
 指定要克隆为子模块的的版本仓库.
dlgSgSubmoduleAdd.lbl"e.g. https://user@server:port/path/to/repository"=e.g. https://user@server:port/path/to/repository
dlgSgSubmoduleAdd.mni"Add Hosting Provider"=添加托管提供商
dlgSgSubmoduleAdd.rbt"Local repository"=本地仓库
dlgSgSubmoduleAdd.rbt"Remote repository"=远程仓库
dlgSgSubmoduleAdd.tle=添加子模块
dlgSgSubmoduleDeinitConfirm.btn"Deinit"=删除
dlgSgSubmoduleDeinitConfirm.fur=子模块将从工作区中跳过。 要摆脱 \(远程\) 仓库，您必须使用取消注册。
dlgSgSubmoduleDeinitConfirm.hdl%1=你想要删除子模块 '$1' 吗？
dlgSgSubmoduleDeinitConfirm.tle=删除子模块
dlgSgSubmoduleResetConfirm.btn"Reset"=重置
dlgSgSubmoduleResetConfirm.fur=将检出相应的提交，因此子模块内容将匹配已注册提交的内容。
dlgSgSubmoduleResetConfirm.hdl%1=是否要将子模块 $1 重置为仓库中注册的提交？
dlgSgSubmoduleResetConfirm.tle=重置子模块
dlgSgSubmoduleSync.btn"Synchronize"=同步
dlgSgSubmoduleSync.chk"Pull submodule repositories"=拉取子模块
dlgSgSubmoduleSync.hdl=同步所有子模块
dlgSgSubmoduleSync.inf=子模块条目将在 .git/config 文件夹中更新. 您可以稍后自定义URL或立即拉取.
dlgSgSubmoduleSync.tle=同步子模块
dlgSgSubtreeAdd.chk"Create local branch \(for advanced operations\)"=\
 创建本地分支 \(高级操作\)
dlgSgSubtreeAdd.chk"Squash subtree into single commit"=将子树压缩为单个提交
dlgSgSubtreeAdd.edt"Branch"=分支
dlgSgSubtreeAdd.edt"Local Directory"=本地目录
dlgSgSubtreeAdd.edt"Local Path"=本地路径
dlgSgSubtreeAdd.edt"Remote"=远程
dlgSgSubtreeAdd.edt"Repository URL"=仓库 URL
dlgSgSubtreeAdd.inf"Provide the path where the subtree should be added relative to the outer repository root directory."=\
 Provide the path where the subtree should be added relative to the outer repository root directory.
dlgSgSubtreeAdd.inf"Specify the repository to clone as subtree."=\
 Specify the repository to clone as subtree.
dlgSgSubtreeAdd.lbl"Local branches for subtrees will only be useful if you plan to use Subtree-Split and Subtree-Reset operations."=\
 Local branches for subtrees will only be useful if you plan to use Subtree-Split and Subtree-Reset operations.
dlgSgSubtreeAdd.lbl"e.g. https://user@server:port/path/to/repository"=e.g. https://user@server:port/path/to/repository
dlgSgSubtreeAdd.rbt"Local repository"=本地仓库
dlgSgSubtreeAdd.rbt"Remote repository"=远程仓库
dlgSgSubtreeAdd.tle=添加子树
dlgSgSvnClientCertificate.btn"Login"=登录
dlgSgSvnClientCertificate.chk"Store passphrase"=存储密码
dlgSgSvnClientCertificate.edt"Certificate"=证书
dlgSgSvnClientCertificate.edt"Passphrase"=密码
dlgSgSvnClientCertificate.hdl=客户端证书
dlgSgSvnClientCertificate.inf%1=为 SVN 仓库 “$1” 提供身份验证的客户端证书。
dlgSgSvnClientCertificate.tle=SVN 认证
dlgSgSvnClientCertificate.wrn"Authentication to the SVN repository '$1' failed with error: $2"=\
 对 SVN 仓库 “$1” 的身份验证失败，错误：$2
dlgSgSvnSslFingerprintChanged.btn"Accept"=同意
dlgSgSvnSslFingerprintChanged.btn"Reject"=拒绝
dlgSgSvnSslFingerprintChanged.edt"MD5 fingerprint"=MD5 指纹
dlgSgSvnSslFingerprintChanged.edt"SHA fingerprint"=SHA 指纹
dlgSgSvnSslFingerprintChanged.edt"Server"=服务器
dlgSgSvnSslFingerprintChanged.lbl"The server fingerprint has changed! Is the change correct?"=\
 服务器指纹已更改！更改是否正确？
dlgSgSvnSslFingerprintChanged.lbl"This might indicate a security problem! When in doubt, contact your server administrator."=\
 这可能表明存在安全问题！如果有疑问，请与服务器管理员联系。
dlgSgSvnSslFingerprintChanged.tle=SVN 身份验证
dlgSgSyncConfirm.btn"Synchronize"=同步
dlgSgSyncConfirm.chk=不再显示
dlgSgSyncConfirm.fur=首先，将推送本地变更，然后可能会拉取远程变更。比普通推送的优势在于，如果由于远程变更而推送失败，它们将被自动拉取。
dlgSgSyncConfirm.hdl=你确定要继续同步吗？
dlgSgSyncConfirm.tle=同步
dlgSgTagAdd.btn"Add Tag && Push"=创建标签并推送
dlgSgTagAdd.btn"Add Tag"=创建标签
dlgSgTagAdd.chk"GPG-sign tag"=GPG-sign 标签
dlgSgTagAdd.edt"Annotated Tag Message"=带注释的标签消息
dlgSgTagAdd.edt"Tag"=标签
dlgSgTagAdd.err"The name must not end with a slash or dot."=\
 名称不得以斜杠或点结尾。
dlgSgTagAdd.hdl=在当前 HEAD 提交创建标签
dlgSgTagAdd.inf=输入要创建的标签名称。如果输入消息，则会创建带注释的标签。
dlgSgTagAdd.tle=创建标签
dlgSgTagAddOverwrite.btn"Overwrite"=覆盖
dlgSgTagAddOverwrite.fur=单击 “取消” 以选择其他标签名称。
dlgSgTagAddOverwrite.hdl%1=标签 '$1' 已经存在。 你想覆盖吗？
dlgSgTagAddOverwrite.tle=创建标签
dlgSgTagDeleteConfirmSingle.btn"Delete"=删除
dlgSgTagDeleteConfirmSingle.chk%1=从远程 “$1” 删除
dlgSgTagDeleteConfirmSingle.fur=你将无法恢复它。
dlgSgTagDeleteConfirmSingle.hdl%1=您确定要删除 “$1” 标签吗？
dlgSgTagDeleteConfirmSingle.tle=删除
dlgSgToolAdd.edt"Keyboard Shortcut"=键盘快捷键
dlgSgToolAdd.err"Please enter a confirmation message."=请输入确认信息.
dlgSgToolAdd.err"Please enter the name for this command."=\
 请输入名称.
dlgSgToolAdd.err"Select the command which should be invoked."=\
 选择要调用的命令.
dlgSgToolAdd.err"The options 'Can be used by the Open command' and 'Show output and wait until finished' cannot both be set."=\
 The options 'Can be used by the Open command' and 'Show output and wait until finished' cannot both be set.
dlgSgToolAdd.hdl=添加外部工具
dlgSgToolAdd.tle=添加
dlgSgToolEdit.edt"Keyboard Shortcut"=键盘快捷键
dlgSgToolEdit.err"Please enter the name for this command."=\
 请输入此命令的名称。
dlgSgToolEdit.hdl=编辑外部工具
dlgSgToolEdit.tle=编辑
dlgSgTool(Add|Edit).btn"Clear"=清除
dlgSgTool(Add|Edit).chk"Can be used by the Open command"=\
 可以由 “打开” 命令使用
dlgSgTool(Add|Edit).chk"Request confirmation before invoking:"=在调用之前请求确认：
dlgSgTool(Add|Edit).chk"Show output and wait until finished"=\
 显示输出并等待完成
dlgSgTool(Add|Edit).edt"Accelerator"=快捷键
dlgSgTool(Add|Edit).edt"Applies To"=适用于
dlgSgTool(Add|Edit).edt"Arguments"=参数
dlgSgTool(Add|Edit).edt"Command"=命令
dlgSgTool(Add|Edit).edt"Handles"=控制
dlgSgTool(Add|Edit).edt"Menu Item Name"=菜单项名称
dlgSgTool(Add|Edit).inf=定义工具菜单项的名称，应执行的命令并配置其参数。使用的变量定义了可以使用工具的选择。
dlgSgTool(Add|Edit).lbl"Valid wildcards are ?\u00a0\(one arbitrary character\) and \*\u00a0\(any number of arbitrary characters\). Separate multiple patterns by comma. Example:\u00a0\*.txt,\u00a0\*.html"=\
 有效的通配符是 ?\u00a0\(一个任意字符\)和 \*\u00a0\(任意数量的任意字符\)。用逗号分隔多个模式。例如：\u00a0\*.txt，\u00a0\* .html。
dlgSgTool(Add|Edit).mni"2nd Commit ID or Ref \(optional\)"=\
 第二个提交 ID 或引用 \(可选\)
dlgSgTool(Add|Edit).mni"2nd Commit ID or Ref"=第二个提交 ID 或引用
dlgSgTool(Add|Edit).mni"Commit ID or Ref"=提交 ID 或引用
dlgSgTool(Add|Edit).mni"Configured Text File Encoding"=配置的文本文件编码
dlgSgTool(Add|Edit).mni"File or Directory Name"=文件或目录名称
dlgSgTool(Add|Edit).mni"File or Directory Path"=文件或目录路径
dlgSgTool(Add|Edit).mni"File or Directory URI"=文件或目录地址
dlgSgTool(Add|Edit).mni"Git Executable"=Git 可执行文件
dlgSgTool(Add|Edit).mni"Git Installation"=Git 安装程序
dlgSgTool(Add|Edit).mni"Hg Executable"=Hg 可执行文件
dlgSgTool(Add|Edit).mni"Hg Installation"=Hg 安装程序
dlgSgTool(Add|Edit).mni"Remote \(Push\) URL"=远程 \(推送\) 网址
dlgSgTool(Add|Edit).mni"Repository Root Path"=仓库根路径
dlgSgTool(Add|Edit).mni"Selection File"=选择文件
dlgSgTool(Add|Edit).mni"Show Directory Selection Dialog"=显示目录选择对话框
dlgSgTool(Add|Edit).mni"Show Open File Dialog"=显示打开文件对话框
dlgSgTool(Add|Edit).mni"Show Save File Dialog"=显示保存文件对话框
dlgSgTool(Add|Edit).mni"SmartGit Installation"=SmartGit 安装程序
dlgSgTool(Add|Edit).rbt"Both"=都
dlgSgTool(Add|Edit).rbt"Commits"=提交
dlgSgTool(Add|Edit).rbt"Directories"=目录
dlgSgTool(Add|Edit).rbt"Files"=文件
dlgSgTool(Add|Edit).rbt"Refs"=引用
dlgSgUndoLastCommitConfirm.btn"Undo"=撤销
dlgSgUndoLastCommitConfirm.fur"Message: $1"=消息：$1
dlgSgUndoLastCommitConfirm.fur"Undoing an already pushed commit might cause serious problems!\n\nMessage: $1"=\
 撤消已推送的提交可能会导致严重问题！\n\n详情：$1
dlgSgUndoLastCommitConfirm.hdl=您确定要撤消上次本地提交吗？
dlgSgUndoLastCommitConfirm.tle=撤消上次提交
dlgSgUnstageNoFilesFound.fur=找不到具有暂存变更的文件。
dlgSgUnstageNoFilesFound.hdl=找不到可能取消暂存的文件。
dlgSgUnstageNoFilesFound.tle=取消暂存
dlgSgWelcome.chk"Show this dialog if no repository was opened"=\
 如果没有打开仓库，则显示此对话框
dlgSgWelcome.hdl=你想做什么?
dlgSgWelcome.inf=选择是否打开新的本地仓库，克隆 \(远程\) 仓库或打开现有仓库。
dlgSgWelcome.rbt"Add an existing local or create a new repository"=\
 创建现有本地或创建新仓库
dlgSgWelcome.rbt"Clone existing repository"=克隆现有的仓库
dlgSgWelcome.rbt"Reopen previously used repository:"=重新打开以前使用的仓库：
dlgSgWelcome.tle=欢迎使用 SmartGit
dlgSgWorktreeAdd.edt"Branch"=分支
dlgSgWorktreeAdd.edt"Directory"=目录
dlgSgWorktreeAdd.hdl=从此仓库创建其他工作区
dlgSgWorktreeAdd.inf=选择要用于新工作区的分支和目录。
dlgSgWorktreeAdd.tle=创建工作区
dlgSgWorktreeAddNoMoreLocalBranches.fur=只能为尚无关联工作区的现有本地分支创建工作区。
dlgSgWorktreeAddNoMoreLocalBranches.hdl=没有可用的 \(更多\) 本地分支。
dlgSgWorktreeAddNoMoreLocalBranches.tle=添加工作区
dlgSgWorktreePruneNoWorktree.fur=您的所有工作区仍然可用。
dlgSgWorktreePruneNoWorktree.hdl=没有要删除的工作区。
dlgSgWorktreePruneNoWorktree.tle=删除废弃的工作区
dlgSg(Preferences|Pull|RepositorySettings).rbt"Merge fetched remote changes"=合并获取的远程变更
dlgSg(Preferences|Pull|RepositorySettings).rbt"Rebase local branch onto fetched changes"=\
 将本地分支变基至获取的变更
dlgShPushTrackingLocalSvnBranches.btn"Push as New"=推送到新的
dlgShPushTrackingLocalSvnBranches.btn"Push onto Existing"=推到现有的
dlgShPushTrackingLocalSvnBranches.fur=您将把本地分支推送回 SVN 仓库。 这些分支可能作为新分支推送到现有的 SVN 对应部分 \(在大多数情况下推荐使用\)。
dlgShPushTrackingLocalSvnBranches.hdl=你想推动本地分支作为新的 SVN 分支吗？
dlgShPushTrackingLocalSvnBranches.tle=推送
dlgTxtEditor.fileModified.btn"Keep Content"=保留内容
dlgTxtEditor.fileModified.btn"Reload"=重新加载
dlgTxtEditor.fileModified.fur=重新加载将显示最新的文件状态.
dlgTxtEditor.fileModified.hdl=该文件配置已变更. 是否重新加载?
dlgTxtEditor.fileModified.tle=编辑器
dlg(DgRefMapperGroupConfig|SgPreferences|SgRepositorySettings).edt"Group Patterns"=分组模式
dlg(DgRefMapperGroupConfig|SgPreferences|SgRepositorySettings).edt"Single Patterns"=单一模式
dlg(DgRefMapperGroupConfig|SgPreferences|SgRepositorySettings).lbl"Tags, branches and other refs matched by this configuration will be grouped in the File Log and show up in the Commit details. It will also be used for grouping the 'Tags'-category of the Branches view."=\
 与此配置匹配的标签、分支和其他引用将在文件日志中分组，并显示在提交详细信息中。它还将用于对 “分支” 视图的 “标签” 类别进行分组。
dlg(DgRefMapperGroupConfig|SgPreferences|SgRepositorySettings).tab"Tag-Grouping"=标签分组
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"Please enter a file pattern \(e.g. \*.txt, \*.java\)."=\
 Please enter a file pattern \(e.g. \*.txt, \*.java\).
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"Select the command which should be invoked."=\
 Select the command which should be invoked.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"Specify the necessary arguments for the command, especially the required variable."=\
 Specify the necessary arguments for the command, especially the required variable.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"Specify the necessary arguments for the command, especially the required variables."=\
 Specify the necessary arguments for the command, especially the required variables.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"The Arguments require the variable \$\{file\}."=\
 只能接受 \$\{file\} 作为变量.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"The Arguments require the variables \$\{leftFile\} and \$\{rightFile\}."=\
 只能接受 \$\{leftFile\} 和 \$\{rightFile\} 作为变量.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"The Arguments require the variables \$\{leftFile\}, \$\{rightFile\} and \$\{mergedFile\}."=\
 只能接受 \$\{leftFile\}, \$\{rightFile\} 和 \$\{mergedFile\} 作为变量.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).lbl"You must use the variable \$\{file\}."=\
 你只能使用 \$\{file\} 作为变量.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).lbl"You must use the variables \$\{leftFile\} and \$\{rightFile\}."=\
 你只能使用 \$\{leftFile\} 和 \$\{rightFile\} 作为变量.
dlg(SgDeleteFileTrash|SgDeleteFilesTrash).btn"Delete"=删除
dlg(SgDeleteFileTrash|SgDeleteFilesTrash).btn"Move to Trash"=移动到回收站
dlg(SgDeleteFileTrash|SgDeleteFilesTrash).fur=如果单击 “删除”，则可能需要文件还原工具来还原已删除的文件！
dlg(SgDeleteFileTrash|SgDeleteFilesTrash).tle=删除
dlg(SgRepositoryRemoveMultiGroup|SgRepositoryRemoveMultiRepo|SgRepositoryRemoveMultiRepoMultiGroup|SgRepositoryRemoveMultiRepoSingleGroup|SgRepositoryRemoveSingleGroup|SgRepositoryRemoveSingleRepo|SgRepositoryRemoveSingleRepoMultiGroup|SgRepositoryRemoveSingleRepoSingleGroup).btn"Remove"=删除
dlg(SgRepositoryRemoveMultiGroup|SgRepositoryRemoveMultiRepo|SgRepositoryRemoveMultiRepoMultiGroup|SgRepositoryRemoveMultiRepoSingleGroup|SgRepositoryRemoveSingleGroup|SgRepositoryRemoveSingleRepo|SgRepositoryRemoveSingleRepoMultiGroup|SgRepositoryRemoveSingleRepoSingleGroup).chk=不再显示
dlg(SgRepositoryRemoveMultiGroup|SgRepositoryRemoveMultiRepo|SgRepositoryRemoveMultiRepoMultiGroup|SgRepositoryRemoveMultiRepoSingleGroup|SgRepositoryRemoveSingleGroup|SgRepositoryRemoveSingleRepo|SgRepositoryRemoveSingleRepoMultiGroup|SgRepositoryRemoveSingleRepoSingleGroup).tle=删除
edt"Search For"=搜索
ntmCredentialHelper"In case you are encountering strange errors or unexpected dialog popups, try to disable this configuration and let SmartGit handle the authentication itself."=\
 万一您遇到奇怪的错误或意外的对话框弹出, 可以尝试禁用此配置改由 SmartGit 处理身份验证.
ntmCredentialHelper"In general this should be fine and is the recommended configuration when working with multiple Git clients."=\
 通常来说这是使用多个Git客户端时的推荐配置.
ntmCredentialHelper"SmartGit has detected that <b>credential.helper</b> is configured in config file $1."=\
 SmartGit 检测到 <b>credential.helper</b> 被配置到了 $1 文件中.
ntmCredentialHelper"To disable this configuration, open the above config file, locate the <b>\[credential\]</b>-section and comment out the <b>helper\=</b> line using <b>#</b>"=\
 要想禁用此配置项, 请打开以上配置文件, 定位到 <b>\[credential\]</b>-选项并使用<b>#</b>注释掉 <b>helper\=</b>
ntmFollowUsOnTwitter"It's a great way to help shaping future versions of SmartGit!"=\
 帮助我们塑造更好的未来版本!
ntmFollowUsOnTwitter"We are using Twitter to:"=我们在 Twitter 上:
ntmFollowUsOnTwitter"announce new versions, including previews"=发布新版本, 以及预览版
ntmFollowUsOnTwitter"inform about new features"=告知新功能
ntmFollowUsOnTwitter"poll for opinions on how to implement new or change existing features"=\
 关于如何实施新功能或更改现有功能的意见调查
ntmHighMemoryUsage"If you are working with huge repositories, this may be OK. In this case, edit $1, increase the value of the -Xmx option, for example to -Xmx1024m \(or add it if not yet existing\) for better performance."=\
 如果您正在使用大型仓库, 这可能是正常的. 在这种情况下, 编辑 $1, 增加 -Xmx 选项, 例如 -Xmx1024m 可以获得更好的性能.
ntmHighMemoryUsage"If you think that the configured memory limit is already quite high or you are not working with huge repositories, this may indicate a problem. Please let us know about it."=\
 如果您认为配置的内存限制过高或者您没有使用大型仓库, 这可能存在某些问题. 请联系我们.
ntmHighMemoryUsage"SmartGit is close to the configured memory limit."=\
 SmartGit 已接近配置的内存限制.
ntmHostingProviderIntegrationNotYetConfigured"SmartGit provides special support for $1. The integration can be configured in the Preferences."=\
 SmartGit 为 $1 提供特殊支持服务. 可在首选项中配置集成.
ntmMarkRepositoriesAsFavorite"Git repositories marked as 'favorites' will be refreshed and fetched automatically in the background."=\
 标记为收藏的仓库会后台自动刷新
ntmMarkRepositoriesAsFavorite"To mark a repository as 'favorite', right-click on it in the 'Repositories' view and select 'Mark as Favorite'."=\
 要想将仓库添加到 '收藏夹', 请在 '仓库' 视图中右击仓库并选择 '标记为收藏'.
ntmPreferencesChangesRestartRequired"Some preferences options have been changed which will only be applied after restarting SmartGit."=\
 某些首选项设置已发生变更, 将会在重启 SmartGit 后生效.
ntmProblematicGcConfiguration"Git's garbage collection is \(by default\) configured to run in background \(gc.autoDetach\) in your .gitconfig. This configuration is appropriate for command line client, but may cause troubles in combinations with GUI clients like SmartGit."=\
 .gitconfig 文件中的 Git 垃圾回收 \(默认\) 被配置为后台运行 \(gc.autoDetach\). 此配置适用于命令行客户端, 但在GUI客户端(如 SmartGit)配合使用可能会导致问题.
ntmSupportExpired"To extend your support, please purchase an update license and upgrade to the latest SmartGit version."=\
 想要使用支持服务, 请购买升级授权许可并更新到最新版本.
ntmSupportExpired"You may continue to use SmartGit, just your support period expired."=\
 您可以继续使用 SmartGit, 只是支持服务已过期.
ntmUpdateCheckFetchVersionStart"After the new version has been downloaded successfully, you will be notified again."=\
 After the new version has been downloaded successfully, you will be notified again.
ntmUpdateCheckFetchVersionSuccess"SmartGit needs to be restarted now for the changes to take effect."=\
 SmartGit 需要重新启动以使更新生效.
ntmUpdateCheckFetchVersionSuccess"Your SmartGit installation needs to be upgraded now."=\
 您的 SmartGit 安装程序需要立即更新.
ntmVoteForUs"Let us and other users know why you prefer SmartGit over other Git clients or what parts of SmartGit still need work!"=\
 Let us and other users know why you prefer SmartGit over other Git clients or what parts of SmartGit still need work!
ntmVoteForUs"share the pros and cons at <link1>slant.co</link1>"=\
 share the pros and cons at <link1>slant.co</link1>
ntmVoteForUs"vote at <link1>alternativeto.net</link1>"=vote at <link1>alternativeto.net</link1>
nttCredentialHelper"External Credentials Helper detected"=检测到外部凭据帮助程序
nttFollowUsOnTwitter"Follow SmartGit on Twitter!"=在Twitter上关注SmartGit!
nttFollowUsOnTwitter"Follow on Twitter"=关注 Twitter
nttGeneral"Don't show again"=不再提醒
nttGeneral"Remind me later"=以后再说
nttHighMemoryUsage"Contact Support"=联系支持
nttHighMemoryUsage"High memory usage"=高内存使用率
nttHostingProviderIntegrationNotYetConfigured"$1-integration is not yet configured."=$1-integration is not yet configured.
nttHostingProviderIntegrationNotYetConfigured"Configure Now"=立即配置
nttMarkRepositoriesAsFavorite"Mark repositories as 'favorite' for automatic background refresh."=\
 标记为收藏的仓库会后台自动刷新.
nttPreferencesChangesRestartRequired"Exit SmartGit"=退出 SmartGit
nttPreferencesChangesRestartRequired"Restart Required"=需要重启
nttPreferencesChangesRestartRequired"Restart SmartGit"=重启 SmartGit
nttProblematicGcConfiguration"Disable Background GC"=禁用后台垃圾回收
nttProblematicGcConfiguration"Possibly problematic Git GC configuration"=Git 垃圾回收配置可能存在问题
nttSupportExpired"Purchase Update"=购买更新
nttSupportExpired"Your support period has expired on $1."=\
 您的支持服务将于 $1 过期.
nttUpdateCheckFetchVersionStart"Started downloading version $1 \($2\)."=正在下载版本 $1 \($2\).
nttUpdateCheckFetchVersionSuccess"Restart SmartGit"=重启 SmartGit
nttUpdateCheckFetchVersionSuccess"Show Changelog"=更新日志
nttUpdateCheckFetchVersionSuccess"Successfully downloaded version $1."=成功下载版本 $1.
nttUpdateCheckFetchVersionSuccess"Upgrade SmartGit"=升级 SmartGit
nttVoteForUs"What do you like in SmartGit?"=\
 您喜欢 SmartGit 哪些功能?
pop"$1 succeeded."=$1 成功。
pop"Command $1 has been aborted."=命令 $1 已中止。
pop"Modify the previous commit and commit."=\
 修改先前的提交和提交。
pop"No more change."=没有更多变更.
pop"No more changes."=没有差异。
pop"Please review the files to commit."=\
 请审阅要提交的文件.
pop"Select the branch for which to stop tracking."=\
 选择需要停止跟踪的分支.
pop"Select the remote to fetch from."=\
 选择要从中获取的远程仓库。
pop"Select the remote to rename."=选择要重命名的远程。
pop"Select the stash to drop."=选择要丢弃的贮藏.
pop"Select the stash to rename."=选择要重命名的存储。
pop"There are no obsolete repositories."=没有过时的仓库。
pop"There is no action available for this drop operation."=\
 此删除操作没有可用的操作。
pop"Unstage unwanted changes for the 1st commit, and commit."=\
 取消暂存第一次提交和提交的不需要的变更。
ttpClonePartialWarning"<b>Warning!</b>\n\nThis functionality depends on the capabilities of your server.\nOnce the clone has finished, check the Output view for possible warnings."=\
 <b>警告!</b>\n\n此功能取决于服务器的功能.\n克隆完成后, 前往输出面板查看可能出现的警告信息.
ttpTagGroupingGroupPatterns"Refs will be categorized into groups: when traversing the repository root log, refs will first be assigned to matching groups. Every group will store only the most recently encountered ref, i.e. if a new ref is encountered, it will replace all existing refs in the current group.\n\nNext, the refs remaining in the group will be passed on from child to parent commit. Now, once again they will be assigned to matching groups, possibly replacing other refs or possibly becoming replaced by more recent refs.\n\nPatterns will be matched against the full ref-name, including the <tt>refs</tt>-prefix. For a matching ref, its name will be shortened to the last path-segment \('\\/'\). For example, <tt>refs/tags/build-.\*</tt> will match a tag <tt>refs/tags/build-123</tt> and its name will be shortened to <tt>build-123</tt>. You may add a <i>named regex capturing group</i> called <tt>name</tt> to further customize the name extraction. For example, <tt>refs/tags/build-\(?&lt;name&gt;.\*\)</tt> will match <tt>refs/tags/build-123</tt> and its name will be shortened to <tt>123</tt>.\n\nYou can assign a title to a pattern by prefixing it by <tt>title:</tt>; the title may only contain letters, digits and '_'.\n\nYou can specify multiple groups patterns, separated by comma \(<tt>,</tt>\), which will be processed in the specified order: if you define two groups which both match a set of refs, such refs will be assigned to the first group.\n\nExample: <tt>build:refs/tags/build\(?&lt;name&gt;.\*\),version:refs/tags/\\d+\\.\\d+\\..\*</tt>"=\
 引用将会按组分类: 遍历存储库根日志时, 引用将首先分配给匹配的组. 每个组将只存储最近的引用, 例如如果出现了新的引用, 将会被当前组中的引用替换.\n\n然后, 组中剩余的引用将从子提交传递到父提交. 他们将再次被分配到匹配的组, 可能取代其他引用，或可能被更新的引用取代.\n\n模式将与完整的引用名称匹配, 包括 <tt>引用</tt>-前缀. For a matching ref, its name will be shortened to the last path-segment \('\\/'\). For example, <tt>refs/tags/build-.\*</tt> will match a tag <tt>refs/tags/build-123</tt> and its name will be shortened to <tt>build-123</tt>. You may add a <i>named regex capturing group</i> called <tt>name</tt> to further customize the name extraction. For example, <tt>refs/tags/build-\(?&lt;name&gt;.\*\)</tt> will match <tt>refs/tags/build-123</tt> and its name will be shortened to <tt>123</tt>.\n\nYou can assign a title to a pattern by prefixing it by <tt>title:</tt>; the title may only contain letters, digits and '_'.\n\nYou can specify multiple groups patterns, separated by comma \(<tt>,</tt>\), which will be processed in the specified order: if you define two groups which both match a set of refs, such refs will be assigned to the first group.\n\nExample: <tt>build:refs/tags/build\(?&lt;name&gt;.\*\),version:refs/tags/\\d+\\.\\d+\\..\*</tt>
ttpTagGroupingSinglePattern"In addition to the grouping logic, a ref matching the <b>Single Patterns</b> will be assigned to a group on its own. This is a shortcut for enumerating each of these refs as explicit pattern in <b>Group Patterns</b>.\n\nFor example, you want to make sure that each of your release branches is considered as group on its own and thus show up in the log graph or will be treated separately by the 'on-refs' calculation.\n\nExample: <tt>refs\\/remotes\\/origin\\/release-.\\\*</tt>"=\
 In addition to the grouping logic, a ref matching the <b>Single Patterns</b> will be assigned to a group on its own. This is a shortcut for enumerating each of these refs as explicit pattern in <b>Group Patterns</b>.\n\nFor example, you want to make sure that each of your release branches is considered as group on its own and thus show up in the log graph or will be treated separately by the 'on-refs' calculation.\n\nExample: <tt>refs\\/remotes\\/origin\\/release-.\\\*</tt>
wndAnnotate.edt"By"=By
wndAnnotate.edt"Commit"=提交
wndAnnotate.edt"Highlight"=高亮
wndAnnotate.edt"View Commit"=查看提交
wndAnnotate.mni"Copy Details"=复制详情
wndAnnotate.mni"Copy ID"=复制 ID
wndAnnotate.mni"Copy Selection"=复制所选
wndAnnotate.mni"Open Log"=打开日志
wndAnnotate.mni"Show Changes"=显示变更
wndAnnotate.mniCommit-first=转到第一次提交
wndAnnotate.mniCommit-last=转到最后一次提交
wndAnnotate.mniCommit-next=转到下一个提交
wndAnnotate.mniCommit-preceding-line=转到前一个提交
wndAnnotate.mniCommit-previous=转到上一个提交
wndAnnotate.mniCompare=显示变更
wndAnnotate.mniCustomize=自定义
wndAnnotate.mniEdit-copy=复制
wndAnnotate.mniFile-close=关闭
wndAnnotate.mniGoto-line=转到行
wndAnnotate.mniLog=打开日志
wndAnnotate.mniSearch-find=查找
wndAnnotate.mniSearch-next=向下查找
wndAnnotate.mniSearch-previous=向上查找
wndAnnotate.mniSet-syntax=语言模式
wndAnnotate.mniShowChanges=显示修改
wndAnnotate.mniUndo-goto=撤消转到
wndAnnotate.mniView-settings=设置
wndAnnotate.mniWindowHideView=隐藏视图
wndAnnotate.mniWindowLineHistory=行历史记录
wndAnnotate.mnu"Edit"=编辑
wndAnnotate.mnu"File"=文件
wndAnnotate.mnu"Go To"=转到
wndAnnotate.mnu"View"=视图
wndAnnotate.rbt"Commit Index"=提交索引
wndAnnotate.rbt"Time"=时间
wndAnnotate.tab"Document"=文档
wndAnnotate.tab"History of current line"=当前行的历史记录
wndCompare.mniRefresh=重新加载
wndCompare.mniView-layout-left-beside-right=左侧右侧
wndCompare.mniView-layout-left-over-right=左上方
wndCompare.tbtEdit-take-left=采用左侧代码块到右侧文件. 取决于左侧代码块, 这将在右侧文件中插入、替换或删除.
wndCompare.tbtEdit-take-right=采用右侧代码块到左侧文件. 取决于右侧代码块, 这将在左侧文件中插入、替换或删除.
wndCompare.tbtFile-save=保存文件变更
wndCompare.tbtGoto-next-diff=下一处差异。
wndCompare.tbtGoto-previous-diff=上一处差异。
wndCompare.tbtRefresh=从文件系统中重新加载文件内容进行对比
wndConflictSolver.mni"Apply Inner-line Difference to Working Tree"=\
 将行内差异应用于工作树
wndConflictSolver.mni"Apply Line to Working Tree"=应用行到工作树
wndConflictSolver.mni"Apply Selection to Working Tree"=应用选定内容到工作树
wndConflictSolver.mniView-layout-all=所有
wndConflictSolver.mniView-layout-left-merge=左合并
wndConflictSolver.mniView-layout-left-right-above-merge=左右合并
wndConflictSolver.mniView-layout-right-merge=右合并
wndConflictSolver.tbr"All"=全部
wndConflictSolver.tbr"Base + Right"=基准 + 右侧
wndConflictSolver.tbr"Base Below"=基准以下
wndConflictSolver.tbr"Base Changes"=基准变更
wndConflictSolver.tbr"Left + Base"=左侧 + 基准
wndConflictSolver.tbr"Left + Merge"=左侧 + 合并
wndConflictSolver.tbr"Merge + Right"=合并 + 右侧
wndConflictSolver.tbr"Merge Below"=下方合并
wndConflictSolver.tbr"Next Conflict"=下一处冲突
wndConflictSolver.tbr"Prev. Conflict"=上一处冲突
wndConflictSolver.tbr"Take Left, Right"=先采用左侧文件块, 再采用右侧文件块
wndConflictSolver.tbr"Take Right, Left"=先采用右侧文件块, 再采用左侧文件块
wndConflictSolver.tbtEdit-take-left=采用左侧代码块. 取决于左侧代码块, 这将在合并结果中插入、替换或删除.
wndConflictSolver.tbtEdit-take-left-right=先采用左侧代码块, 再采用右侧文件块
wndConflictSolver.tbtEdit-take-right=采用右侧代码块. 取决于右侧代码块, 这将在合并结果中插入、替换或删除.
wndConflictSolver.tbtEdit-take-right-left=先采用右侧文件块, 再采用左侧文件块
wndConflictSolver.tbtFile-open-base=从通用基础文档中打开左右变更。
wndConflictSolver.tbtFile-save=保存文件修改。
wndConflictSolver.tbtGoto-next-conflict=下一处冲突。
wndConflictSolver.tbtGoto-next-diff=下一处冲突变更。
wndConflictSolver.tbtGoto-previous-conflict=上一处冲突。
wndConflictSolver.tbtGoto-previous-diff=上一处变更。
wndConflictSolver.tbtView-layout-all=显示左侧, 合并和右侧文件.
wndConflictSolver.tbtView-layout-left-merge=显示左侧和合并文件.
wndConflictSolver.tbtView-layout-left-right-above-merge=在合并文件上方显示左右文件。
wndConflictSolver.tbtView-layout-right-merge=显示合并和右侧文件
wndDeepgit.btn"Go Deeper"=深入
wndDeepgit.col"File"=文件
wndDeepgit.col"Modifications"=修改
wndDeepgit.ihp"The \*Origin View\*: it highlights the selected origin candidate. By invoking \*Blame \(go deeper\)\* DeepGit will move its /focus/ onto the shown file\\/commit and select the corresponding commit in the \*Navigation\* view."=\
 \*起源视图\*: 这里会高亮显示已选的起源. 通过点击 \*Blame \(go deeper\)\* DeepGit 会移动起源 /聚焦/ 已显示的文件\\/提交, 并选择 \*导航视图\* 相应的提交.
wndDeepgit.ihp"This view displays all /origin candidates/ for the selected line from the \*Blame\* view: If the selected line has not been modified\\/added in the \*Blame\* view commit itself, the \*Appeared here\* origin takes you to this commit. Otherwise, the \*Changed in-place\* entry shows the actual change. \*Moved\* entries denote possible moves. The selected origin candidate will be highlighted in the \*Blame\* view as well as the \*Origin\* view. To inspect changes of the origin candidate in greater detail, switch to the \*Origins\* perspective."=\
 此视图是显示来自\*提交\视图中所选行的*/起源/: 如果所选行在\*提交\*视图提交中被修改, \*出现在此处\*会引导你到此次提交. 否则, 会显示\*就地更改\*的入口. \*已移动\*表示可能的移动. 被选中的起源会在\*提交\*视图和\*起源\*视图中高亮显示. 要想更详细地审查起源的更改, 可以切换到\*起源\*视角.
wndDeepgit.ihp"This view displays all changes for the selected commit from the \*Navigation\* view. The selected file will be compared in the below view."=\
 此视图是显示\*导航\*视图中选中提交的所有变更. 选中的文件将会在下方列出对比情况.
wndDeepgit.ihp"This view displays all files which have changed as part of the selected \*Blame\* line's commit. The selected file will be compared in the below view."=\
 This view displays all files which have changed as part of the selected \*Blame\* line's commit. The selected file will be compared in the below view.
wndDeepgit.ihp"This view shows how the selected line from the \*Blame\* view has changed in the past."=\
 This view shows how the selected line from the \*Blame\* view has changed in the past.
wndDeepgit.ihp"This view shows the Log for the investigated file and for all previous files you have navigated to. For the selected commit, more details will be displayed which depend on the current perspective: \n# in the \*Blame\* perspective the file's content will be displayed in the \*Blame\* view, \n# in the \*Diff\* perspective the file's modifications will be displayed, \n# in the \*Log\* perspective a summary of all modified files will be displayed in the \*Files\* view."=\
 此视图是显示审查的文件和你导航过的所有文件的日志. 对于选中的提交, 不同的视角会显示更详细的信息: \n# 对于\*提交\*视角, 文件的内容将会显示在\*提交\* 视图中, \n# 对于\*差异\*视角, 将会显示文件的修改 \n# 对于\*日志\*视角, 将会在\*文件\*视图中显示所有修改文件的摘要.
wndDeepgit.ihp"This view shows the blame for the selected file\\/commit from the \*Navigation\* tree. When selecting a line DeepGit will start searching for the origin of this line and show results in the \*Origin Candidates\* view \(only available in the \*Blame+Origins\* perspective\). The best origin candidate will be selected and highlighted. DeepGit will follow across line moves and file renames and taking into account the line's vicinity, so origin candidates will usually be blocks, not just single lines."=\
 这里显示的是\*导航树\*已选的文件或提交. 选中行后 DeepGit 就会立即开始搜索这行的来源并显示在\*原始提交\*视图中 \(仅 \*提交和起源视角\* 可用\). 最符合的起源结果将会被选中并高亮. DeepGit 将跟踪跨行移动和文件重命名，并参考上下文, 所以原始来源通常是多个块, 而不是单独几行.
wndDeepgit.ihp"This view shows the diff for the selected file from the above \*Files\* view."=\
 此视图是显示\*文件\*视图选中的文件差异.
wndDeepgit.ihp"This view shows the diff for the selected origin candidate\\/file from the above \*Origin Candidates\*\\/\*Files\* view."=\
 此视图是显示\\/来自于\*起源\*\\/\*文件\*视图选中的原始来源或文件差异.
wndDeepgit.lbl"Similarity detection was only performed for single lines, some results may be omitted \(View\|Extend Lines to Blocks\)"=\
 仅对单行进行相似性检测, 某些结果可能会被省略 \(视图\|单行/代码块\)
wndDeepgit.lblBlameHeader"Blame \(in progress...\)"=提交 \(处理中...\)
wndDeepgit.lblBlameHeader"Blame for"=提交
wndDeepgit.lblBlameMatchPopup"Appeared here"=出现在此处
wndDeepgit.lblBlameMatchPopup"Changed in-place"=就地更改
wndDeepgit.lblBlameMatchPopup"Lines first appeared at this position"=\
 这里可能是最初添加的地方
wndDeepgit.lblBlameMatchPopup"Lines have possibly been changed in-place"=\
 这里可能被修改过
wndDeepgit.lblBlameMatchPopup"Lines have possibly been moved over from somewhere else"=\
 这里可能是从其他地方移动过来的
wndDeepgit.lblBlameMatchPopup"Moved"=已移动
wndDeepgit.lblBlameMatchPopup"other possible origins"=可能是其他来源
wndDeepgit.lblBlameMatchPopup"single origin, high likelihood"=很可能是单一来源
wndDeepgit.lblCompareHeader"New contents"=新内容
wndDeepgit.lblCompareHeader"Old contents"=旧内容
wndDeepgit.lblOriginCandidate"Appeared here"=出现在此处:
wndDeepgit.lblOriginCandidate"Changed in-place"=就地更改
wndDeepgit.lblOriginCandidate"Line has been introduced in this commit"=\
 在此提交中被引入
wndDeepgit.lblOriginCandidate"Lines have been added"=被添加
wndDeepgit.lblOriginCandidate"Lines have been introduced in this commit"=\
 在此提交中被引入
wndDeepgit.lblOriginCandidate"Lines have been modified"=就地更改
wndDeepgit.lblOriginCandidate"Moved"=已移动
wndDeepgit.lblOriginCandidate"Origins from '$1' omitted: file is binary"=\
 来自 '$1' 的起源被省略: 二进制文件
wndDeepgit.lblOriginCandidate"Similarity detection was only performed for single lines, some results may be omitted \(View\|Extend Lines to Blocks\)"=\
 仅对单行进行相似性检测, 某些结果可能会被省略 \(视图\|单行/代码块\)
wndDeepgit.lblOriginCandidate"as 'git diff' sees it"=使用 'git diff' 查看
wndDeepgit.lblOriginCandidate"for the first time"=首次
wndDeepgit.lblOriginCandidate"from $1 previous line"=来自于 $1 上一行
wndDeepgit.lblOriginCandidate"from $1 previous lines"=来自于 $1 前几行
wndDeepgit.lblOriginCandidate"of"=:
wndDeepgit.lblOriginCandidate"over from somewhere else"=来自于其他地方
wndDeepgit.lblOriginCandidate"similarity for $1 origin line"=与 $1 个起源行相似
wndDeepgit.lblOriginCandidate"similarity for $1 origin lines"=与 $1 个起源行相似
wndDeepgit.lblOriginHeader"No file to compare"=没有文件要对比
wndDeepgit.lblOriginHeader"Possibly modified \(or added\) as part of <b>surrounding block</b> in old contents"=\
 可能来自于旧内容的 <b>附近的代码块</b>
wndDeepgit.lblOriginHeader"Possibly moved from <b>similar lines</b> from old contents"=\
 可能来自于旧内容的 <b>相似行</b>
wndDeepgit.lblOriginHeader"Possibly originates from <b>in-place change</b> since old contents"=\
 可能来自于旧内容的 <b>就地更改</b>
wndDeepgit.lblTextHeader"Commit"=提交
wndDeepgit.lblTextHeader"File"=文件
wndDeepgit.lblTextHeader"Msg"=信息
wndDeepgit.lblTextHeader"at"=提交于
wndDeepgit.lblTextHeader"by"=by
wndDeepgit.lblTextHeader"on"=on
wndDeepgit.mni"Copy Details"=复制详情
wndDeepgit.mni"Copy ID"=复制 ID
wndDeepgit.mni"Copy Selection in Column"=按列复制
wndDeepgit.mni"Copy Selection"=复制所选
wndDeepgit.mni"Copy"=复制
wndDeepgit.mni"File"=文件
wndDeepgit.mni"Modifications"=修改
wndDeepgit.mni"Open File Log"=打开文件日志
wndDeepgit.mni"Open Repository Log"=打开仓库日志
wndDeepgit.mniAbout=关于 DeepGit
wndDeepgit.mniBack=回退
wndDeepgit.mniConfigureRefGroups=引用标签分组
wndDeepgit.mniEdit-copy=复制
wndDeepgit.mniExtendLineToBlock=单行/代码块
wndDeepgit.mniFile-close=关闭
wndDeepgit.mniFilterAddSelection=将选定内容添加到筛选器
wndDeepgit.mniFilterReset=重置筛选器
wndDeepgit.mniFilterSetSelection=将选定内容设置为筛选器
wndDeepgit.mniFollowRenames=关注重命名
wndDeepgit.mniForward=前进
wndDeepgit.mniGoto-line=转到行
wndDeepgit.mniGoto-next-diff=下一处差异
wndDeepgit.mniGoto-previous-diff=上一处差异
wndDeepgit.mniHighlightBlameChanges=高亮当前追溯提交的变更
wndDeepgit.mniHighlightOriginChanges=高亮当前来源提交的变更
wndDeepgit.mniIgnoreWhitespaceOnlyChanges=忽略空白变更
wndDeepgit.mniLicenseAgreement=许可协议
wndDeepgit.mniNextChange=下一处变更
wndDeepgit.mniOpenFileLog=打开文件日志
wndDeepgit.mniOpenRepositoryLog=打开仓库日志
wndDeepgit.mniOptimizeCreationOrigins=优化 “出现在此处” 的来源
wndDeepgit.mniPerspectiveBlameOrigin=追溯起源视角
wndDeepgit.mniPerspectiveBlameSimple=追溯视角
wndDeepgit.mniPerspectiveCommit=记录视角
wndDeepgit.mniPerspectiveHistory=比较透视
wndDeepgit.mniPerspectiveOrigins=起源视角
wndDeepgit.mniPreviousChange=上一处变更
wndDeepgit.mniResetInlineHelp=重新显示所有内联帮助
wndDeepgit.mniSearch-find=查找
wndDeepgit.mniSearch-next=向下查找
wndDeepgit.mniSearch-previous=向上查找
wndDeepgit.mniSetEncoding=编码
wndDeepgit.mniShowAtRefs=在引用处显示
wndDeepgit.mniShowLinePrefixes=显示行前缀
wndDeepgit.mniShowOnRefs=显示引用
wndDeepgit.mniToggleLineHistory=行历史记录
wndDeepgit.mniViewToolbar=显示工具栏
wndDeepgit.mniWindowHorizontalLayout=水平追溯起源布局
wndDeepgit.mniWindowVerticalLayout=垂直追溯起源布局
wndDeepgit.mnu"Edit"=编辑
wndDeepgit.mnu"File"=文件
wndDeepgit.mnu"Go To"=转到
wndDeepgit.mnu"Help"=帮助
wndDeepgit.mnu"View"=视图
wndDeepgit.tab"Files \(in progress\)"=文件 \(处理中\)
wndDeepgit.tab"Files changed in commit $1"=在 $1 提交中变更的文件
wndDeepgit.tab"Navigation \(initializing...\)"=导航 \(初始化...\)
wndDeepgit.tab"Navigation"=导航
wndDeepgit.tab"Origin Candidates \($1 hunks processed...\)"=起源 \($1 个已处理...\)
wndDeepgit.tab"Origin Candidates \(in progress\)"=起源 \(处理中\)
wndDeepgit.tab"Origin Candidates for line $1 of commit $2"=\
 提交ID $2 第 $1 行起源
wndDeepgit.tab"Origin Candidates"=起源
wndDeepgit.tbr"Back"=后退
wndDeepgit.tbr"Blame"=追溯
wndDeepgit.tbr"Blame+Origins"=追溯起源
wndDeepgit.tbr"Diff"=差异
wndDeepgit.tbr"Forward"=前进
wndDeepgit.tbr"Log"=日志
wndDeepgit.tbr"Origins"=起源
wndDeepgit.tbt"Go to next change."=下一处变更
wndDeepgit.tbt"Go to previous change."=上一处变更
wndDeepgit.tbtBack=上一个提交...
wndDeepgit.tbtForward=下一个提交...
wndDeepgit.tbtPerspectiveBlameOrigin=在可能的起源中查找行的起源位置。
wndDeepgit.tbtPerspectiveBlameSimple=在没有替代起源的情况下，在简单的情况下找到线的起源。
wndDeepgit.tbtPerspectiveCommit=审查记录。
wndDeepgit.tbtPerspectiveHistory=审查文件修订之间的差异。
wndDeepgit.tbtPerspectiveOrigins=找出该行的起源处所发生的其他情况。\n\n 为了检查可用的原点，必须首先对其进行评估。首先，使用文件\|打开选择要审查的文件，并选择其中的一行。然后等到可能原点的计算完成。
wndEditor.mni"CR \(classic macOS\)"=CR \(经典 macOS 系统\)
wndEditor.mni"CR+LF \(Windows\)"=CR+LF \(Windows 系统\)
wndEditor.mni"LF \(Unix, macOS\)"=LF \(Unix, macOS 系统\)
wndEditor.mniEdit-undo=撤销
wndEditor.mniEofEnforceLineEnding=在文件末尾强制使用行尾序列
wndEditor.mniReplaceTabsWithSpaces=将制表符 \(Tab\) 替换为空格
wndEditor.mniView-remember-as-default=记住为默认值
wndEditor.mniView-settings=设置
wndEditor.tbtFile-save=保存文件修改。
wndGit.indexEditor.mni"Discard Inner-line Change"=丢弃行内变更
wndGit.indexEditor.mni"Discard Line"=丢弃线
wndGit.indexEditor.mni"Discard Selection"=丢弃选择
wndGit.indexEditor.mni"Stage Inner-line Change"=暂存行内变更
wndGit.indexEditor.mni"Stage Line"=暂存线
wndGit.indexEditor.mni"Stage Selection"=暂存选择
wndGit.indexEditor.mni"Unstage Inner-line Change"=取消暂存行内变更
wndGit.indexEditor.mni"Unstage Line"=取消暂存线
wndGit.indexEditor.mni"Unstage Selection"=取消暂存选择
wndGit.indexEditor.mniView-layout-all=所有
wndGit.indexEditor.mniView-layout-head-index=HEAD 和索引
wndGit.indexEditor.mniView-layout-head-index-wt=所有
wndGit.indexEditor.mniView-layout-head-wt-above-index=HEAD 和工作区在索引上方
wndGit.indexEditor.mniView-layout-index-wt=索引和工作区
wndGit.indexEditor.mniView-layout-left-merge=左合并
wndGit.indexEditor.mniView-layout-left-right-above-merge=左右合并
wndGit.indexEditor.mniView-layout-right-merge=右合并
wndGit.indexEditor.tbtEdit-take-left=将左侧块移至合并结果。根据左侧块，这将在合并结果处插入，替换或删除。
wndGit.indexEditor.tbtEdit-take-right=采用右侧代码块到合并结果. 取决于右侧代码块, 这将在合并结果中插入、替换或删除.
wndGit.indexEditor.tbtFile-save=保存文件修改。
wndGit.indexEditor.tbtGoto-next-diff=下一处变更。
wndGit.indexEditor.tbtGoto-previous-diff=上一处变更。
wndLog.col"LFS"=LFS
wndLog.mni"Cherry-Pick $1 to '$2'"=将 $1 摘取至 '$2'
wndLog.mni"Committer Abbreviated"=修订者缩写
wndLog.mni"Committer Avatar"=修订者头像
wndLog.mni"Committer with Full Name and Email"=\
 修订者完整姓名和邮件
wndLog.mni"Committer with Full Name"=修订者完整姓名
wndLog.mni"Copy Branch"=复制分支
wndLog.mni"Copy Email Address"=复制邮件地址
wndLog.mni"Modification"=修改
wndLog.mni"Select Branch"=选择分支
wndLog.mni"Select Commit"=选择提交
wndLog.mni"Send Mail"=发送邮件
wndLog.mni"Unstage Hunk"=取消大量暂存
wndLog.mni"Unstage Innerline Change"=取消暂存行内变更
wndLog.mni"Unstage Line"=取消暂存行
wndLog.mni"Unstage Selection"=取消暂存所选
wndLog.tab"Changes \(EOL: Windows\)"=变更 \(EOL: Windows\)
wndLog.tbt"If selected and Index as well as Working Tree changes are available, show them separately."=\
 If selected and Index as well as Working Tree changes are available, show them separately.
wndLog.tbt"Reading incoming pull requests from '$1'."=\
 Reading incoming pull requests from '$1'.
wndLog.tbt"Refresh information from Bitbucket."=Refresh information from Bitbucket.
wndProject.mni"Log Selection"=选择日志
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std|).lblStatusBarMessage"Ready"=就绪
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std|).mniWindow-fullScreen=全屏
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std|).mniWindow-maximizeMaximize=最大化
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std|).mniWindow-maximizeRestore=还原
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std|).mniWindow-minimize=最小化
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std|).mniWindowMaximizeRestore"Maximize View"=最大化视图
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std|).mniWindowMaximizeRestore"Restore Maximized View"=还原视图
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std|).mnu"< No Windows >"=< 无窗口 >
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std|).mnu"Window"=窗口
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-take-left=使用左边文件块
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-take-left-right=使用左边文件块，然后使用右边文件块
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-take-right=使用右边文件块
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-take-right-left=使用右边文件块，然后使用左边文件块
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-undo=撤销
wnd(Compare|ConflictSolver|Git.indexEditor).mniFile-export-html=导出为 HTML 文件
wnd(Compare|ConflictSolver|Git.indexEditor).mniFile-open-base=打开基本文件变更
wnd(Compare|ConflictSolver|Git.indexEditor).mniGoto-next-conflict=下一处冲突
wnd(Compare|ConflictSolver|Git.indexEditor).mniGoto-next-diff=下一处差异
wnd(Compare|ConflictSolver|Git.indexEditor).mniGoto-previous-conflict=上一处冲突
wnd(Compare|ConflictSolver|Git.indexEditor).mniGoto-previous-diff=上一处差异
wnd(Compare|ConflictSolver|Git.indexEditor).mniShow-line-numbers=显示行号
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-ignore-whitespaces-all=忽略所有空白字符变化
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-ignore-whitespaces-leading-trailing=忽略前导/尾随空格以进行行比较
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-ignore-whitespaces-none=忽略没有用于行比较的空格
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-refresh=刷新
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-remember-as-default=记住默认
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-settings=设置
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-show-current-line-control=显示长的当前行
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-synchronize-scrolling=同步滚动
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Next Change"=下一处差异
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Prev. Change"=上一处差异
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Reload"=重新加载
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Take Left"=采用左侧
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Take Right"=采用右侧
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mni"Copy Selection"=复制选中
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniCustomize=自定义
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-copy=复制
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-cut=剪切
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-ignore-case-changes=忽略行比较的大小写变更
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-paste=粘贴
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-redo=重做
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniFile-close=关闭
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniFile-save=保存
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniGoto-line=转到行
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSearch-find=查找
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSearch-next=向下查找
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSearch-previous=向上查找
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSearch-replace=查找并替换
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSet-syntax=语言模式
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mnu"Edit"=编辑
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mnu"File"=文件
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mnu"Go To"=转到
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mnu"View"=视图
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).tbr"Save"=保存
wnd(Log|Project|Std|)."Abort"=中止
wnd(Log|Project|Std|)."Commit"=提交
wnd(Log|Project|Std|)."Conflict Solver"=冲突解决工具
wnd(Log|Project|Std|)."Continue"=继续
wnd(Log|Project|Std|)."Mark HEAD as Bad"=将 HEAD 标记为损坏
wnd(Log|Project|Std|)."Mark HEAD as Good"=将 HEAD 标记为正常
wnd(Log|Project|Std|)."Mark Resolved"=标记已解决
wnd(Log|Project|Std|)."Recreate Conflict"=重现冲突
wnd(Log|Project|Std|)."Rerun Thoroughly"=完全重运行
wnd(Log|Project|Std|)."Reset"=重置
wnd(Log|Project|Std|)."Reveal"=展示
wnd(Log|Project|Std|)."Show Local Changes"=显示本地变更
wnd(Log|Project|Std|)."Step"=步骤
wnd(Log|Project|Std|)."Swap"=交换
wnd(Log|Project|Std|)."Take Ours"=采用 我们的
wnd(Log|Project|Std|)."Take Theirs"=采用 他们的
wnd(Log|Project|Std|).btn"Abort"=中止
wnd(Log|Project|Std|).btn"Commit"=提交
wnd(Log|Project|Std|).btn"Conflict Solver"=冲突解决工具
wnd(Log|Project|Std|).btn"Continue"=继续
wnd(Log|Project|Std|).btn"Mark HEAD as Bad"=将 HEAD 标记为损坏
wnd(Log|Project|Std|).btn"Mark HEAD as Good"=将 HEAD 标记为正常
wnd(Log|Project|Std|).btn"Mark Resolved"=标记已解决
wnd(Log|Project|Std|).btn"Recreate Conflict"=重现冲突
wnd(Log|Project|Std|).btn"Rerun Thoroughly"=完全重运行
wnd(Log|Project|Std|).btn"Reset"=重置
wnd(Log|Project|Std|).btn"Reveal"=展示
wnd(Log|Project|Std|).btn"Show Local Changes"=显示本地变更
wnd(Log|Project|Std|).btn"Stage"=暂存
wnd(Log|Project|Std|).btn"Step"=步骤
wnd(Log|Project|Std|).btn"Swap"=交换
wnd(Log|Project|Std|).btn"Take Ours"=采用 我们的
wnd(Log|Project|Std|).btn"Take Theirs"=采用 他们的
wnd(Log|Project|Std|).chk"Add 'Signed-off-by' signature"=添加 'Signed-off-by' 签名
wnd(Log|Project|Std|).chk"Amend last commit instead of creating new one"=\
 修订最后一次提交而不是创建新提交
wnd(Log|Project|Std|).chk"Amend last commit"=修订上次的提交
wnd(Log|Project|Std|).chk"Bypass commit hook"=忽略提交钩子
wnd(Log|Project|Std|).chk"Create simple commit \('squash'\)"=生成简单提交 \('压缩'\)
wnd(Log|Project|Std|).chk"Push"=推送
wnd(Log|Project|Std|).col"Assignee"=代理人
wnd(Log|Project|Std|).col"Author"=作者
wnd(Log|Project|Std|).col"Branch"=分支
wnd(Log|Project|Std|).col"Copied From"=复制自
wnd(Log|Project|Std|).col"Copied from"=复制自
wnd(Log|Project|Std|).col"Date"=日期
wnd(Log|Project|Std|).col"Entry"=登记
wnd(Log|Project|Std|).col"Ext."=扩展名
wnd(Log|Project|Std|).col"Index State"=索引状态
wnd(Log|Project|Std|).col"Last Changed On"=最后更改于
wnd(Log|Project|Std|).col"Modification"=修改
wnd(Log|Project|Std|).col"Name"=名称
wnd(Log|Project|Std|).col"Path"=路径
wnd(Log|Project|Std|).col"Relative Directory"=相对目录
wnd(Log|Project|Std|).col"Relative Path"=相对路径
wnd(Log|Project|Std|).col"Renamed Path"=重命名路径
wnd(Log|Project|Std|).col"Size"=大小
wnd(Log|Project|Std|).col"State"=状态
wnd(Log|Project|Std|).col"Submodule"=子模块
wnd(Log|Project|Std|).col"Text"=文本
wnd(Log|Project|Std|).col"Working Tree State"=工作区状态
wnd(Log|Project|Std|).edt"Commit to"=提交到
wnd(Log|Project|Std|).hnt"File Filter"=文件过滤器
wnd(Log|Project|Std|).hnt"Filter or Tag Search"=过滤器或标签搜索
wnd(Log|Project|Std|).lbl"$1 files hidden"=$1 个隐藏文件
wnd(Log|Project|Std|).lbl"Directories"=个目录
wnd(Log|Project|Std|).lbl"Directory"=个目录
wnd(Log|Project|Std|).lbl"File"=个文件
wnd(Log|Project|Std|).lbl"Files"=个文件
wnd(Log|Project|Std|).mni"  Show Rewritten Behind Commits"=\
 在提交后显示重写
wnd(Log|Project|Std|).mni"<no entry>"=< 禁止输入 >
wnd(Log|Project|Std|).mni"<none>"=<无>
wnd(Log|Project|Std|).mni"Abbreviated"=简短的
wnd(Log|Project|Std|).mni"Add GitHub Comment"=创建 GitHub 注释
wnd(Log|Project|Std|).mni"Add GitLab Comment"=创建 GitLab 注释
wnd(Log|Project|Std|).mni"Add Review Comment"=创建审阅注释
wnd(Log|Project|Std|).mni"All"=所有
wnd(Log|Project|Std|).mni"Apply Patch"=应用补丁
wnd(Log|Project|Std|).mni"Assign"=分配
wnd(Log|Project|Std|).mni"Assignee"=申请人
wnd(Log|Project|Std|).mni"Author Abbreviated"=作者缩写
wnd(Log|Project|Std|).mni"Author Avatar"=作者头像
wnd(Log|Project|Std|).mni"Author with Full Name and Email"=\
 作者全名和电子邮件
wnd(Log|Project|Std|).mni"Author with Full Name"=作者全名
wnd(Log|Project|Std|).mni"Author"=作者
wnd(Log|Project|Std|).mni"Branch Coloring"=分支着色
wnd(Log|Project|Std|).mni"Branches and Tags"=分支和标签
wnd(Log|Project|Std|).mni"Branching:"=分支：
wnd(Log|Project|Std|).mni"Cancel"=取消
wnd(Log|Project|Std|).mni"Check Out"=检出
wnd(Log|Project|Std|).mni"Checkout"=检出
wnd(Log|Project|Std|).mni"Cherry-Pick Commits to $1"=摘取提交至 $1
wnd(Log|Project|Std|).mni"Clear History"=清除历史记录
wnd(Log|Project|Std|).mni"Close"=关闭
wnd(Log|Project|Std|).mni"Coloring:"=着色：
wnd(Log|Project|Std|).mni"Columns"=列
wnd(Log|Project|Std|).mni"Columns:"=列：
wnd(Log|Project|Std|).mni"Comment $1"=评论 $1
wnd(Log|Project|Std|).mni"Commit"=提交
wnd(Log|Project|Std|).mni"Committer"=修订者
wnd(Log|Project|Std|).mni"Compact Author"=紧凑作者
wnd(Log|Project|Std|).mni"Copy Full ID"=复制完整 ID
wnd(Log|Project|Std|).mni"Copy ID"=复制 ID
wnd(Log|Project|Std|).mni"Copy Name"=复制名称
wnd(Log|Project|Std|).mni"Copy Selection in Column"=按列复制
wnd(Log|Project|Std|).mni"Copy Selection"=复制所选
wnd(Log|Project|Std|).mni"Copy URL"=复制 URL
wnd(Log|Project|Std|).mni"Copy"=复制
wnd(Log|Project|Std|).mni"Create Merge Request"=创建合并请求
wnd(Log|Project|Std|).mni"Create Pull Request"=创建拉取请求
wnd(Log|Project|Std|).mni"Cut"=剪切
wnd(Log|Project|Std|).mni"Date"=日期
wnd(Log|Project|Std|).mni"Default Coloring"=默认着色
wnd(Log|Project|Std|).mni"Delete 'Comment $1'"=删除 '评论 $1'
wnd(Log|Project|Std|).mni"Delete"=删除
wnd(Log|Project|Std|).mni"Diff Tool"=差异工具
wnd(Log|Project|Std|).mni"Discard Hunk"=丢弃块
wnd(Log|Project|Std|).mni"Discard Inner-line Change"=丢弃行内变更
wnd(Log|Project|Std|).mni"Discard Line"=丢弃行
wnd(Log|Project|Std|).mni"Discard Selection"=丢弃选中
wnd(Log|Project|Std|).mni"Drop Local Data"=删除本地数据
wnd(Log|Project|Std|).mni"Edit 'Comment $1'"=编辑 '评论 $1'
wnd(Log|Project|Std|).mni"Edit in Index Editor"=在索引编辑器中编辑
wnd(Log|Project|Std|).mni"Edit"=编辑
wnd(Log|Project|Std|).mni"Ext."=提取。
wnd(Log|Project|Std|).mni"Fast-Forward Merge"=快进合并
wnd(Log|Project|Std|).mni"Fetch Merge Request"=获取合并请求
wnd(Log|Project|Std|).mni"Fetch Pull Request"=获取拉取请求
wnd(Log|Project|Std|).mni"File Content \(very expensive\)"=文件内容 \(非常昂贵\)
wnd(Log|Project|Std|).mni"File \(expensive\)"=文件 \(昂贵\)
wnd(Log|Project|Std|).mni"Files from Subdirectories"=子目录文件
wnd(Log|Project|Std|).mni"Follow All Parents"=关注所有父系
wnd(Log|Project|Std|).mni"Follow Only First Parent"=只关注第一个父系
wnd(Log|Project|Std|).mni"Forget Pattern"=忘记模式
wnd(Log|Project|Std|).mni"Forget"=忘记
wnd(Log|Project|Std|).mni"Format Patch"=格式补丁
wnd(Log|Project|Std|).mni"Full Author With Email"=完整的电子邮件作者
wnd(Log|Project|Std|).mni"Full Author"=完整作者
wnd(Log|Project|Std|).mni"Full Name With Email"=电子邮件全名
wnd(Log|Project|Std|).mni"Full Name"=全名
wnd(Log|Project|Std|).mni"Git Config"=Git 配置
wnd(Log|Project|Std|).mni"Git-LFS Version"=Git-LFS 版本
wnd(Log|Project|Std|).mni"ID"=ID
wnd(Log|Project|Std|).mni"Include Merge Only if File was Changed"=\
 仅当文件已变更时才包括合并
wnd(Log|Project|Std|).mni"Integrate"=集成
wnd(Log|Project|Std|).mni"Jump To"=跳转到
wnd(Log|Project|Std|).mni"LFS"=LFS
wnd(Log|Project|Std|).mni"Last Changed On"=最后更改于
wnd(Log|Project|Std|).mni"Mark as Bad"=标记为损坏
wnd(Log|Project|Std|).mni"Mark as Good"=标记为正常
wnd(Log|Project|Std|).mni"Merge '$1'"=Merge '$1'
wnd(Log|Project|Std|).mni"Merge Directly To"=直接合并到
wnd(Log|Project|Std|).mni"Merge Merge Request"=合并合并请求
wnd(Log|Project|Std|).mni"Merge Pull Request"=合并拉取请求
wnd(Log|Project|Std|).mni"Merge"=合并
wnd(Log|Project|Std|).mni"Message"=消息
wnd(Log|Project|Std|).mni"More options"=更多选项
wnd(Log|Project|Std|).mni"Move Commit"=移动提交
wnd(Log|Project|Std|).mni"Move To"=移动到
wnd(Log|Project|Std|).mni"Move and Squash Commit"=移动和压缩提交
wnd(Log|Project|Std|).mni"Name"=名称
wnd(Log|Project|Std|).mni"Neither"=两者都不是
wnd(Log|Project|Std|).mni"New Group"=创建分组
wnd(Log|Project|Std|).mni"No Group"=不分组
wnd(Log|Project|Std|).mni"Only If Changed"=仅当变更时
wnd(Log|Project|Std|).mni"Only Selected"=仅选中
wnd(Log|Project|Std|).mni"Open in Browser"=在浏览器中打开
wnd(Log|Project|Std|).mni"Open in Web Browser"=在 Web 浏览器中打开
wnd(Log|Project|Std|).mni"Other Branch"=其他分支
wnd(Log|Project|Std|).mni"Paste"=粘贴
wnd(Log|Project|Std|).mni"Path"=路径
wnd(Log|Project|Std|).mni"Please select Index or Working Tree."=\
 请选择索引或工作区。
wnd(Log|Project|Std|).mni"Print Git Version"=打印 Git 版本
wnd(Log|Project|Std|).mni"Pull, then Push"=拉取然后推送
wnd(Log|Project|Std|).mni"Push To"=推送到
wnd(Log|Project|Std|).mni"Push"=推送
wnd(Log|Project|Std|).mni"Push, then Pull"=推送然后拉取
wnd(Log|Project|Std|).mni"Quick Stash All"=快速贮藏所有
wnd(Log|Project|Std|).mni"Quick Stash Selection"=快速贮藏选中
wnd(Log|Project|Std|).mni"Rebase $1 commit from $2 to $3"=\
 将 $1 提交 从 $2 变基至 $3
wnd(Log|Project|Std|).mni"Rebase $1 commits from $2 to $3"=\
 将 $1 提交 从 $2 变基至 $3
wnd(Log|Project|Std|).mni"Rebase HEAD to '$1'"=将 HEAD 变基至 '$1'
wnd(Log|Project|Std|).mni"Regular Expressions"=常用表达
wnd(Log|Project|Std|).mni"Reject Pull Request"=拒绝拉取请求
wnd(Log|Project|Std|).mni"Relative Directory"=相对目录
wnd(Log|Project|Std|).mni"Relative Path"=相对路径
wnd(Log|Project|Std|).mni"Remember Pattern"=记住模式
wnd(Log|Project|Std|).mni"Rename"=重命名
wnd(Log|Project|Std|).mni"Renamed Path"=重命名路径
wnd(Log|Project|Std|).mni"Reorder Commits"=重新排序提交
wnd(Log|Project|Std|).mni"Reply '$1'"=回复 '$1'
wnd(Log|Project|Std|).mni"Reply"=回复
wnd(Log|Project|Std|).mni"Reset HEAD to $1"=将 HEAD 重置为 $1
wnd(Log|Project|Std|).mni"Reset to Default"=重置为默认
wnd(Log|Project|Std|).mni"Resolve"=解决
wnd(Log|Project|Std|).mni"Retract Merge Request"=撤消合并请求
wnd(Log|Project|Std|).mni"Retract Pull Request"=撤消拉取请求
wnd(Log|Project|Std|).mni"Revert $1"=撤销 $1
wnd(Log|Project|Std|).mni"Review"=评阅
wnd(Log|Project|Std|).mni"Rewrap"=重新包装
wnd(Log|Project|Std|).mni"Select from JIRA"=从 JIRA 中选择
wnd(Log|Project|Std|).mni"Select from Log"=从日志中选择
wnd(Log|Project|Std|).mni"Set '$1' to $2"=将 '$1' 设置为 $2
wnd(Log|Project|Std|).mni"Show All Refs"=显示所有引用
wnd(Log|Project|Std|).mni"Show Auxiliary Branch"=显示辅助分支
wnd(Log|Project|Std|).mni"Show Branch Labels"=显示分支标签
wnd(Log|Project|Std|).mni"Show Common Commits"=显示共同提交
wnd(Log|Project|Std|).mni"Show Incoming Commits"=显示传入提交
wnd(Log|Project|Std|).mni"Show More Commits \(Temporarily\)"=显示更多提交 \(暂时\)
wnd(Log|Project|Std|).mni"Show Only Selected Branches and Tags"=\
 仅显示选定的分支和标签
wnd(Log|Project|Std|).mni"Show Only Selected Refs"=仅显示选定的引用
wnd(Log|Project|Std|).mni"Show Unchanged Directories"=显示未变更的目录
wnd(Log|Project|Std|).mni"Show Working Tree On Demand"=按需显示工作区
wnd(Log|Project|Std|).mni"Show Working Tree Permanently"=永久显示工作区
wnd(Log|Project|Std|).mni"Size"=大小
wnd(Log|Project|Std|).mni"Sort By Time"=按时间排序
wnd(Log|Project|Std|).mni"Sort First Parents before Merge Parents"=\
 Sort First Parents before Merge Parents
wnd(Log|Project|Std|).mni"Sort Merge Parents before First Parents"=\
 Sort Merge Parents before First Parents
wnd(Log|Project|Std|).mni"Squash"=压缩
wnd(Log|Project|Std|).mni"Stage Hunk"=暂存大块
wnd(Log|Project|Std|).mni"Stage Inner-line Change"=暂存行内变更
wnd(Log|Project|Std|).mni"Stage Innerline Change"=暂存行内变更
wnd(Log|Project|Std|).mni"Stage Line"=暂存此行
wnd(Log|Project|Std|).mni"Stage Lines"=暂存这些行
wnd(Log|Project|Std|).mni"Stage Selection"=暂存选中
wnd(Log|Project|Std|).mni"Stash Selection"=贮藏选中
wnd(Log|Project|Std|).mni"State"=状态
wnd(Log|Project|Std|).mni"Subtree"=子树
wnd(Log|Project|Std|).mni"Template!"=模板！
wnd(Log|Project|Std|).mni"Test"=测试
wnd(Log|Project|Std|).mni"Text"=文本
wnd(Log|Project|Std|).mni"Toggle Hosting Provider Integration"=切换托管服务提供商集成
wnd(Log|Project|Std|).mni"Toggle"=切换
wnd(Log|Project|Std|).mni"Varying Coloring"=变色
wnd(Log|Project|Std|).mniAbout=关于 SmartGit
wnd(Log|Project|Std|).mniAdd=创建
wnd(Log|Project|Std|).mniAnnotate=追溯
wnd(Log|Project|Std|).mniAssume-unchanged-toggle=切换 “假设不变”
wnd(Log|Project|Std|).mniBisectBad=将 HEAD 标记为损坏
wnd(Log|Project|Std|).mniBisectExit=重置
wnd(Log|Project|Std|).mniBisectGood=将 HEAD 标记为正常
wnd(Log|Project|Std|).mniBisectStart=开始
wnd(Log|Project|Std|).mniBranchAbort=中止分支
wnd(Log|Project|Std|).mniBranchAdd=创建分支
wnd(Log|Project|Std|).mniBranchAddTag=创建标签
wnd(Log|Project|Std|).mniBranchClose=关闭
wnd(Log|Project|Std|).mniBranchContinue=继续
wnd(Log|Project|Std|).mniBranchDelete=删除分支
wnd(Log|Project|Std|).mniBranchRename=重命名
wnd(Log|Project|Std|).mniBranchResetTracking=停止跟踪
wnd(Log|Project|Std|).mniBranchSetTracking=设置跟踪分支
wnd(Log|Project|Std|).mniBranchSplit=修改或拆分提交
wnd(Log|Project|Std|).mniBranchSplitFiles=拆分文件
wnd(Log|Project|Std|).mniBranchesGitFlowRemoteOnly=在 Git 工作流部分显示远程分支
wnd(Log|Project|Std|).mniBranchesGitFlowTracked=显示远程，跟踪分支
wnd(Log|Project|Std|).mniBranchesSectionize=按路径名称分组标签和分支 (foo/bar)
wnd(Log|Project|Std|).mniBranchesSectionizeAfterLastSlash=在最后一个斜杠后
wnd(Log|Project|Std|).mniBranchesSectionizeCompact=除了单项
wnd(Log|Project|Std|).mniBranchesSectionsBeforeRefs=优先显示组
wnd(Log|Project|Std|).mniBranchesSelectObsolete=选择过时的本地分支
wnd(Log|Project|Std|).mniBranchesSortByName=按名称排序引用
wnd(Log|Project|Std|).mniBranchesSortByNameReversed=按名称排序引用 (数字反转)
wnd(Log|Project|Std|).mniBranchesSortByTime=按提交时间排序引用
wnd(Log|Project|Std|).mniChangesView.compact=压缩
wnd(Log|Project|Std|).mniChangesView.ignoreLineSeparators=忽略行尾序列变更
wnd(Log|Project|Std|).mniChangesView.sideBySide=并排
wnd(Log|Project|Std|).mniChangesView.unified=合并
wnd(Log|Project|Std|).mniCheckForLatestBuild=检查更新 \(编译版本\)
wnd(Log|Project|Std|).mniCheckForNewVersion=检查更新
wnd(Log|Project|Std|).mniCheckout=检出
wnd(Log|Project|Std|).mniCherryPick=摘取
wnd(Log|Project|Std|).mniClean=清理工作区
wnd(Log|Project|Std|).mniClearOutput=清理输出
wnd(Log|Project|Std|).mniCommit=提交
wnd(Log|Project|Std|).mniCompact-display=紧凑型显示
wnd(Log|Project|Std|).mniCompareWithWorkingTree=与工作区比较
wnd(Log|Project|Std|).mniConfigureTagGrouping=标签分组
wnd(Log|Project|Std|).mniConfigureToolbar=配置工具栏
wnd(Log|Project|Std|).mniConflictSolver=冲突解决工具
wnd(Log|Project|Std|).mniContactSupport=技术支持
wnd(Log|Project|Std|).mniCopyCommitId=复制 ID
wnd(Log|Project|Std|).mniCopyCommitMessage=复制消息
wnd(Log|Project|Std|).mniCopyName=复制文件名
wnd(Log|Project|Std|).mniCopyPath=复制路径
wnd(Log|Project|Std|).mniCopyRelativePath=复制相对路径
wnd(Log|Project|Std|).mniCustomize=自定义
wnd(Log|Project|Std|).mniDebugCreateHeapDump=创建堆转储
wnd(Log|Project|Std|).mniDebugCreateThreadDumps=创建定期线程转储
wnd(Log|Project|Std|).mniDebugEnableRefreshTraceLogging=开始跟踪刷新
wnd(Log|Project|Std|).mniDebugLogFileMonitorEvents=记录文件监控事件
wnd(Log|Project|Std|).mniDebugLogFileMonitorState=记录文件监控状态
wnd(Log|Project|Std|).mniDebugLogOpenRepositories=记录打开仓库
wnd(Log|Project|Std|).mniDebugRestart=重新开始
wnd(Log|Project|Std|).mniDebugRunGc=运行垃圾回收 \(GC\)
wnd(Log|Project|Std|).mniDelete=删除
wnd(Log|Project|Std|).mniDiscard=丢弃
wnd(Log|Project|Std|).mniEdit-ignore-case-changes=忽略行比较的大小写变更
wnd(Log|Project|Std|).mniEditCommitAuthor=编辑作者
wnd(Log|Project|Std|).mniEditCommitMessage=编辑提交消息
wnd(Log|Project|Std|).mniEditFile=编辑文件
wnd(Log|Project|Std|).mniExit=退出
wnd(Log|Project|Std|).mniFastForward=快进合并
wnd(Log|Project|Std|).mniFetch=拉取
wnd(Log|Project|Std|).mniFile-close=关闭
wnd(Log|Project|Std|).mniFilterCommits=过滤提交
wnd(Log|Project|Std|).mniFilterFiles=过滤文件
wnd(Log|Project|Std|).mniFindAction=查找命令
wnd(Log|Project|Std|).mniFindObject=查找对象
wnd(Log|Project|Std|).mniFixup=修复
wnd(Log|Project|Std|).mniFlowConfigure=配置
wnd(Log|Project|Std|).mniFlowContext=Git 工作流
wnd(Log|Project|Std|).mniFlowFeatureFinish=完成 Feature
wnd(Log|Project|Std|).mniFlowFeatureStart=开始 Feature
wnd(Log|Project|Std|).mniFlowHotfixFinish=完成 Hotfix
wnd(Log|Project|Std|).mniFlowHotfixStart=开始 Hotfix
wnd(Log|Project|Std|).mniFlowIntegrateDevelop=整合开发
wnd(Log|Project|Std|).mniFlowReleaseFinish=完成 Release
wnd(Log|Project|Std|).mniFlowReleaseStart=开始 Release
wnd(Log|Project|Std|).mniFlowSupportStart=开始 Support 分支
wnd(Log|Project|Std|).mniForgetCommit=忘记提交
wnd(Log|Project|Std|).mniGoto-next-diff=下一处差异
wnd(Log|Project|Std|).mniGoto-previous-diff=上一处差异
wnd(Log|Project|Std|).mniGotoChildrenCommit=选择子提交
wnd(Log|Project|Std|).mniGotoParentsCommit=选择父提交
wnd(Log|Project|Std|).mniIgnore=忽略
wnd(Log|Project|Std|).mniIgnore-line-separators=忽略行尾序列变更
wnd(Log|Project|Std|).mniIgnoreReveal=编辑忽略文件
wnd(Log|Project|Std|).mniIncludeTrackedRemoteBranches=包括跟踪远程分支
wnd(Log|Project|Std|).mniIndexEditor=索引编辑器
wnd(Log|Project|Std|).mniInvestigate=审查
wnd(Log|Project|Std|).mniLfsInstall=安装
wnd(Log|Project|Std|).mniLfsLock=加锁
wnd(Log|Project|Std|).mniLfsPrune=修剪
wnd(Log|Project|Std|).mniLfsTrack=跟踪
wnd(Log|Project|Std|).mniLfsUnlock=解锁
wnd(Log|Project|Std|).mniLicenseAgreement=许可协议
wnd(Log|Project|Std|).mniLocalGc=运行垃圾收集器
wnd(Log|Project|Std|).mniLog=日志
wnd(Log|Project|Std|).mniLogCommitsColoringBranch=分支着色
wnd(Log|Project|Std|).mniLogCommitsColoringDefault=默认着色
wnd(Log|Project|Std|).mniLogCommitsColoringLegacy=变色
wnd(Log|Project|Std|).mniLogCommitsColoringMerge=可合并着色
wnd(Log|Project|Std|).mniLogRepository=日志窗口
wnd(Log|Project|Std|).mniLogShowAllParents=关注所有父系
wnd(Log|Project|Std|).mniLogShowOnlyFirstParents=只显示第一个父系
wnd(Log|Project|Std|).mniLogTopoFiltering=筛选时显示图形
wnd(Log|Project|Std|).mniLogWorkingTreeIndexOnDemand=按需显示工作区索引
wnd(Log|Project|Std|).mniLogWorkingTreeIndexPermanent=永久显示工作区索引
wnd(Log|Project|Std|).mniMailingList=SmartGit 官方网站
wnd(Log|Project|Std|).mniMerge=合并
wnd(Log|Project|Std|).mniModifyCommit=修改
wnd(Log|Project|Std|).mniNewStandardWindow=显示标准窗口
wnd(Log|Project|Std|).mniNewWindow=新窗口
wnd(Log|Project|Std|).mniOpen=打开
wnd(Log|Project|Std|).mniOpenDocumentation=在线文档
wnd(Log|Project|Std|).mniOpenRootLog=打开根日志
wnd(Log|Project|Std|).mniOpenUserEcho=功能请求
wnd(Log|Project|Std|).mniOpenWorkingTree=打开工作区
wnd(Log|Project|Std|).mniPreferences=偏好设置
wnd(Log|Project|Std|).mniPreviewCommentNext=下一条注释
wnd(Log|Project|Std|).mniPreviewCommentPrevious=上一条注释
wnd(Log|Project|Std|).mniPreviewCompareAutomatic=自动
wnd(Log|Project|Std|).mniPreviewCompareHeadVsIndex=HEAD 与索引
wnd(Log|Project|Std|).mniPreviewCompareIndexVsWT=索引与工作区
wnd(Log|Project|Std|).mniPreviewRefresh=刷新
wnd(Log|Project|Std|).mniPreviewShowCurrentLines=显示长的当前行
wnd(Log|Project|Std|).mniPreviewUndo=撤销
wnd(Log|Project|Std|).mniPush=推送
wnd(Log|Project|Std|).mniPushCommits=推送提交
wnd(Log|Project|Std|).mniPushTo=推送到
wnd(Log|Project|Std|).mniPushToGerrit=推送到 Gerrit
wnd(Log|Project|Std|).mniRebaseAbort=中止
wnd(Log|Project|Std|).mniRebaseContinue=继续
wnd(Log|Project|Std|).mniRebaseHeadTo=将 HEAD 变基至
wnd(Log|Project|Std|).mniRebaseInteractive=交互式变基至
wnd(Log|Project|Std|).mniRebaseSkip=跳过
wnd(Log|Project|Std|).mniRebaseStep=步骤
wnd(Log|Project|Std|).mniRebaseToHead=变基至 HEAD
wnd(Log|Project|Std|).mniRebaseToHead"Rebase to HEAD \($1\)"=变基至 HEAD \($1\)
wnd(Log|Project|Std|).mniRebaseToHead"Rebase to HEAD"=变基至 HEAD
wnd(Log|Project|Std|).mniRefresh=刷新
wnd(Log|Project|Std|).mniRegister=注册产品
wnd(Log|Project|Std|).mniRemoteAdd=创建
wnd(Log|Project|Std|).mniRemoteCopyUrl=复制网址
wnd(Log|Project|Std|).mniRemoteDelete=删除
wnd(Log|Project|Std|).mniRemoteFetch=获取
wnd(Log|Project|Std|).mniRemoteFetchAll=获取所有
wnd(Log|Project|Std|).mniRemoteFetchMore=获取更多
wnd(Log|Project|Std|).mniRemoteProperties=属性
wnd(Log|Project|Std|).mniRemoteRename=重命名
wnd(Log|Project|Std|).mniRemove=移除
wnd(Log|Project|Std|).mniRename=重命名
wnd(Log|Project|Std|).mniRepositoryAdd=添加或创建
wnd(Log|Project|Std|).mniRepositoryAddGroup=创建分组
wnd(Log|Project|Std|).mniRepositoryClone=克隆
wnd(Log|Project|Std|).mniRepositoryClose=关闭
wnd(Log|Project|Std|).mniRepositoryEditConfig=仓库
wnd(Log|Project|Std|).mniRepositoryEditConfigUser=用户
wnd(Log|Project|Std|).mniRepositoryFavorite=取消标记为收藏夹
wnd(Log|Project|Std|).mniRepositoryFavorite"Mark as Favorite"=标记为收藏
wnd(Log|Project|Std|).mniRepositoryFavorite"Unmark as Favorite"=取消标记收藏
wnd(Log|Project|Std|).mniRepositoryOpen=打开仓库
wnd(Log|Project|Std|).mniRepositoryOpenInNewWindow=在新窗口中打开仓库
wnd(Log|Project|Std|).mniRepositoryRemove=删除
wnd(Log|Project|Std|).mniRepositoryRename=重命名
wnd(Log|Project|Std|).mniRepositorySearch=搜索仓库
wnd(Log|Project|Std|).mniRepositorySelectObsolete=选择过时的仓库
wnd(Log|Project|Std|).mniRepositorySettings=设置
wnd(Log|Project|Std|).mniReset=重置提交
wnd(Log|Project|Std|).mniResetAdvanced=重置提交 \(高级\)
wnd(Log|Project|Std|).mniResolve=解决
wnd(Log|Project|Std|).mniResolveOurs=采用 我们的
wnd(Log|Project|Std|).mniResolveRecreateConflict=重现冲突
wnd(Log|Project|Std|).mniResolveTheirs=采用 他们的
wnd(Log|Project|Std|).mniRevealCommit=显示提交
wnd(Log|Project|Std|).mniRevealCommitExtend=与选中提交比较
wnd(Log|Project|Std|).mniRevealCommitWithHead=与 HEAD 比较
wnd(Log|Project|Std|).mniRevealPrevCommit=显示先前的提交
wnd(Log|Project|Std|).mniRevealWorkingTree=显示工作区
wnd(Log|Project|Std|).mniRevert=还原
wnd(Log|Project|Std|).mniReviewCommentCreate=添加注释
wnd(Log|Project|Std|).mniReviewConfigure=配置
wnd(Log|Project|Std|).mniReviewDumpDatabase=转储数据库
wnd(Log|Project|Std|).mniReviewPullRequestCreate=创建拉取请求
wnd(Log|Project|Std|).mniReviewPullRequestCreate"Create Merge Request"=创建合并请求
wnd(Log|Project|Std|).mniReviewPullRequestCreate"Create Pull Request"=创建拉取请求
wnd(Log|Project|Std|).mniReviewShowClosedPullRequests=显示已关闭的拉取请求
wnd(Log|Project|Std|).mniReviewSync=同步
wnd(Log|Project|Std|).mniRewriteTextFile=修复换行符
wnd(Log|Project|Std|).mniSaveAs=另存为
wnd(Log|Project|Std|).mniSearch-find=查找
wnd(Log|Project|Std|).mniSearch-next=查找下一处
wnd(Log|Project|Std|).mniSearch-previous=查找上一处
wnd(Log|Project|Std|).mniSelectCommittableFiles=选择可提交文件
wnd(Log|Project|Std|).mniSelectDirectory=选择目录
wnd(Log|Project|Std|).mniSelectRoot=选择仓库根目录
wnd(Log|Project|Std|).mniSet-syntax=语言模式
wnd(Log|Project|Std|).mniSetDepth=设置深度
wnd(Log|Project|Std|).mniShow-line-numbers=显示行号
wnd(Log|Project|Std|).mniShowChanges=显示变更
wnd(Log|Project|Std|).mniSkipWorkTree=切换 “跳过工作区”
wnd(Log|Project|Std|).mniSortCommitsAsIs=按时间排序提交
wnd(Log|Project|Std|).mniSortCommitsFirstParentsBeforeMergeParents=Sort First Parents before Merge Parents
wnd(Log|Project|Std|).mniSortCommitsMergeParentsBeforeFirstParents=Sort Merge Parents before First Parents
wnd(Log|Project|Std|).mniSplitCommit=拆分
wnd(Log|Project|Std|).mniSquashCommits=压缩提交
wnd(Log|Project|Std|).mniStage=暂存
wnd(Log|Project|Std|).mniStashApply=应用贮藏
wnd(Log|Project|Std|).mniStashDrop=丢弃贮藏
wnd(Log|Project|Std|).mniStashRename=重命名贮藏
wnd(Log|Project|Std|).mniStashSave=贮藏所有
wnd(Log|Project|Std|).mniStashSaveSelection=贮藏选中
wnd(Log|Project|Std|).mniSubmoduleDeactivate=停用
wnd(Log|Project|Std|).mniSubmoduleDeinit=定义
wnd(Log|Project|Std|).mniSubmoduleInit=初始化
wnd(Log|Project|Std|).mniSubmoduleRegister=创建
wnd(Log|Project|Std|).mniSubmoduleReset=重置
wnd(Log|Project|Std|).mniSubmoduleSync=同步
wnd(Log|Project|Std|).mniSubmoduleUnregister=注销
wnd(Log|Project|Std|).mniSubtreeAdd=创建
wnd(Log|Project|Std|).mniSubtreeMerge=合并
wnd(Log|Project|Std|).mniSubtreePush=推送
wnd(Log|Project|Std|).mniSubtreeReset=重置
wnd(Log|Project|Std|).mniSubtreeSplit=拆分
wnd(Log|Project|Std|).mniSync=同步
wnd(Log|Project|Std|).mniUndoLastCommit=取消最后一次提交
wnd(Log|Project|Std|).mniUnstage=取消暂存
wnd(Log|Project|Std|).mniView-ignore-whitespaces-all=忽略所有空白字符变化
wnd(Log|Project|Std|).mniView-ignore-whitespaces-leading-trailing=行比较时忽略前导/尾随空格
wnd(Log|Project|Std|).mniView-ignore-whitespaces-none=行比较时忽略没有用于比较的空格
wnd(Log|Project|Std|).mniView-remember-as-default=记住默认
wnd(Log|Project|Std|).mniView-settings=设置
wnd(Log|Project|Std|).mniView-show-current-line-control=显示长的当前行
wnd(Log|Project|Std|).mniViewFromSubmodules=从子模块显示文件
wnd(Log|Project|Std|).mniViewIgnored=显示忽略文件
wnd(Log|Project|Std|).mniViewRecursive=来自子目录的文件
wnd(Log|Project|Std|).mniViewRenameSource=显示重命名源文件
wnd(Log|Project|Std|).mniViewSeparateWtAndIndex=单独的工作区和索引
wnd(Log|Project|Std|).mniViewSetAnchorCommit=设置锚点提交
wnd(Log|Project|Std|).mniViewSkipped=显示跳过文件
wnd(Log|Project|Std|).mniViewStaged=显示暂存文件
wnd(Log|Project|Std|).mniViewStyleIndex=只有索引
wnd(Log|Project|Std|).mniViewStyleMixed=混合
wnd(Log|Project|Std|).mniViewStyleWorkingTree=仅工作区
wnd(Log|Project|Std|).mniViewToolBar=显示工具栏
wnd(Log|Project|Std|).mniViewUnchanged=显示未变更的文件
wnd(Log|Project|Std|).mniViewUnchangedAssumed=显示 “假设不变” 的文件
wnd(Log|Project|Std|).mniViewUnversioned=显示无版本文件
wnd(Log|Project|Std|).mniWindowBranches=分支视图
wnd(Log|Project|Std|).mniWindowChanges=变更视图
wnd(Log|Project|Std|).mniWindowClose=关闭
wnd(Log|Project|Std|).mniWindowComments=注释视图
wnd(Log|Project|Std|).mniWindowCommit=提交视图
wnd(Log|Project|Std|).mniWindowDebugLog=调试记录
wnd(Log|Project|Std|).mniWindowDirectories=仓库视图
wnd(Log|Project|Std|).mniWindowFiles=文件视图
wnd(Log|Project|Std|).mniWindowGraph=图形视图
wnd(Log|Project|Std|).mniWindowHideView=隐藏选中视图
wnd(Log|Project|Std|).mniWindowJournal=日志视图
wnd(Log|Project|Std|).mniWindowLayoutSetMain=主要审阅
wnd(Log|Project|Std|).mniWindowLayoutSetReview=审阅视角
wnd(Log|Project|Std|).mniWindowOutput=输出视图
wnd(Log|Project|Std|).mniWindowWorkingTree=工作区窗口
wnd(Log|Project|Std|).mniWorktreeAdd=创建工作区
wnd(Log|Project|Std|).mniWorktreePrune=修剪过时的工作区
wnd(Log|Project|Std|).mniWorktreeRemove=远程工作树
wnd(Log|Project|Std|).mnu"Bisect"=二分
wnd(Log|Project|Std|).mnu"Branch"=分支
wnd(Log|Project|Std|).mnu"Branches"=分支
wnd(Log|Project|Std|).mnu"Changes"=变更
wnd(Log|Project|Std|).mnu"Commits"=提交
wnd(Log|Project|Std|).mnu"Debug"=调试
wnd(Log|Project|Std|).mnu"Edit Git Config"=编辑 Git 配置文件
wnd(Log|Project|Std|).mnu"Edit"=编辑
wnd(Log|Project|Std|).mnu"Git-Flow"=Git 工作流
wnd(Log|Project|Std|).mnu"Help"=帮助
wnd(Log|Project|Std|).mnu"LFS"=LFS
wnd(Log|Project|Std|).mnu"Local"=本地
wnd(Log|Project|Std|).mnu"Query"=查询
wnd(Log|Project|Std|).mnu"Rebase"=变基
wnd(Log|Project|Std|).mnu"Remote"=远程
wnd(Log|Project|Std|).mnu"Repositories"=仓库
wnd(Log|Project|Std|).mnu"Repository"=仓库
wnd(Log|Project|Std|).mnu"Resolve"=解决
wnd(Log|Project|Std|).mnu"Review"=审阅
wnd(Log|Project|Std|).mnu"Submodule"=子模块
wnd(Log|Project|Std|).mnu"Subtree"=子树
wnd(Log|Project|Std|).mnu"Tools"=工具
wnd(Log|Project|Std|).mnu"View"=视图
wnd(Log|Project|Std|).tab"Branches"=分支
wnd(Log|Project|Std|).tab"Changes of $1 - $2 \($3\)"=\
 $1 - $2 \($3\)
wnd(Log|Project|Std|).tab"Changes of $1 - $2"=$1 - $2
wnd(Log|Project|Std|).tab"Changes of $1 \($2\) - $3"=\
 $1 \($2\) - $3
wnd(Log|Project|Std|).tab"Changes of $1 \($2\)"=$1 \($2\)
wnd(Log|Project|Std|).tab"Changes"=变更
wnd(Log|Project|Std|).tab"Comments \($1\)"=备注 \($1\)
wnd(Log|Project|Std|).tab"Comments"=注释
wnd(Log|Project|Std|).tab"Commit Message"=提交信息
wnd(Log|Project|Std|).tab"Commit"=提交
wnd(Log|Project|Std|).tab"Debug Log"=调试记录
wnd(Log|Project|Std|).tab"Files \(Working Tree\)"=文件 \(工作副本\)
wnd(Log|Project|Std|).tab"Files"=文件
wnd(Log|Project|Std|).tab"Graph \(Initializing Log-Cache...\)"=图形 \(初始化 日志缓存...\)
wnd(Log|Project|Std|).tab"Graph \(Initializing Subtree-Cache...\)"=图形 \(初始化 Subtree 缓存...\)
wnd(Log|Project|Std|).tab"Graph \(Initializing...\)"=图形 \(初始化...\)
wnd(Log|Project|Std|).tab"Graph \(Loading...\)"=图形 \(载入中...\)
wnd(Log|Project|Std|).tab"Graph \(Running log...\)"=图形 \(运行日志...\)
wnd(Log|Project|Std|).tab"Graph \(Scanning WT...\)"=图形 \(扫描 WT...\)
wnd(Log|Project|Std|).tab"Graph"=图形
wnd(Log|Project|Std|).tab"Journal"=日志
wnd(Log|Project|Std|).tab"Output"=输出
wnd(Log|Project|Std|).tab"Repositories"=仓库
wnd(Log|Project|Std|).tbr"  History  "=历史
wnd(Log|Project|Std|).tbr"Add Tag"=创建标签
wnd(Log|Project|Std|).tbr"Add or Create"=添加或创建
wnd(Log|Project|Std|).tbr"Add"=创建
wnd(Log|Project|Std|).tbr"Apply Stash"=应用贮藏
wnd(Log|Project|Std|).tbr"Blame"=追溯
wnd(Log|Project|Std|).tbr"Branch"=分支
wnd(Log|Project|Std|).tbr"Changes"=变更
wnd(Log|Project|Std|).tbr"Check Out"=检出
wnd(Log|Project|Std|).tbr"Cherry-Pick"=摘取
wnd(Log|Project|Std|).tbr"Clone"=克隆
wnd(Log|Project|Std|).tbr"Commit"=提交
wnd(Log|Project|Std|).tbr"Compact"=紧凑
wnd(Log|Project|Std|).tbr"Conflict Solver"=冲突解决工具
wnd(Log|Project|Std|).tbr"Delete"=删除
wnd(Log|Project|Std|).tbr"Discard"=丢弃
wnd(Log|Project|Std|).tbr"Drop Stash"=丢弃贮藏
wnd(Log|Project|Std|).tbr"Fetch"=拉取
wnd(Log|Project|Std|).tbr"Finish"=完成
wnd(Log|Project|Std|).tbr"Git-Flow"=Git 工作流
wnd(Log|Project|Std|).tbr"Ignore"=忽略
wnd(Log|Project|Std|).tbr"Index Editor"=索引编辑器
wnd(Log|Project|Std|).tbr"Integrate"=集成
wnd(Log|Project|Std|).tbr"Investigate"=审查
wnd(Log|Project|Std|).tbr"Local Files"=本地文件
wnd(Log|Project|Std|).tbr"Log Selection"=日志选择
wnd(Log|Project|Std|).tbr"Log"=日志
wnd(Log|Project|Std|).tbr"Main"=主
wnd(Log|Project|Std|).tbr"Merge"=合并
wnd(Log|Project|Std|).tbr"Pull"=拉取
wnd(Log|Project|Std|).tbr"Push To"=推送到
wnd(Log|Project|Std|).tbr"Push"=推送
wnd(Log|Project|Std|).tbr"Rebase"=变基
wnd(Log|Project|Std|).tbr"Refresh"=刷新
wnd(Log|Project|Std|).tbr"Remove"=移除
wnd(Log|Project|Std|).tbr"Reset Adv."=高级重置。
wnd(Log|Project|Std|).tbr"Reset"=重置
wnd(Log|Project|Std|).tbr"Revert"=还原
wnd(Log|Project|Std|).tbr"Review"=审阅
wnd(Log|Project|Std|).tbr"Save Stash"=贮藏
wnd(Log|Project|Std|).tbr"Search"=搜索
wnd(Log|Project|Std|).tbr"Side by Side"=并列
wnd(Log|Project|Std|).tbr"Stage"=暂存
wnd(Log|Project|Std|).tbr"Start"=开始
wnd(Log|Project|Std|).tbr"Sync"=同步
wnd(Log|Project|Std|).tbr"Unified"=合并
wnd(Log|Project|Std|).tbr"Unstage"=取消暂存
wnd(Log|Project|Std|).tbt"Clear logging."=清除记录。
wnd(Log|Project|Std|).tbt"Commit Message History"=提交消息历史
wnd(Log|Project|Std|).tbt"Hosting provider is not configured for the current repository. Go to the Preferences to add a configuration."=\
 当前仓库未配置主机提供商。前往 “偏好设置” 创建配置。
wnd(Log|Project|Std|).tbt"If selected, files from subdirectories are shown."=\
 如果选定该属性，将显示子目录中的文件。
wnd(Log|Project|Std|).tbt"If selected, the directories will be shown."=\
 选中则显示目录.
wnd(Log|Project|Std|).tbt"Indicates how many files or directories are selected."=\
 展示有多少个文件或目录被选中.
wnd(Log|Project|Std|).tbt"Interpret the search pattern as regular expression."=\
 把搜索通配理解为正则表达式.
wnd(Log|Project|Std|).tbt"Options"=选项
wnd(Log|Project|Std|).tbt"Reading incoming merge requests from '$1'."=\
 从 '$1' 读取收到的合并请求.
wnd(Log|Project|Std|).tbt"Reading repository info from '$1'."=从 '$1' 读取仓库信息.
wnd(Log|Project|Std|).tbt"Refresh information from GitLab."=刷新 GitLab 的信息。
wnd(Log|Project|Std|).tbt"Show directories tree"=显示目录树
wnd(Log|Project|Std|).tbtAnnotate=显示所选文件的追溯 \(注释\) 视图。
wnd(Log|Project|Std|).tbtBranchAdd=为当前提交添加新分支。
wnd(Log|Project|Std|).tbtBranchAddTag=为当前提交添加新标签。
wnd(Log|Project|Std|).tbtCheckout=检出一个现有提交。
wnd(Log|Project|Std|).tbtCherryPick=合并来自其他分支的修改.
wnd(Log|Project|Std|).tbtClearOutput=清除输出窗格。
wnd(Log|Project|Std|).tbtCommit=提交本地变更。
wnd(Log|Project|Std|).tbtConflictSolver=打开冲突解决进程 \(或配置的外部合并工具\) 以解决冲突。
wnd(Log|Project|Std|).tbtDelete=删除选定的本地文件或目录。
wnd(Log|Project|Std|).tbtDiscard=丢弃本地变更。
wnd(Log|Project|Std|).tbtFetch=从远程仓库获取提交并 \(可选\) 将它们与本地提交集成。
wnd(Log|Project|Std|).tbtFlowContext=完成 Git 工作流功能。
wnd(Log|Project|Std|).tbtFlowFeatureFinish=完成 Git 流功能。
wnd(Log|Project|Std|).tbtFlowFeatureStart=启动新的 Git 流功能。
wnd(Log|Project|Std|).tbtFlowHotfixFinish=完成 Git 流热修复进程。
wnd(Log|Project|Std|).tbtFlowHotfixStart=启动新的 Git 流热修复进程。
wnd(Log|Project|Std|).tbtFlowIntegrateDevelop=将新的基本提交集成到 Git 流功能中。
wnd(Log|Project|Std|).tbtGoto-next-diff=下一处差异。
wnd(Log|Project|Std|).tbtGoto-previous-diff=上一处差异。
wnd(Log|Project|Std|).tbtIgnore=标记要忽略的未版本控制的本地文件/目录。
wnd(Log|Project|Std|).tbtIndexEditor=编辑所选文件的索引状态，例如：决定哪些行应该被暂存.
wnd(Log|Project|Std|).tbtInvestigate=使用 DeepGit 逐行审查历史记录。
wnd(Log|Project|Std|).tbtLog=显示所选文件或目录的历史日志。
wnd(Log|Project|Std|).tbtLogRepository=显示整个仓库的历史日志。
wnd(Log|Project|Std|).tbtMerge=合并来自其他分支的变更。
wnd(Log|Project|Std|).tbtPreviewRefresh=重新加载预览的文件内容。
wnd(Log|Project|Std|).tbtPush=将本地提交推送到远程源仓库。
wnd(Log|Project|Std|).tbtPushTo=将本地提交推送到远程仓库，允许选择目标仓库。
wnd(Log|Project|Std|).tbtRebaseHeadTo=将 HEAD 提交应用于所选提交。
wnd(Log|Project|Std|).tbtRefresh=刷新日志视图。
wnd(Log|Project|Std|).tbtRemoteFetch=从所有远程仓库获取提交。
wnd(Log|Project|Std|).tbtRemove=从仓库中删除选定的文件或目录。
wnd(Log|Project|Std|).tbtRepositoryAdd=添加或创建新的仓库。
wnd(Log|Project|Std|).tbtRepositoryClone=克隆新的仓库。
wnd(Log|Project|Std|).tbtRepositorySearch=搜索现有仓库。
wnd(Log|Project|Std|).tbtReset=将当前 HEAD 重置为新的提交。
wnd(Log|Project|Std|).tbtResetAdvanced=将当前 HEAD 重置为新的提交，并保留索引或工作区中的差异。
wnd(Log|Project|Std|).tbtRevealHomeCommit=在图表中显示 HEAD/工作区.
wnd(Log|Project|Std|).tbtRevealPrevCommit=在调用显示工作区之前显示所选的提交。
wnd(Log|Project|Std|).tbtRevealWorkingTree=在图中显示工作区节点。
wnd(Log|Project|Std|).tbtRevert=通过 "反向" 合并来撤销现有提交的修改。
wnd(Log|Project|Std|).tbtShowChanges=打开所选文件的文件比较。
wnd(Log|Project|Std|).tbtStage=将工作区文件暂存在索引中以准备下一次提交。
wnd(Log|Project|Std|).tbtStashApply=从贮藏中重新应用本地变更。
wnd(Log|Project|Std|).tbtStashDrop=从仓库中删除一个或多个贮藏。
wnd(Log|Project|Std|).tbtStashSave=贮藏当前的本地变更。
wnd(Log|Project|Std|).tbtStdSetModeHistory=显示历史记录视图。
wnd(Log|Project|Std|).tbtStdSetModeWt=显示仓库 \(工作区\)的本地文件。
wnd(Log|Project|Std|).tbtSync=推送当前分支的本地提交并拉取远程变更。
wnd(Log|Project|Std|).tbtUnstage=从索引中删除暂存变更。
wnd(Log|Project|Std|).tbtViewFromSubmodules=如果选中，将显示子模块中的文件。
wnd(Log|Project|Std|).tbtViewIgnored=如果选中，将显示忽略的文件。
wnd(Log|Project|Std|).tbtViewRenameSource=如果选中，将显示检测到的重命名的已删除/丢失的源文件。
wnd(Log|Project|Std|).tbtViewSkipped=如果选中，将显示跳过的文件。
wnd(Log|Project|Std|).tbtViewStaged=如果选中，将显示具有暂存 \(Index\) 变更且未变更工作区的文件。
wnd(Log|Project|Std|).tbtViewUnchanged=如果选中，将显示未变更的文件。
wnd(Log|Project|Std|).tbtViewUnchangedAssumed=如果选中，将显示具有 “假设不变” 标志的文件。
wnd(Log|Project|Std|).tbtViewUnversioned=如果选中，未加入版本控制的文件将会显示。
wnd(Log|Project|Std|).tbtWindowLayoutSetMain=切换到主透视图。
wnd(Log|Project|Std|).tbtWindowLayoutSetReview=切换到审阅透视图。
